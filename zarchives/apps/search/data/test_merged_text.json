[
    {
      "file_name": "97_Things_Every_Programmer_Should_Know.pdf",
      "mergedText": "\n[image: image0.jpg] 97 Collective Wisdom from the Experts 97 Things Every Programmer Should Know O'REILLY\u00ae Edited by Kevlin Henney \n\n\n\n[image: image1.jpg] 97 Programming 97 Things Every Programmer Should Know Tap into the wisdom of experts to learn what every programmer should know, no matter what language you use. With the 97 short and extremely useful tips for programmers in this book, you'll expand your skills by adopting new approaches to old problems, learning appropriate best practices, and honing your craft through sound advice. With contributions from some of the most experienced and respected practi- tioners in the industry-including Michael Feathers, Pete Goodliffe, Diomidis Spinellis, Cay Horstmann, Verity Stob, and many more-this book contains practical knowledge and principles that you can apply to all kinds of projects. A few of the 97 things you should know: Code in the Language of the Domain (Dan North) Write Tests for People (Gerard Meszaros) Convenience Is Not an -ility (Gregor Hohpe) = Know Your IDE (Heinz Kabutz) A Message to the Future (Linda Rising) . The Boy Scout Rule (Robert C. Martin, aka Uncle Bob) Beware the Share (Udi Dahan) Kevlin Henney is an independent consultant, trainer, and author who focuses on programming, patterns, practice, and process. He is coauthor of two volumes in the Pattern-Oriented Software Architecture series: A Pattern Language for Distributed Computing and On Patterns and Pattern Languages (Wiley). oreilly.com O'REILLY US $29.99 CAN $37.99 ISBN: 978-0-596-80948-5 Safari Free online edition 52999 for 45 days with Books Online purchase of this book. 9 780596 809485 Details on last page. \n\n\n\n97 Things\nEvery Programmer Should Know\n\nCollective Wisdom from the Experts\n\nEdited by Kevlin Henney\n\nBeijing \u00b7 Cambridge \u00b7 Farnham \u00b7 K\u00f6ln \u00b7 Sebastopol \u00b7 Taipei \u00b7 Tokyo\n\n\n\n97 Things Every Programmer Should Know\nEdited by Kevlin Henney\n\nCopyright \u00a9 2010 Kevlin Henney. All rights reserved.\nPrinted in the United States of America.\n\nPublished by O\u2019Reilly Media, Inc. 1005 Gravenstein Highway North, Sebastopol CA 95472\n\nO\u2019Reilly books may be purchased for educational, business, or sales promotional use. Online \neditions are also available for most titles (http://my.safaribooksonline.com). For more information, \ncontact our corporate/institutional sales department: (800) 998-9938 or corporate@oreilly.com. \n\nEditor: Mike Loukides\nSeries Editor: Richard Monson-Haefel\nProduction Editor: Rachel Monaghan\nProofreader: Rachel Monaghan\n\nCompositor: Ron Bilodeau\nIndexer: Julie Hawks\nInterior Designer: Ron Bilodeau\nCover Designers: Mark Paglietti and  \n         Susan Thompson\n\nPrint History: \n\n February 2010:  First Edition.\n\nThe O\u2019Reilly logo is a registered trademark of O\u2019Reilly Media, Inc. 97 Things Every Programmer \nShould Know and related trade dress are trademarks of O\u2019Reilly Media, Inc.\n\nMany of the designations used by manufacturers and sellers to distinguish their products are \nclarified as trademarks. Where those designations appear in this book, and O\u2019Reilly Media, Inc. \nwas aware of a trademark claim, the designations have been printed in caps or initial caps.\n\nWhile every precaution has been taken in the preparation of this book, the publisher and au-\nthors assume no responsibility for errors and omissions, or for damages resulting from the use \nof the information contained herein.\n\nThis book uses Repkover,\u2122 a durable and flexible lay-flat binding.\n\nISBN: 978-0-596-80948-5\n\n[SB]\n\n[image: image2.jpg]\n\nTo absent friends\n\n\n\n\n\nv\n\nContents\n\nContributions by Category . . . . . . . . . . . . . . . . . . . . . xv\n\nPreface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxiii\n\nAct with Prudence . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\nSeb Rose\n\nApply Functional Programming Principles . . . . . . . . . . . . 4\n\nEdward Garson\n\nAsk, \u201cWhat Would the User Do?\u201d (You Are Not the User) . . 6\n\nGiles Colborne\n\nAutomate Your Coding Standard . . . . . . . . . . . . . . . . . . 8\n\nFilip van Laenen\n\nBeauty Is in Simplicity . . . . . . . . . . . . . . . . . . . . . . . . 10\n\nJ\u00f8rn \u00d8lmheim\n\nBefore You Refactor . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\nRajith Attapattu\n\nBeware the Share . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\nUdi Dahan\n\n\n\nvi Contents\n\nThe Boy Scout Rule . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n\nRobert C. Martin (Uncle Bob)\n\nCheck Your Code First Before Looking to Blame Others . . . 18\n\nAllan Kelly\n\nChoose Your Tools with Care . . . . . . . . . . . . . . . . . . . 20\n\nGiovanni Asproni\n\nCode in the Language of the Domain . . . . . . . . . . . . . . 22\n\nDan North\n\nCode Is Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\nRyan Brush\n\nCode Layout Matters . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\nSteve Freeman\n\nCode Reviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\nMattias Karlsson\n\nCoding with Reason . . . . . . . . . . . . . . . . . . . . . . . . . 30\n\nYechiel Kimchi\n\nA Comment on Comments . . . . . . . . . . . . . . . . . . . . . 32\n\nCal Evans\n\nComment Only What the Code Cannot Say . . . . . . . . . . 34\n\nKevlin Henney\n\nContinuous Learning . . . . . . . . . . . . . . . . . . . . . . . . . 36\n\nClint Shank\n\nConvenience Is Not an -ility . . . . . . . . . . . . . . . . . . . . 38\n\nGregor Hohpe\n\n\n\nviiContents\n\nDeploy Early and Often . . . . . . . . . . . . . . . . . . . . . . . 40\n\nSteve Berczuk\n\nDistinguish Business Exceptions from Technical . . . . . . . 42\n\nDan Bergh Johnsson\n\nDo Lots of Deliberate Practice. . . . . . . . . . . . . . . . . . . 44\n\nJon Jagger\n\nDomain-Specific Languages . . . . . . . . . . . . . . . . . . . . 46\n\nMichael Hunger\n\nDon\u2019t Be Afraid to Break Things . . . . . . . . . . . . . . . . . 48\n\nMike Lewis\n\nDon\u2019t Be Cute with Your Test Data . . . . . . . . . . . . . . . . 50\n\nRod Begbie\n\nDon\u2019t Ignore That Error! . . . . . . . . . . . . . . . . . . . . . . . 52\n\nPete Goodliffe\n\nDon\u2019t Just Learn the Language, Understand Its Culture . . 54\n\nAnders Nor\u00e5s\n\nDon\u2019t Nail Your Program into the Upright Position . . . . . . 56\n\nVerity Stob\n\nDon\u2019t Rely on \u201cMagic Happens Here\u201d . . . . . . . . . . . . . . 58\n\nAlan Griffiths\n\nDon\u2019t Repeat Yourself . . . . . . . . . . . . . . . . . . . . . . . . 60\n\nSteve Smith\n\nDon\u2019t Touch That Code! . . . . . . . . . . . . . . . . . . . . . . . 62\n\nCal Evans\n\n\n\nviii Contents\n\nEncapsulate Behavior, Not Just State . . . . . . . . . . . . . . 64\n\nEinar Landre\n\nFloating-Point Numbers Aren\u2019t Real . . . . . . . . . . . . . . . 66\n\nChuck Allison\n\nFulfill Your Ambitions with Open Source . . . . . . . . . . . . 68\n\nRichard Monson-Haefel\n\nThe Golden Rule of API Design . . . . . . . . . . . . . . . . . . 70\n\nMichael Feathers\n\nThe Guru Myth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\n\nRyan Brush\n\nHard Work Does Not Pay Off . . . . . . . . . . . . . . . . . . . 74\n\nOlve Maudal\n\nHow to Use a Bug Tracker . . . . . . . . . . . . . . . . . . . . . 76\n\nMatt Doar\n\nImprove Code by Removing It . . . . . . . . . . . . . . . . . . . 78\n\nPete Goodliffe\n\nInstall Me . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80\n\nMarcus Baker\n\nInterprocess Communication Affects Application  \nResponse Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\n\nRandy Stafford\n\nKeep the Build Clean . . . . . . . . . . . . . . . . . . . . . . . . . 84\n\nJohannes Brodwall\n\nKnow How to Use Command-Line Tools . . . . . . . . . . . . 86\n\nCarroll Robinson\n\n\n\nixContents\n\nKnow Well More Than Two Programming Languages . . . . 88\n\nRussel Winder\n\nKnow Your IDE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\n\nHeinz Kabutz\n\nKnow Your Limits . . . . . . . . . . . . . . . . . . . . . . . . . . . 92\n\nGreg Colvin\n\nKnow Your Next Commit . . . . . . . . . . . . . . . . . . . . . . 94\n\nDan Bergh Johnsson\n\nLarge, Interconnected Data Belongs to a Database . . . . . 96\n\nDiomidis Spinellis\n\nLearn Foreign Languages . . . . . . . . . . . . . . . . . . . . . . 98\n\nKlaus Marquardt\n\nLearn to Estimate . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\n\nGiovanni Asproni\n\nLearn to Say, \u201cHello, World\u201d . . . . . . . . . . . . . . . . . . . . 102\n\nThomas Guest\n\nLet Your Project Speak for Itself . . . . . . . . . . . . . . . . . 104\n\nDaniel Lindner\n\nThe Linker Is Not a Magical Program . . . . . . . . . . . . . . 106\n\nWalter Bright\n\nThe Longevity of Interim Solutions . . . . . . . . . . . . . . . . 108\n\nKlaus Marquardt\n\nMake Interfaces Easy to Use Correctly  \nand Hard to Use Incorrectly . . . . . . . . . . . . . . . . . . . . 110\n\nScott Meyers\n\n\n\nx Contents\n\nMake the Invisible More Visible . . . . . . . . . . . . . . . . . . 112\n\nJon Jagger\n\nMessage Passing Leads to Better Scalability  \nin Parallel Systems . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n\nRussel Winder\n\nA Message to the Future . . . . . . . . . . . . . . . . . . . . . . 116\n\nLinda Rising\n\nMissing Opportunities for Polymorphism . . . . . . . . . . . . 118\n\nKirk Pepperdine\n\nNews of the Weird: Testers Are Your Friends . . . . . . . . . 120\n\nBurk Hufnagel\n\nOne Binary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\n\nSteve Freeman\n\nOnly the Code Tells the Truth . . . . . . . . . . . . . . . . . . . 124\n\nPeter Sommerlad\n\nOwn (and Refactor) the Build . . . . . . . . . . . . . . . . . . . 126\n\nSteve Berczuk\n\nPair Program and Feel the Flow . . . . . . . . . . . . . . . . . . 128\n\nGudny Hauknes, Kari R\u00f8ssland, and Ann Katrin Gagnat\n\nPrefer Domain-Specific Types to Primitive Types . . . . . . 130\n\nEinar Landre\n\nPrevent Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\nGiles Colborne\n\nThe Professional Programmer . . . . . . . . . . . . . . . . . . . 134\n\nRobert C. Martin (Uncle Bob)\n\n\n\nxiContents\n\nPut Everything Under Version Control . . . . . . . . . . . . . 136\n\nDiomidis Spinellis\n\nPut the Mouse Down and Step Away from the Keyboard . 138\n\nBurk Hufnagel\n\nRead Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\n\nKarianne Berg\n\nRead the Humanities . . . . . . . . . . . . . . . . . . . . . . . . . 142\n\nKeith Braithwaite\n\nReinvent the Wheel Often . . . . . . . . . . . . . . . . . . . . . 144\n\nJason P. Sage\n\nResist the Temptation of the Singleton Pattern . . . . . . . . 146\n\nSam Saariste\n\nThe Road to Performance Is Littered  \nwith Dirty Code Bombs . . . . . . . . . . . . . . . . . . . . . . . 148\n\nKirk Pepperdine\n\nSimplicity Comes from Reduction . . . . . . . . . . . . . . . . 150\n\nPaul W. Homer\n\nThe Single Responsibility Principle . . . . . . . . . . . . . . . . 152\n\nRobert C. Martin (Uncle Bob)\n\nStart from Yes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\n\nAlex Miller\n\nStep Back and Automate, Automate, Automate . . . . . . . 156\n\nCay Horstmann\n\nTake Advantage of Code Analysis Tools . . . . . . . . . . . . 158\n\nSarah Mount\n\n\n\nxii Contents\n\nTest for Required Behavior, Not Incidental Behavior. . . . . 160\n\nKevlin Henney\n\nTest Precisely and Concretely . . . . . . . . . . . . . . . . . . . 162\n\nKevlin Henney\n\nTest While You Sleep (and over Weekends) . . . . . . . . . . 164\n\nRajith Attapattu\n\nTesting Is the Engineering Rigor  \nof Software Development . . . . . . . . . . . . . . . . . . . . . 166\n\nNeal Ford\n\nThinking in States . . . . . . . . . . . . . . . . . . . . . . . . . . . 168\n\nNiclas Nilsson\n\nTwo Heads Are Often Better Than One . . . . . . . . . . . . . 170\n\nAdrian Wible\n\nTwo Wrongs Can Make a Right (and Are Difficult to Fix) . 172\n\nAllan Kelly\n\nUbuntu Coding for Your Friends . . . . . . . . . . . . . . . . . 174\n\nAslam Khan\n\nThe Unix Tools Are Your Friends . . . . . . . . . . . . . . . . . 176\n\nDiomidis Spinellis\n\nUse the Right Algorithm and Data Structure . . . . . . . . . 178\n\nJan Christiaan \u201cJC\u201d van Winkel\n\nVerbose Logging Will Disturb Your Sleep . . . . . . . . . . . 180\n\nJohannes Brodwall\n\n\n\nxiiiContents\n\nWET Dilutes Performance Bottlenecks . . . . . . . . . . . . . 182\n\nKirk Pepperdine\n\nWhen Programmers and Testers Collaborate . . . . . . . . . 184\n\nJanet Gregory\n\nWrite Code As If You Had to Support It  \nfor the Rest of Your Life . . . . . . . . . . . . . . . . . . . . . . . 186\n\nYuriy Zubarev\n\nWrite Small Functions Using Examples . . . . . . . . . . . . . 188\n\nKeith Braithwaite\n\nWrite Tests for People . . . . . . . . . . . . . . . . . . . . . . . . 190\n\nGerard Meszaros\n\nYou Gotta Care About the Code . . . . . . . . . . . . . . . . . 192\n\nPete Goodliffe\n\nYour Customers Do Not Mean What They Say . . . . . . . . 194\n\nNate Jackson\n\nContributors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196\n\nIndex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221\n\n\n\n\n\nxv\n\nContributions \nby Category\n\nBugs and Fixes\n\nCheck Your Code First Before Looking to Blame Others . . . . . . . 18\n\nDon\u2019t Touch That Code! . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n\nHow to Use a Bug Tracker . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n\nTwo Wrongs Can Make a Right (and Are Difficult to Fix) . . . . . 172\n\nBuild and Deployment\n\nDeploy Early and Often . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n\nDon\u2019t Touch That Code! . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n\nInstall Me . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80\n\nKeep the Build Clean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n\nLet Your Project Speak for Itself . . . . . . . . . . . . . . . . . . . . . 104\n\nOne Binary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\n\nOwn (and Refactor) the Build . . . . . . . . . . . . . . . . . . . . . . . 126\n\nCoding Guidelines and Code Layout\n\nAutomate Your Coding Standard . . . . . . . . . . . . . . . . . . . . . . 8\n\nCode Layout Matters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n\nCode Reviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\nA Comment on Comments . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\nComment Only What the Code Cannot Say . . . . . . . . . . . . . . . 34\n\nTake Advantage of Code Analysis Tools . . . . . . . . . . . . . . . . 158\n\n\n\nxvi Contents\n\nDesign Principles and Coding Techniques\n\nApply Functional Programming Principles . . . . . . . . . . . . . . . . 4\n\nAsk, \u201cWhat Would the User Do?\u201d (You Are Not the User) . . . . . . 6\n\nBeauty Is in Simplicity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n\nChoose Your Tools with Care . . . . . . . . . . . . . . . . . . . . . . . . 20\n\nCode in the Language of the Domain . . . . . . . . . . . . . . . . . . . 22\n\nCode Is Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\nCoding with Reason . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n\nConvenience Is Not an -ility . . . . . . . . . . . . . . . . . . . . . . . . . 38\n\nDistinguish Business Exceptions from Technical . . . . . . . . . . . . 42\n\nDon\u2019t Repeat Yourself . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\nEncapsulate Behavior, Not Just State . . . . . . . . . . . . . . . . . . . 64\n\nThe Golden Rule of API Design . . . . . . . . . . . . . . . . . . . . . . . 70\n\nInterprocess Communication Affects Application  \n\nResponse Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\n\nMake Interfaces Easy to Use Correctly  \n\nand Hard to Use Incorrectly . . . . . . . . . . . . . . . . . . . . . . . . 110\n\nMessage Passing Leads to Better Scalability  \n\nin Parallel Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n\nMissing Opportunities for Polymorphism . . . . . . . . . . . . . . . . 118\n\nOnly the Code Tells the Truth . . . . . . . . . . . . . . . . . . . . . . . 124\n\nPrefer Domain-Specific Types to Primitive Types . . . . . . . . . . 130\n\nPrevent Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\nResist the Temptation of the Singleton Pattern . . . . . . . . . . . . 146\n\nThe Single Responsibility Principle . . . . . . . . . . . . . . . . . . . . 152\n\nThinking in States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168\n\nWET Dilutes Performance Bottlenecks . . . . . . . . . . . . . . . . . 182\n\nDomain Thinking\n\nCode in the Language of the Domain . . . . . . . . . . . . . . . . . . . 22\n\nDomain-Specific Languages . . . . . . . . . . . . . . . . . . . . . . . . . 46\n\nLearn Foreign Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n\nPrefer Domain-Specific Types to Primitive Types . . . . . . . . . . 130\n\n\n\nxviiContents\n\nRead the Humanities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\n\nThinking in States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168\n\nWrite Small Functions Using Examples . . . . . . . . . . . . . . . . . 188\n\nErrors, Error Handling, and Exceptions\n\nDistinguish Business Exceptions from Technical . . . . . . . . . . . . 42\n\nDon\u2019t Ignore That Error! . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52\n\nDon\u2019t Nail Your Program into the Upright Position . . . . . . . . . . . 56\n\nPrevent Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\nVerbose Logging Will Disturb Your Sleep . . . . . . . . . . . . . . . 180\n\nLearning, Skills, and Expertise\n\nContinuous Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n\nDo Lots of Deliberate Practice. . . . . . . . . . . . . . . . . . . . . . . 44\n\nDon\u2019t Just Learn the Language, Understand Its Culture . . . . . . . 54\n\nFulfill Your Ambitions with Open Source . . . . . . . . . . . . . . . . . 68\n\nThe Guru Myth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\n\nHard Work Does Not Pay Off . . . . . . . . . . . . . . . . . . . . . . . . 74\n\nRead Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\n\nRead the Humanities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\n\nReinvent the Wheel Often . . . . . . . . . . . . . . . . . . . . . . . . . 144\n\nNocturnal or Magical\n\nDon\u2019t Rely on \u201cMagic Happens Here\u201d . . . . . . . . . . . . . . . . . . . 58\n\nDon\u2019t Touch That Code! . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n\nThe Guru Myth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\n\nKnow How to Use Command-Line Tools . . . . . . . . . . . . . . . . . 86\n\nThe Linker Is Not a Magical Program . . . . . . . . . . . . . . . . . . 106\n\nTest While You Sleep (and over Weekends) . . . . . . . . . . . . . . 164\n\nVerbose Logging Will Disturb Your Sleep . . . . . . . . . . . . . . . 180\n\nWrite Code As If You Had to Support It  \n\nfor the Rest of Your Life . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\n\n\n\nxviii Contents\n\nPerformance, Optimization, and \nRepresentation\n\nApply Functional Programming Principles . . . . . . . . . . . . . . . . 4\n\nFloating-Point Numbers Aren\u2019t Real . . . . . . . . . . . . . . . . . . . . 66\n\nImprove Code by Removing It . . . . . . . . . . . . . . . . . . . . . . . . 78\n\nInterprocess Communication Affects Application  \n\nResponse Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\n\nKnow Your Limits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92\n\nLarge, Interconnected Data Belongs to a Database . . . . . . . . . . 96\n\nMessage Passing Leads to Better Scalability  \n\nin Parallel Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n\nThe Road to Performance Is Littered with Dirty Code Bombs . . 148\n\nUse the Right Algorithm and Data Structure . . . . . . . . . . . . . 178\n\nWET Dilutes Performance Bottlenecks . . . . . . . . . . . . . . . . . 182\n\nProfessionalism, Mindset, and Attitude\n\nContinuous Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n\nDo Lots of Deliberate Practice. . . . . . . . . . . . . . . . . . . . . . . 44\n\nHard Work Does Not Pay Off . . . . . . . . . . . . . . . . . . . . . . . . 74\n\nThe Longevity of Interim Solutions . . . . . . . . . . . . . . . . . . . . 108\n\nThe Professional Programmer . . . . . . . . . . . . . . . . . . . . . . . 134\n\nPut the Mouse Down and Step Away from the Keyboard . . . . . 138\n\nTesting Is the Engineering Rigor of Software Development . . . . 166\n\nWrite Code As If You Had to Support It  \n\nfor the Rest of Your Life . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\n\nYou Gotta Care About the Code . . . . . . . . . . . . . . . . . . . . . 192\n\nProgramming Languages and Paradigms\n\nApply Functional Programming Principles . . . . . . . . . . . . . . . . 4\n\nDomain-Specific Languages . . . . . . . . . . . . . . . . . . . . . . . . . 46\n\nDon\u2019t Just Learn the Language, Understand Its Culture . . . . . . . 54\n\nKnow Well More Than Two Programming Languages . . . . . . . . . 88\n\nLearn Foreign Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n\n\n\nxixContents\n\nRefactoring and Code Care\n\nAct with Prudence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\nBefore You Refactor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n\nThe Boy Scout Rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n\nComment Only What the Code Cannot Say . . . . . . . . . . . . . . . 34\n\nDon\u2019t Be Afraid to Break Things . . . . . . . . . . . . . . . . . . . . . . 48\n\nImprove Code by Removing It . . . . . . . . . . . . . . . . . . . . . . . . 78\n\nKeep the Build Clean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n\nKnow Your Next Commit . . . . . . . . . . . . . . . . . . . . . . . . . . . 94\n\nThe Longevity of Interim Solutions . . . . . . . . . . . . . . . . . . . . 108\n\nA Message to the Future . . . . . . . . . . . . . . . . . . . . . . . . . . 116\n\nOnly the Code Tells the Truth . . . . . . . . . . . . . . . . . . . . . . . 124\n\nOwn (and Refactor) the Build . . . . . . . . . . . . . . . . . . . . . . . 126\n\nThe Professional Programmer . . . . . . . . . . . . . . . . . . . . . . . 134\n\nThe Road to Performance Is Littered with Dirty Code Bombs . . 148\n\nSimplicity Comes from Reduction . . . . . . . . . . . . . . . . . . . . 150\n\nUbuntu Coding for Your Friends . . . . . . . . . . . . . . . . . . . . . 174\n\nYou Gotta Care About the Code . . . . . . . . . . . . . . . . . . . . . 192\n\nReuse Versus Repetition\n\nBeware the Share . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n\nConvenience Is Not an -ility . . . . . . . . . . . . . . . . . . . . . . . . . 38\n\nDo Lots of Deliberate Practice. . . . . . . . . . . . . . . . . . . . . . . 44\n\nDon\u2019t Repeat Yourself . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\nReinvent the Wheel Often . . . . . . . . . . . . . . . . . . . . . . . . . 144\n\nUse the Right Algorithm and Data Structure . . . . . . . . . . . . . 178\n\nWET Dilutes Performance Bottlenecks . . . . . . . . . . . . . . . . . 182\n\nSchedules, Deadlines, and Estimates\n\nAct with Prudence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n\nCode Is Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\nKnow Your Next Commit . . . . . . . . . . . . . . . . . . . . . . . . . . . 94\n\nLearn to Estimate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\n\nMake the Invisible More Visible . . . . . . . . . . . . . . . . . . . . . . . 112\n\n\n\nxx Contents\n\nSimplicity\n\nBeauty Is in Simplicity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n\nLearn to Say, \u201cHello, World\u201d . . . . . . . . . . . . . . . . . . . . . . . . 102\n\nA Message to the Future . . . . . . . . . . . . . . . . . . . . . . . . . . 116\n\nSimplicity Comes from Reduction . . . . . . . . . . . . . . . . . . . . 150\n\nTeamwork and Collaboration\n\nCode Reviews . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n\nLearn Foreign Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n\nPair Program and Feel the Flow . . . . . . . . . . . . . . . . . . . . . . 128\n\nStart from Yes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\n\nTwo Heads Are Often Better Than One . . . . . . . . . . . . . . . . . 170\n\nUbuntu Coding for Your Friends . . . . . . . . . . . . . . . . . . . . . 174\n\nWhen Programmers and Testers Collaborate . . . . . . . . . . . . . 184\n\nTests, Testing, and Testers\n\nApply Functional Programming Principles . . . . . . . . . . . . . . . . 4\n\nCode Is Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n\nDon\u2019t Be Cute with Your Test Data . . . . . . . . . . . . . . . . . . . . . 50\n\nThe Golden Rule of API Design . . . . . . . . . . . . . . . . . . . . . . . 70\n\nMake Interfaces Easy to Use Correctly and Hard to Use  \n\nIncorrectly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\n\nMake the Invisible More Visible . . . . . . . . . . . . . . . . . . . . . . . 112\n\nNews of the Weird: Testers Are Your Friends . . . . . . . . . . . . . 120\n\nTest for Required Behavior, Not Incidental Behavior. . . . . . . . . 160\n\nTest Precisely and Concretely . . . . . . . . . . . . . . . . . . . . . . . 162\n\nTest While You Sleep (and over Weekends) . . . . . . . . . . . . . . 164\n\nTesting Is the Engineering Rigor of Software Development . . . . 166\n\nWhen Programmers and Testers Collaborate . . . . . . . . . . . . . 184\n\nWrite Small Functions Using Examples . . . . . . . . . . . . . . . . . 188\n\nWrite Tests for People . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190\n\n\n\nxxiContents\n\nTools, Automation, and Development \nEnvironments\n\nAutomate Your Coding Standard . . . . . . . . . . . . . . . . . . . . . . 8\n\nCheck Your Code First Before Looking to Blame Others . . . . . . . 18\n\nChoose Your Tools with Care . . . . . . . . . . . . . . . . . . . . . . . . 20\n\nDon\u2019t Repeat Yourself . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n\nHow to Use a Bug Tracker . . . . . . . . . . . . . . . . . . . . . . . . . . 76\n\nKnow How to Use Command-Line Tools . . . . . . . . . . . . . . . . . 86\n\nKnow Your IDE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\n\nLarge, Interconnected Data Belongs to a Database . . . . . . . . . . 96\n\nLearn to Say, \u201cHello, World\u201d . . . . . . . . . . . . . . . . . . . . . . . . 102\n\nLet Your Project Speak for Itself . . . . . . . . . . . . . . . . . . . . . 104\n\nThe Linker Is Not a Magical Program . . . . . . . . . . . . . . . . . . 106\n\nPut Everything Under Version Control . . . . . . . . . . . . . . . . . 136\n\nStep Back and Automate, Automate, Automate . . . . . . . . . . . 156\n\nTake Advantage of Code Analysis Tools . . . . . . . . . . . . . . . . 158\n\nTest While You Sleep (and over Weekends) . . . . . . . . . . . . . . 164\n\nThe Unix Tools Are Your Friends . . . . . . . . . . . . . . . . . . . . . 176\n\nUsers and Customers\n\nAsk, \u201cWhat Would the User Do?\u201d (You Are Not the User) . . . . . . 6\n\nDomain-Specific Languages . . . . . . . . . . . . . . . . . . . . . . . . . 46\n\nMake Interfaces Easy to Use Correctly and Hard to Use  \n\nIncorrectly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\n\nNews of the Weird: Testers Are Your Friends . . . . . . . . . . . . . 120\n\nPrevent Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\n\nRead the Humanities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\n\nYour Customers Do Not Mean What They Say . . . . . . . . . . . . 194\n\n\n\n\n\nxxiii\n\nThe newest computer can merely compound, at speed, the oldest problem in the \nrelations between human beings, and in the end the communicator will be confronted \n\nwith the old problem, of what to say and how to say it.\n\u2014Edward R. Murrow\n\nPROGRAMMERS HAVE A LOT ON THEiR MiNDS. Programming languages, \nprogramming techniques, development environments, coding style, tools, \ndevelopment process, deadlines, meetings, software architecture, design pat-\nterns, team dynamics, code, requirements, bugs, code quality. And more. A lot. \n\nThere is an art, craft, and science to programming that extends far beyond \nthe program. The act of programming marries the discrete world of comput-\ners with the fluid world of human affairs. Programmers mediate between the \nnegotiated and uncertain truths of business and the crisp, uncompromising \ndomain of bits and bytes and higher constructed types.\n\nWith so much to know, so much to do, and so many ways of doing so, no \nsingle person or single source can lay claim to \u201cthe one true way.\u201d Instead, 97 \nThings Every Programmer Should Know draws on the wisdom of crowds and \nthe voices of experience to offer not so much a coordinated big picture as a \ncrowdsourced mosaic of what every programmer should know. This ranges \nfrom code-focused advice to culture, from algorithm usage to agile thinking, \nfrom implementation know-how to professionalism, from style to substance.\n\nThe contributions do not dovetail like modular parts, and there is no intent \nthat they should\u2014if anything, the opposite is true. The value of each contribu-\ntion comes from its distinctiveness. The value of the collection lies in how the \ncontributions complement, confirm, and even contradict one another. There \nis no overarching narrative: it is for you to respond to, reflect on, and connect \ntogether what you read, weighing it against your own context, knowledge, and \nexperience.\n\nPreface\n\n\n\nxxiv Preface\n\nPermissions\nThe licensing of each contribution follows a nonrestrictive, open source \nmodel. Every contribution is freely available online and licensed under a Cre-\native Commons Attribution 3.0 License, which means that you can use the \nindividual contributions in your own work, as long as you give credit to the \noriginal author:\n\nhttp://creativecommons.org/licenses/by/3.0/us/\n\nHow to Contact Us\nPlease address comments and questions concerning this book to the publisher:\n\nO\u2019Reilly Media, Inc.\n1005 Gravenstein Highway North\nSebastopol, CA 95472\n800-998-9938 (in the United States or Canada)\n707-829-0515 (international or local)\n707-829-0104 (fax)\n\nOn the web page for this book, we list errata and any additional information. \nYou can access this page at:\n\nhttp://www.oreilly.com/catalog/9780596809485/\nThe companion website for this book, where you can find all the contributions, \ncontributor biographies, and more, is at: \n\nhttp://programmer.97things.oreilly.com \nYou can also follow news and updates about this book and the website on Twitter: \n\nhttp://twitter.com/97TEPSK\nTo comment or ask technical questions about this book, send email to:\n\nbookquestions@oreilly.com\nFor more information about our books, conferences, Resource Centers, and \nthe O\u2019Reilly Network, see our website at:\n\nhttp://www.oreilly.com/\n\nSafari\u00ae Books Online\nSafari Books Online is an on-demand digital library that lets \nyou easily search over 7,500 technology and creative refer-\nence books and videos to find the answers you need quickly.\n\nWith a subscription, you can read any page and watch any video from our \nlibrary online. Read books on your cell phone and mobile devices. Access new \n\nhttp://www.oreilly.com/catalog/9780596522698/\nhttp://programmer.97things.oreilly.com\nhttp://twitter.com/97TEPSK\nmailto:bookquestions@oreilly.com\nhttp://www.oreilly.com/\n\n\n1Preface\n\ntitles before they are available for print, and get exclusive access to manuscripts \nin development and post feedback for the authors. Copy and paste code sam-\nples, organize your favorites, download chapters, bookmark key sections, cre-\nate notes, print out pages, and benefit from tons of other time-saving features.\n\nO\u2019Reilly Media has uploaded this book to the Safari Books Online service. To \nhave full digital access to this book and others on similar topics from O\u2019Reilly \nand other publishers, sign up for free at http://my.safaribooksonline.com.\n\nAcknowledgments\nMany people have contributed their time and their insight, both directly and \nindirectly, to the 97 Things Every Programmer Should Know project. They all \ndeserve credit.\n\nRichard Monson-Haefel is the 97 Things series editor and also the editor of \nthe first book in the series, 97 Things Every Software Architect Should Know, to \nwhich I contributed. I would like to thank Richard for trailblazing the series \nconcept and its open contribution approach, and for enthusiastically supporting \nmy proposal for this book.\n\nI would like to thank all those who devoted the time and effort to contribute \nitems to this project: both the contributors whose items are published in this \nbook and the others whose items were not selected, but whose items are also \npublished on the website. The high quantity and quality of contributions made \nthe final selection process very difficult\u2014the hardcoded number in the book\u2019s \ntitle unfortunately meant there was no slack to accommodate just a few more. \nI am also grateful for the additional feedback, comments, and suggestions \nprovided by Giovanni Asproni, Paul Colin Gloster, and Michael Hunger.\n\nThanks to O\u2019Reilly for the support they have provided this project, from hosting \nthe wiki that made it possible to seeing it all the way through to publication in \nbook form. People at O\u2019Reilly I would like to thank specifically are Mike Loukides, \nLaurel Ackerman, Edie Freedman, Ed Stephenson, and Rachel Monaghan.\n\nIt is not simply the case that the book\u2019s content was developed on the Web: the \nproject was also publicized and popularized on the Web. I would like to thank \nall those who have tweeted, retweeted, blogged, and otherwise spread the word.\n\nI would also like to thank my wife, Carolyn, for bringing order to my chaos, and \nto my two sons, Stefan and Yannick, for reclaiming some of the chaos.\n\nI hope this book will provide you with information, insight, and inspiration.\n\nEnjoy!\n\u2014Kevlin Henney\n\nhttp://my.safaribooksonline.com\n\n\n2 97 Things Every Programmer Should Know\n\nAct with \nPrudence\nSeb Rose\n \n\nWhatever you undertake, act with prudence and \nconsider the consequences.\n\n\u2014Anon\n\nNO MATTER HOW COMFORTABLE A SCHEDULE LOOKS at the beginning of \nan iteration, you can\u2019t avoid being under pressure some of the time. If you find \nyourself having to choose between \u201cdoing it right\u201d and \u201cdoing it quick,\u201d it is \noften appealing to \u201cdo it quick\u201d with the understanding that you\u2019ll come back \nand fix it later. When you make this promise to yourself, your team, and your \ncustomer, you mean it. But all too often, the next iteration brings new prob-\nlems and you become focused on them. This sort of deferred work is known \nas technical debt, and it is not your friend. Specifically, Martin Fowler calls this \ndeliberate technical debt in his taxonomy of technical debt,* and it should not \nbe confused with inadvertent technical debt.\n\nTechnical debt is like a loan: you benefit from it in the short term, but you \nhave to pay interest on it until it is fully paid off. Shortcuts in the code make \nit harder to add features or refactor your code. They are breeding grounds \nfor defects and brittle test cases. The longer you leave it, the worse it gets. By \nthe time you get around to undertaking the original fix, there may be a whole \nstack of not-quite-right design choices layered on top of the original problem, \nmaking the code much harder to refactor and correct. In fact, it is often only \nwhen things have got so bad that you must fix the original problem, that you \nactually do go back to fix it. And by then, it is often so hard to fix that you really \ncan\u2019t afford the time or the risk.\n\n* http://martinfowler.com/bliki/TechnicalDebtQuadrant.html\n\n[image: image3.jpg]  \n\nhttp://martinfowler.com/bliki/TechnicalDebtQuadrant.html\n\n\n3Collective Wisdom from the Experts\n\nThere are times when you must incur technical debt to meet a deadline or \nimplement a thin slice of a feature. Try not to be in this position, but if the situ-\nation absolutely demands it, then go ahead. But (and this is a big but) you must \ntrack technical debt and pay it back quickly, or things go rapidly downhill. \nAs soon as you make the decision to compromise, write a task card or log it in \nyour issue-tracking system to ensure that it does not get forgotten.\n\nIf you schedule repayment of the debt in the next iteration, the cost will be \nminimal. Leaving the debt unpaid will accrue interest, and that interest should \nbe tracked to make the cost visible. This will emphasize the effect on busi-\nness value of the project\u2019s technical debt and enables appropriate prioritization \nof the repayment. The choice of how to calculate and track the interest will \ndepend on the particular project, but track it you must.\n\nPay off technical debt as soon as possible. It would be imprudent to do otherwise.\n\n\n\n4 97 Things Every Programmer Should Know\n\nApply Functional \nProgramming \nPrinciples\nEdward Garson\n\nFUNCTiONAL PROGRAMMiNG has recently enjoyed renewed interest from the \nmainstream programming community. Part of the reason is because emergent \nproperties of the functional paradigm are well positioned to address the chal-\nlenges posed by our industry\u2019s shift toward multicore. However, while that is \ncertainly an important application, it is not the reason this piece admonishes \nyou to know thy functional programming.\n\nMastery of the functional programming paradigm can greatly improve the \nquality of the code you write in other contexts. If you deeply understand and \napply the functional paradigm, your designs will exhibit a much higher degree \nof referential transparency.\n\nReferential transparency is a very desirable property: it implies that functions \nconsistently yield the same results given the same input, irrespective of where \nand when they are invoked. That is, function evaluation depends less\u2014ideally, \nnot at all\u2014on the side effects of mutable state.\n\nA leading cause of defects in imperative code is attributable to mutable vari-\nables. Everyone reading this will have investigated why some value is not as \nexpected in a particular situation. Visibility semantics can help to mitigate \nthese insidious defects, or at least to drastically narrow down their location, \nbut their true culprit may in fact be the providence of designs that employ \ninordinate mutability.\n\nAnd we certainly don\u2019t get much help from the industry in this regard. Intro-\nductions to object orientation tacitly promote such design, because they \noften show examples composed of graphs of relatively long-lived objects \nthat happily call mutator methods on one another, which can be  dangerous. \n\n[image: image4.jpg]  \n\n\n\n5Collective Wisdom from the Experts\n\nHowever, with astute test-driven design, particularly when being sure to \n\u201cMock Roles, not Objects,\u201d* unnecessary mutability can be designed away.\n\nThe net result is a design that typically has better responsibility allocation with \nmore numerous, smaller functions that act on arguments passed into them, \nrather than referencing mutable member variables. There will be fewer defects, \nand furthermore they will often be simpler to debug, because it is easier to \nlocate where a rogue value is introduced in these designs than to otherwise \ndeduce the particular context that results in an erroneous assignment. This \nadds up to a much higher degree of referential transparency, and positively \nnothing will get these ideas as deeply into your bones as learning a functional \nprogramming language, where this model of computation is the norm.\n\nOf course, this approach is not optimal in all situations. For example, in object-\noriented systems, this style often yields better results with domain model \ndevelopment (i.e., where collaborations serve to break down the complexity of \nbusiness rules) than with user-interface development.\n\nMaster the functional programming paradigm so you are able to judiciously \napply the lessons learned to other domains. Your object systems (for one) will \nresonate with referential transparency goodness and be much closer to their \nfunctional counterparts than many would have you believe. In fact, some would \neven assert that, at their apex, functional programming and object orientation \nare merely a reflection of each other, a form of computational yin and yang.\n\n* http://www.jmock.org/oopsla2004.pdf\n\nhttp://www.jmock.org/oopsla2004.pdf\n\n\n6 97 Things Every Programmer Should Know\n\nAsk, \u201cWhat Would \nthe User Do?\u201d (You \nAre Not the User)\nGiles Colborne\n\nWE ALL TEND TO ASSUME THAT OTHER PEOPLE THiNK LiKE US. But they \ndon\u2019t. Psychologists call this the false consensus bias. When people think or act \ndifferently from us, we\u2019re quite likely to label them (subconsciously) as defec-\ntive in some way.\n\nThis bias explains why programmers have such a hard time putting themselves \nin the users\u2019 position. Users don\u2019t think like programmers. For a start, they spend \nmuch less time using computers. They neither know nor care how a computer \nworks. This means they can\u2019t draw on any of the battery of problem-solving \ntechniques so familiar to programmers. They don\u2019t recognize the patterns and \ncues programmers use to work with, through, and around an interface.\n\nThe best way to find out how a user thinks is to watch one. Ask a user to \ncomplete a task using a similar piece of software to what you\u2019re developing. \nMake sure the task is a real one: \u201cAdd up a column of numbers\u201d is OK; \u201cCal-\nculate your expenses for the last month\u201d is better. Avoid tasks that are too spe-\ncific, such as \u201cCan you select these spreadsheet cells and enter a SUM formula \nbelow?\u201d\u2014there\u2019s a big clue in that question. Get the user to talk through his or \nher progress. Don\u2019t interrupt. Don\u2019t try to help. Keep asking yourself, \u201cWhy is \nhe doing that?\u201d and \u201cWhy is she not doing that?\u201d\n\nThe first thing you\u2019ll notice is that users do a core of things similarly. They try \nto complete tasks in the same order\u2014and they make the same mistakes in the \nsame places. You should design around that core behavior. This is different \nfrom design meetings, where people tend to listen when someone says, \u201cWhat \nif the user wants to\u2026?\u201d This leads to elaborate features and confusion over \nwhat users want. Watching users eliminates this confusion.\n\n[image: image5.jpg]  \n\n\n\n7Collective Wisdom from the Experts\n\nYou\u2019ll see users getting stuck. When you get stuck, you look around. When \nusers get stuck, they narrow their focus. It becomes harder for them to see \nsolutions elsewhere on the screen. It\u2019s one reason why help text is a poor solu-\ntion to poor user interface design. If you must have instructions or help text, \nmake sure to locate it right next to your problem areas. A user\u2019s narrow focus \nof attention is why tool tips are more useful than help menus.\n\nUsers tend to muddle through. They\u2019ll find a way that works and stick with \nit, no matter how convoluted. It\u2019s better to provide one really obvious way of \ndoing things than two or three shortcuts.\n\nYou\u2019ll also find that there\u2019s a gap between what users say they want and what \nthey actually do. That\u2019s worrying, as the normal way of gathering user require-\nments is to ask them. It\u2019s why the best way to capture requirements is to watch \nusers. Spending an hour watching users is more informative than spending a \nday guessing what they want.\n\n\n\n8 97 Things Every Programmer Should Know\n\nAutomate Your \nCoding Standard\nFilip van Laenen\n\nYOU\u2019VE PROBABLY BEEN THERE, TOO. At the beginning of a project, every-\nbody has lots of good intentions\u2014call them \u201cnew project\u2019s resolutions.\u201d Quite \noften, many of these resolutions are written down in documents. The ones about \ncode end up in the project\u2019s coding standard. During the kick-off meeting, the \nlead developer goes through the document and, in the best case, everybody \nagrees that they will try to follow them. Once the project gets underway, \nthough, these good intentions are abandoned, one at a time. When the project \nis finally delivered, the code looks like a mess, and nobody seems to know how \nit came to be that way.\n\nWhen did things go wrong? Probably already at the kick-off meeting. Some of \nthe project members didn\u2019t pay attention. Others didn\u2019t understand the point. \nWorse, some disagreed and were already planning their coding standard \nrebellion. Finally, some got the point and agreed, but when the pressure in the \nproject got too high, they had to let something go. Well-formatted code doesn\u2019t \nearn you points with a customer that wants more functionality. Furthermore, \nfollowing a coding standard can be quite a boring task if it isn\u2019t automated. Just \ntry to indent a messy class by hand to find out for yourself.\n\nBut if it\u2019s such a problem, why is it that we want a coding standard in the first \nplace? One reason to format the code in a uniform way is so that nobody can \n\u201cown\u201d a piece of code just by formatting it in his or her private way. We may \nwant to prevent developers from using certain antipatterns in order to avoid \nsome common bugs. In all, a coding standard should make it easier to work in \nthe project, and maintain development speed from the beginning to the end. \nIt follows, then, that everybody should agree on the coding standard, too\u2014it \ndoes not help if one developer uses three spaces to indent code, and another \nuses four.\n\n[image: image6.jpg]  \n\n\n\n9Collective Wisdom from the Experts\n\nThere exists a wealth of tools that can be used to produce code quality reports \nand to document and maintain the coding standard, but that isn\u2019t the whole \nsolution. It should be automated and enforced where possible. Here are a few \nexamples:\n\n\u2022 Make sure code formatting is part of the build process, so that everybody \nruns it automatically every time they compile the code.\n\n\u2022 Use static code analysis tools to scan the code for unwanted antipatterns. \nIf any are found, break the build.\n\n\u2022 Learn to configure those tools so that you can scan for your own, project-\nspecific antipatterns.\n\n\u2022 Do not only measure test coverage, but automatically check the results, \ntoo. Again, break the build if test coverage is too low. \n\nTry to do this for everything that you consider important. You won\u2019t be able \nto automate everything you really care about. As for the things that you can\u2019t \nautomatically flag or fix, consider them a set of guidelines supplementary to \nthe coding standard that is automated, but accept that you and your colleagues \nmay not follow them as diligently.\n\nFinally, the coding standard should be dynamic rather than static. As the proj-\nect evolves, the needs of the project change, and what may have seemed smart \nin the beginning isn\u2019t necessarily smart a few months later.\n\n\n\n10 97 Things Every Programmer Should Know\n\nBeauty Is in \nSimplicity\nJ\u00f8rn \u00d8lmheim\n\nTHERE iS ONE qUOTE, from Plato, that I think is particularly good for all \nsoftware developers to know and keep close to their hearts: \n\nBeauty of style and harmony and grace and good rhythm depends on simplicity.\n\nIn one sentence, this sums up the values that we as software developers should \naspire to.\n\nThere are a number of things we strive for in our code:\n\n\u2022 Readability\n\n\u2022 Maintainability\n\n\u2022 Speed of development\n\n\u2022 The elusive quality of beauty \n\nPlato is telling us that the enabling factor for all of these qualities is simplicity.\n\nWhat is beautiful code? This is potentially a very subjective question. Per-\nception of beauty depends heavily on individual background, just as much \nof our perception of anything depends on our background. People educated \nin the arts have a different perception of (or at least approach to) beauty \nthan people educated in the sciences. Arts majors tend to approach beauty in \nsoftware by comparing software to works of art, while science majors tend to \ntalk about symmetry and the golden ratio, trying to reduce things to formulae. \nIn my experience, simplicity is the foundation of most of the arguments from \nboth sides.\n\n[image: image7.jpg]  \n\n\n\n11Collective Wisdom from the Experts\n\nThink about source code that you have studied. If you haven\u2019t spent time \nstudying other people\u2019s code, stop reading this right now and find some open \nsource code to study. Seriously! I mean it! Go search the Web for some code in \nyour language of choice, written by some well-known, acknowledged expert.\n\nYou\u2019re back? Good. Where were we? Ah, yes\u2026I have found that code that \nresonates with me, and that I consider beautiful, has a number of properties in \ncommon. Chief among these is simplicity. I find that no matter how complex \nthe total application or system is, the individual parts have to be kept simple: \nsimple objects with a single responsibility containing similarly simple, focused \nmethods with descriptive names. Some people think the idea of having short \nmethods of 5\u201310 lines of code is extreme, and some languages make it very \nhard to do, but I think that such brevity is a desirable goal nonetheless.\n\nThe bottom line is that beautiful code is simple code. Each individual part \nis kept simple with simple responsibilities and simple relationships with the \nother parts of the system. This is the way we can keep our systems maintain-\nable over time, with clean, simple, testable code, ensuring a high speed of \ndevelopment throughout the lifetime of the system.\n\nBeauty is born of and found in simplicity.\n\n\n\n12 97 Things Every Programmer Should Know\n\nBefore You \nRefactor\nRajith Attapattu\n\nAT SOME POiNT, every programmer will need to refactor existing code. But \nbefore you do so, please think about the following, as this could save you and \nothers a great deal of time (and pain):\n\n\u2022 The best approach for restructuring starts by taking stock of the existing \ncodebase and the tests written against that code. This will help you under-\nstand the strengths and weaknesses of the code as it currently stands, \nso you can ensure that you retain the strong points while avoiding the \nmistakes. We all think we can do better than the existing system\u2026until \nwe end up with something no better\u2014or even worse\u2014than the previous \nincarnation because we failed to learn from the existing system\u2019s mistakes. \n\n\u2022 Avoid the temptation to rewrite everything. It is best to reuse as much \ncode as possible. No matter how ugly the code is, it has already been \ntested, reviewed, etc. Throwing away the old code\u2014especially if it was \nin production\u2014means that you are throwing away months (or years) of \ntested, battle-hardened code that may have had certain workarounds and \nbug fixes you aren\u2019t aware of. If you don\u2019t take this into account, the new \ncode you write may end up showing the same mysterious bugs that were \nfixed in the old code. This will waste a lot of time, effort, and knowledge \ngained over the years. \n\n\u2022 Many incremental changes are better than one massive change. Incremen-\ntal changes allows you to gauge the impact on the system more easily \nthrough feedback, such as from tests. It is no fun to see a hundred test \nfailures after you make a change. This can lead to frustration and pressure \nthat can in turn result in bad decisions. A couple of test failures at a time \nis easier to deal with, leading to a more manageable approach. \n\n[image: image8.jpg]  \n\n\n\n13Collective Wisdom from the Experts\n\n\u2022 After each development iteration, it is important to ensure that the existing \ntests pass. Add new tests if the existing tests are not sufficient to cover the \nchanges you made. Do not throw away the tests from the old code with-\nout due consideration. On the surface, some of these tests may not appear \nto be applicable to your new design, but it would be well worth the effort \nto dig deep down into the reasons why this particular test was added. \n\n\u2022 Personal preferences and ego shouldn\u2019t get in the way. If something isn\u2019t \nbroken, why fix it? That the style or the structure of the code does not \nmeet your personal preference is not a valid reason for restructuring. \nThinking you could do a better job than the previous programmer is not \na valid reason, either. \n\n\u2022 New technology is an insufficient reason to refactor. One of the worst reasons \nto refactor is because the current code is way behind all the cool technol-\nogy we have today, and we believe that a new language or framework can \ndo things a lot more elegantly. Unless a cost-benefit analysis shows that \na new language or framework will result in significant improvements in \nfunctionality, maintainability, or productivity, it is best to leave it as it is. \n\n\u2022 Remember that humans make mistakes. Restructuring will not always \nguarantee that the new code will be better\u2014or even as good as\u2014the pre-\nvious attempt. I have seen and been a part of several failed restructuring \nattempts. It wasn\u2019t pretty, but it was human. \n\n\n\n14 97 Things Every Programmer Should Know\n\nBeware the Share\nUdi Dahan\n\niT WAS MY FiRST PROjECT AT THE COMPANY. I\u2019d just finished my degree \nand was anxious to prove myself, staying late every day going through the \nexisting code. As I worked through my first feature, I took extra care to put \nin place everything I had learned\u2014commenting, logging, pulling out shared \ncode into libraries where possible, the works. The code review that I had felt so \nready for came as a rude awakening\u2014reuse was frowned upon!\n\nHow could this be? Throughout college, reuse was held up as the epitome of \nquality software engineering. All the articles I had read, the textbooks, the \nseasoned software professionals who taught me\u2014was it all wrong?\n\nIt turns out that I was missing something critical.\n\nContext.\n\nThe fact that two wildly different parts of the system performed some logic \nin the same way meant less than I thought. Up until I had pulled out those \nlibraries of shared code, these parts were not dependent on each other. Each \ncould evolve independently. Each could change its logic to suit the needs of the \nsystem\u2019s changing business environment. Those four lines of similar code were \naccidental\u2014a temporal anomaly, a coincidence. That is, until I came along.\n\n[image: image9.jpg]  \n\n\n\n15Collective Wisdom from the Experts\n\nThe libraries of shared code I created tied the shoelaces of each foot to the \nother. Steps by one business domain could not be made without first synchro-\nnizing with the other. Maintenance costs in those independent functions used \nto be negligible, but the common library required an order of magnitude more \ntesting.\n\nWhile I\u2019d decreased the absolute number of lines of code in the system, I had \nincreased the number of dependencies. The context of these dependencies is \ncritical\u2014had they been localized, the sharing may have been justified and had \nsome positive value. When these dependencies aren\u2019t held in check, their ten-\ndrils entangle the larger concerns of the system, even though the code itself \nlooks just fine.\n\nThese mistakes are insidious in that, at their core, they sound like a good idea. \nWhen applied in the right context, these techniques are valuable. In the wrong \ncontext, they increase cost rather than value. When coming into an existing \ncodebase with no knowledge of where the various parts will be used, I\u2019m much \nmore careful these days about what is shared.\n\nBeware the share. Check your context. Only then, proceed.\n\n\n\n16 97 Things Every Programmer Should Know\n\nThe Boy Scout Rule\nRobert C. Martin (Uncle Bob)\n\nTHE BOY SCOUTS HAVE A RULE: \u201cAlways leave the campground cleaner than \nyou found it.\u201d If you find a mess on the ground, you clean it up regardless of \nwho might have made it. You intentionally improve the environment for the \nnext group of campers. (Actually, the original form of that rule, written by \nRobert Stephenson Smyth Baden-Powell, the father of scouting, was \u201cTry and \nleave this world a little better than you found it.\u201d)\n\nWhat if we followed a similar rule in our code: \u201cAlways check a module in \ncleaner than when you checked it out\u201d? Regardless of who the original author \nwas, what if we always made some effort, no matter how small, to improve the \nmodule? What would be the result?\n\nI think if we all followed that simple rule, we would see the end of the relentless \ndeterioration of our software systems. Instead, our systems would gradually \nget better and better as they evolved. We would also see teams caring for the \nsystem as a whole, rather than just individuals caring for their own small part.\n\nI don\u2019t think this rule is too much to ask. You don\u2019t have to make every mod-\nule perfect before you check it in. You simply have to make it a little bit better \nthan when you checked it out. Of course, this means that any code you add \nto a module must be clean. It also means that you clean up at least one other \nthing before you check the module back in. You might simply improve the \nname of one variable, or split one long function into two smaller functions. \nYou might break a circular dependency, or add an interface to decouple policy \nfrom detail.\n\n[image: image10.jpg]  \n\n\n\n17Collective Wisdom from the Experts\n\nFrankly, this just sounds like common decency to me\u2014like washing your \nhands after you use the restroom, or putting your trash in the bin instead of \ndropping it on the floor. Indeed, the act of leaving a mess in the code should be \nas socially unacceptable as littering. It should be something that just isn\u2019t done.\n\nBut it\u2019s more than that. Caring for our own code is one thing. Caring for the \nteam\u2019s code is quite another. Teams help one another and clean up after one \nanother. They follow the Boy Scout rule because it\u2019s good for everyone, not just \ngood for themselves.\n\n\n\n18 97 Things Every Programmer Should Know\n\nCheck Your Code \nFirst Before Looking \nto Blame Others\nAllan Kelly\n\nDEVELOPERS\u2014ALL OF US!\u2014often have trouble believing our own code is bro-\nken. It is just so improbable that, for once, it must be the compiler that\u2019s broken.\n\nYet, in truth, it is very (very) unusual that code is broken by a bug in the com-\npiler, interpreter, OS, app server, database, memory manager, or any other \npiece of system software. Yes, these bugs exist, but they are far less common \nthan we might like to believe.\n\nI once had a genuine problem with a compiler bug optimizing away a loop vari-\nable, but I have imagined my compiler or OS had a bug many more times. I have \nwasted a lot of my time, support time, and management time in the process, only \nto feel a little foolish each time it turned out to be my mistake after all.\n\nAssuming that the tools are widely used, mature, and employed in various tech-\nnology stacks, there is little reason to doubt the quality. Of course, if the tool is \nan early release, or used by only a few people worldwide, or a piece of seldom \ndownloaded, version 0.1, open source software, there may be good reason to \nsuspect the software. (Equally, an alpha version of commercial software might \nbe suspect.)\n\nGiven how rare compiler bugs are, you are far better putting your time and \nenergy into finding the error in your code than into proving that the compiler \nis wrong. All the usual debugging advice applies, so isolate the problem, stub \nout calls, and surround it with tests; check calling conventions, shared libraries, \nand version numbers; explain it to someone else; look out for stack corrup-\ntion and variable type mismatches; and try the code on different machines \nand different build configurations, such as debug and release.\n\n[image: image11.jpg]  \n\n\n\n19Collective Wisdom from the Experts\n\nQuestion your own assumptions and the assumptions of others. Tools from \ndifferent vendors might have different assumptions built into them\u2014so too \nmight different tools from the same vendor.\n\nWhen someone else is reporting a problem you cannot duplicate, go and see \nwhat they are doing. They may be doing something you never thought of or \nare doing something in a different order.\n\nMy personal rule is that if I have a bug I can\u2019t pin down, and I\u2019m starting \nto think it\u2019s the compiler, then it\u2019s time to look for stack corruption. This is \nespecially true if adding trace code makes the problem move around.\n\nMultithreaded problems are another source of bugs that turn hair gray and \ninduce screaming at the machine. All the recommendations to favor simple \ncode are multiplied when a system is multithreaded. Debugging and unit tests \ncannot be relied on to find such bugs with any consistency, so simplicity of \ndesign is paramount.\n\nSo, before you rush to blame the compiler, remember Sherlock Holmes\u2019s \nadvice, \u201cOnce you eliminate the impossible, whatever remains, no matter how \nimprobable, must be the truth,\u201d and opt for it over Dirk Gently\u2019s, \u201cOnce you \neliminate the improbable, whatever remains, no matter how impossible, must \nbe the truth.\u201d\n\n\n\n20 97 Things Every Programmer Should Know\n\nChoose Your \nTools with Care\nGiovanni Asproni\n\nMODERN APPLiCATiONS ARE VERY RARELY BUiLT FROM SCRATCH. They \nare assembled using existing tools\u2014components, libraries, and frameworks\u2014\nfor a number of good reasons:\n\n\u2022 Applications grow in size, complexity, and sophistication, while the time \navailable to develop them grows shorter. It makes better use of devel-\nopers\u2019 time and intelligence if they can concentrate on writing more \n business-domain code and less infrastructure code.\n\n\u2022 Widely used components and frameworks are likely to have fewer bugs \nthan the ones developed in-house.\n\n\u2022 There is a lot of high-quality software available on the Web for free, \nwhich means lower development costs and greater likelihood of finding \ndevelopers with the necessary interest and expertise.\n\n\u2022 Software production and maintenance is human-intensive work, so buying \nmay be cheaper than building. \n\nHowever, choosing the right mix of tools for your application can be a tricky \nbusiness requiring some thought. In fact, when making a choice, you should \nkeep in mind a few things:\n\n\u2022 Different tools may rely on different assumptions about their context\u2014e.g., \nsurrounding infrastructure, control model, data model, communication \nprotocols, etc.\u2014which can lead to an architectural mismatch between the \napplication and the tools. Such a mismatch leads to hacks and workarounds \nthat will make the code more complex than necessary.\n\n\u2022 Different tools have different lifecycles, and upgrading one of them may \nbecome an extremely difficult and time-consuming task since the new func-\ntionality, design changes, or even bug fixes may cause incompatibilities with \n\n[image: image12.jpg]  \n\n\n\n21Collective Wisdom from the Experts\n\nthe other tools. The greater the number of tools, the worse the problem \ncan become.\n\n\u2022 Some tools require quite a bit of configuration, often by means of one or \nmore XML files, which can grow out of control very quickly. The applica-\ntion may end up looking as if it was all written in XML plus a few odd lines \nof code in some programming language. The configurational complexity \nwill make the application difficult to maintain and to extend.\n\n\u2022 Vendor lock-in occurs when code that depends heavily on specific ven-\ndor products ends up being constrained by them on several counts: \nmaintainability, performances, ability to evolve, price, etc.\n\n\u2022 If you plan to use free software, you may discover that it\u2019s not so free after \nall. You may need to buy commercial support, which is not necessarily \ngoing to be cheap.\n\n\u2022 Licensing terms matter, even for free software. For example, in some \ncompanies, it is not acceptable to use software licensed under the GNU \nlicense terms because of its viral nature\u2014i.e., software developed with it \nmust be distributed along with its source code. \n\nMy personal strategy to mitigate these problems is to start small by using only \nthe tools that are absolutely necessary. Usually the initial focus is on removing \nthe need to engage in low-level infrastructure programming (and problems), \ne.g., by using some middleware instead of using raw sockets for distributed \napplications. And then add more if needed. I also tend to isolate the external \ntools from my business domain objects by means of interfaces and layering, \nso that I can change the tool if I have to with a minimal amount of pain. A \npositive side effect of this approach is that I generally end up with a smaller \napplication that uses fewer external tools than originally forecast.\n\n\n\n22 97 Things Every Programmer Should Know\n\nCode in the \nLanguage of \nthe Domain\nDan North\n\nPiCTURE TWO CODEBASES. In one, you come across:\nif (portfolioIdsByTraderId.get(trader.getId())\n\n.containsKey(portfolio.getId())) {...}\n\nYou scratch your head, wondering what this code might be for. It seems to be \ngetting an ID from a trader object; using that to get a map out of a, well, map-\nof-maps, apparently; and then seeing if another ID from a portfolio object \nexists in the inner map. You scratch your head some more. You look for the \ndeclaration of portfolioIdsByTraderId and discover this:\n\nMap<int, Map<int, int>> portfolioIdsByTraderId;\n\nGradually, you realize it might have something to do with whether a trader has \naccess to a particular portfolio. And of course you will find the same lookup \nfragment\u2014or, more likely, a similar but subtly different code fragment\u2014\nwhenever something cares whether a trader has access to a particular portfolio.\n\nIn the other codebase, you come across this:\nif (trader.canView(portfolio)) {...}\n\nNo head scratching. You don\u2019t need to know how a trader knows. Perhaps \nthere is one of these maps-of-maps tucked away somewhere inside. But that\u2019s \nthe trader\u2019s business, not yours.\n\nNow which of those codebases would you rather be working in?\n\nOnce upon a time, we only had very basic data structures: bits and bytes and \ncharacters (really just bytes, but we would pretend they were letters and punc-\ntuation). Decimals were a bit tricky because our base-10 numbers don\u2019t work \nvery well in binary, so we had several sizes of floating-point types. Then came \narrays and strings (really just different arrays). Then we had stacks and queues \nand hashes and linked lists and skip lists and lots of other exciting data struc-\ntures that don\u2019t exist in the real world. \u201cComputer science\u201d was about spending \n\n[image: image13.jpg]  \n\n\n\n23Collective Wisdom from the Experts\n\nlots of effort mapping the real world into our restrictive data structures. The \nreal gurus could even remember how they had done it.\n\nThen we got user-defined types! OK, this isn\u2019t news, but it does change the \ngame somewhat. If your domain contains concepts like traders and portfolios, \nyou can model them with types called, say, Trader and Portfolio. But, more \nimportantly than this, you can model relationships between them using domain \nterms, too.\n\nIf you don\u2019t code using domain terms, you are creating a tacit (read: secret) \nunderstanding that this int over here means the way to identify a trader, \nwhereas that int over there means the way to identify a portfolio. (Best not \nto get them mixed up!) And if you represent a business concept (\u201cSome trad-\ners are not allowed to view some portfolios\u2014it\u2019s illegal\u201d) with an algorithmic \nsnippet\u2014say, an existence relationship in a map of keys\u2014you aren\u2019t doing the \naudit and compliance guys any favors.\n\nThe next programmer to come along might not be in on the secret, so why \nnot make it explicit? Using a key as a lookup to another key that performs an \nexistence check is not terribly obvious. How is someone supposed to intuit \nthat\u2019s where the business rules preventing conflict of interest are implemented?\n\nMaking domain concepts explicit in your code means other programmers can \ngather the intent of the code much more easily than by trying to retrofit an algo-\nrithm into what they understand about a domain. It also means that when the \ndomain model evolves\u2014which it will, as your understanding of the domain \ngrows\u2014you are in a good position to evolve the code. Coupled with good encap-\nsulation, the chances are good that the rule will exist in only one place, and that \nyou can change it without any of the dependent code being any the wiser.\n\nThe programmer who comes along a few months later to work on the code will \nthank you. The programmer who comes along a few months later might be you.\n\n\n\n24 97 Things Every Programmer Should Know\n\nCode Is Design\nRyan Brush\n\niMAGiNE WAKiNG UP TOMORROW and learning that the construction indus-\ntry has made the breakthrough of the century. Millions of cheap, incredibly \nfast robots can fabricate materials out of thin air, have a near-zero power cost, \nand can repair themselves. And it gets better: given an unambiguous blueprint \nfor a construction project, the robots can build it without human intervention, \nall at negligible cost.\n\nOne can imagine the impact on the construction industry, but what would \nhappen upstream? How would the behavior of architects and designers change \nif construction costs were negligible? Today, physical and computer models are \nbuilt and rigorously tested before investing in construction. Would we bother \nif the construction was essentially free? If a design collapses, no big deal\u2014just \nfind out what went wrong and have our magical robots build another one. \nThere are further implications. With models obsolete, unfinished designs \nevolve by repeatedly building and improving upon an approximation of the \nend goal. A casual observer may have trouble distinguishing an unfinished \ndesign from a finished product.\n\nOur ability to predict timelines will fade away. Construction costs are more \neasily calculated than design costs\u2014we know the approximate cost of install-\ning a girder, and how many girders we need. As predictable tasks shrink toward \nzero, the less predictable design time starts to dominate. Results are produced \nmore quickly, but reliable timelines slip away.\n\nOf course, the pressures of a competitive economy still apply. With construc-\ntion costs eliminated, a company that can quickly complete a design gains an \n\n[image: image14.jpg]  \n\n\n\n25Collective Wisdom from the Experts\n\nedge in the market. Getting design done fast becomes the central push of engi-\nneering firms. Inevitably, someone not deeply familiar with the design will see \nan unvalidated version, see the market advantage of releasing early, and say, \n\u201cThis looks good enough.\u201d\n\nSome life-or-death projects will be more diligent, but in many cases, consum-\ners learn to suffer through the incomplete design. Companies can always send \nout our magic robots to \u201cpatch\u201d the broken buildings and vehicles they sell. \nAll of this points to a startlingly counterintuitive conclusion: our sole premise \nwas a dramatic reduction in construction costs, with the result that quality got \nworse.\n\nIt shouldn\u2019t surprise us that the preceding story has played out in software. \nIf we accept that code is design\u2014a creative process rather than a mechanical \none\u2014the software crisis is explained. We now have a design crisis: the demand \nfor quality, validated designs exceeds our capacity to create them. The pressure \nto use incomplete design is strong.\n\nFortunately, this model also offers clues to how we can get better. Physical \nsimulations equate to automated testing; software design isn\u2019t complete until \nit is validated with a brutal battery of tests. To make such tests more effective, \nwe are finding ways to rein in the huge state space of large systems. Improved \nlanguages and design practices give us hope. Finally, there is one inescapable \nfact: great designs are produced by great designers dedicating themselves to \nthe mastery of their craft. Code is no different.\n\n\n\n26 97 Things Every Programmer Should Know\n\nCode Layout \nMatters\nSteve Freeman\n\nAN iNFEASiBLE NUMBER OF YEARS AGO, I worked on a Cobol system where \nstaff members weren\u2019t allowed to change the indentation unless they already \nhad a reason to change the code, because someone once broke something by \nletting a line slip into one of the special columns at the beginning of a line. This \napplied even if the layout was misleading, which it sometimes was, so we had \nto read the code very carefully because we couldn\u2019t trust it. The policy must \nhave cost a fortune in programmer drag.\n\nThere\u2019s research suggesting that we all spend much more of our programming \ntime navigating and reading code\u2014finding where to make the change\u2014than \nactually typing, so that\u2019s what we want to optimize for. Here are three such \noptimizations:\n\nEasy to scan \nPeople are really good at visual pattern matching (a leftover trait from the \ntime when we had to spot lions on the savannah), so I can help myself \nby making everything that isn\u2019t directly relevant to the domain\u2014all the \n\u201caccidental complexity\u201d that comes with most commercial languages\u2014\nfade into the background by standardizing it. If code that behaves the \nsame looks the same, then my perceptual system will help me pick out \nthe differences. That\u2019s why I also observe conventions about how to lay \nout the parts of a class within a compilation unit: constants, fields, public \nmethods, private methods. \n\n[image: image15.jpg]  \n\n\n\n27Collective Wisdom from the Experts\n\nExpressive layout\nWe\u2019ve all learned to take the time to find the right names so that our code \nexpresses as clearly as possible what it does, rather than just listing the \nsteps\u2014right? The code\u2019s layout is part of this expressiveness, too. A first cut \nis to have the team agree on an automatic formatter for the basics, and then \nI might make adjustments by hand while I\u2019m coding. Unless there\u2019s active \ndissension, a team will quickly converge on a common \u201chand-finished\u201d \nstyle. A formatter cannot understand my intentions (I should know, I once \nwrote one), and it\u2019s more important to me that the line breaks and groupings \nreflect the intention of the code, not just the syntax of the language. (Kevin \nMcGuire freed me from my bondage to automatic code formatters.) \n\nCompact format\nThe more I can get on a screen, the more I can see without breaking con-\ntext by scrolling or switching files, which means I can keep less state in my \nhead. Long procedure comments and lots of whitespace made sense for \neight-character names and line printers, but now I live in an IDE that does \nsyntax coloring and cross linking. Pixels are my limiting factor, so I want \nevery one to contribute to my understanding of the code. I want the layout \nto help me understand the code, but no more than that. \n\nA nonprogrammer friend once remarked that code looks like poetry. I get \nthat feeling from really good code\u2014that everything in the text has a purpose, \nand that it\u2019s there to help me understand the idea. Unfortunately, writing code \ndoesn\u2019t have the same romantic image as writing poetry.\n\n\n\n28 97 Things Every Programmer Should Know\n\nCode Reviews\nMattias Karlsson\n\nYOU SHOULD DO CODE REViEWS. Why? Because they increase code quality \nand reduce defect rate. But not necessarily for the reasons you might think.\n\nBecause they may previously have had some bad experiences with code \nreviews, many programmers tend to dislike them. I have seen organizations \nthat require that all code pass a formal review before being deployed to pro-\nduction. Often, it is the architect or a lead developer doing this review, a \npractice that can be described as architect reviews everything. This is stated in \nthe company\u2019s software development process manual, so the programmers \nmust comply. \n\nThere may be some organizations that need such a rigid and formal process, \nbut most do not. In most organizations, such an approach is counterproductive. \nReviewees can feel like they are being judged by a parole board. Reviewers \nneed both the time to read the code and the time to keep up to date with all the \ndetails of the system; they can rapidly become the bottleneck in this process, \nand the process soon degenerates.\n\nInstead of simply correcting mistakes in code, the purpose of code reviews \nshould be to share knowledge and establish common coding guidelines. Shar-\ning your code with other programmers enables collective code ownership. \nLet a random team member walk through the code with the rest of the team. \nInstead of looking for errors, you should review the code by trying to learn \nand understand it.\n\n[image: image16.jpg]  \n\n\n\n29Collective Wisdom from the Experts\n\nBe gentle during code reviews. Ensure that comments are constructive, not \ncaustic. Introduce different roles for the review meeting to avoid having orga-\nnizational seniority among team members affect the code review. Examples \nof roles could include having one reviewer focus on documentation, another \non exceptions, and a third to look at the functionality. This approach helps to \nspread the review burden across the team members.\n\nHave a regular code review day each week. Spend a couple of hours in a review \nmeeting. Rotate the reviewee every meeting in a simple round-robin pattern. \nRemember to switch roles among team members every review meeting, too. \nInvolve newbies in code reviews. They may be inexperienced, but their fresh \nuniversity knowledge can provide a different perspective. Involve experts for \ntheir experience and knowledge. They will identify error-prone code faster \nand with more accuracy. Code reviews will flow more easily if the team has \ncoding conventions that are checked by tools. That way, code formatting will \nnever be discussed during the code review meeting.\n\nMaking code reviews fun is perhaps the most important contributor to suc-\ncess. Reviews are about the people reviewing. If the review meeting is painful \nor dull, it will be hard to motivate anyone. Make it an informal code review \nwhose principal purpose is to share knowledge among team members. Leave \nsarcastic comments outside, and bring a cake or brown-bag lunch instead.\n\n\n\n30 97 Things Every Programmer Should Know\n\nCoding with \nReason\nYechiel Kimchi\n\nTRYiNG TO REASON about software correctness by hand results in a formal \nproof that is longer than the code, and more likely to contain errors. Auto-\nmated tools are preferable but not always possible. What follows describes a \nmiddle path: reasoning semiformally about correctness.\n\nThe underlying approach is to divide all the code under consideration into \nshort sections\u2014from a single line, such as a function call, to blocks of less \nthan 10 lines\u2014and argue about their correctness. The arguments need only be \nstrong enough to convince your devil\u2019s advocate peer programmer.\n\nA section should be chosen so that at each endpoint, the state of the program \n(namely, the program counter and the values of all \u201cliving\u201d objects) satis-\nfies an easily described property, and so that the functionality of that section \n(state transformation) is easy to describe as a single task; these guidelines \nwill make reasoning simpler. Such endpoint properties generalize concepts \nlike preconditions and postconditions for functions, and invariants for loops \nand classes (with respect to their instances). Striving for sections to be as inde-\npendent of one another as possible simplifies reasoning and is indispensable \nwhen these sections are to be modified.\n\nMany of the coding practices that are well known (although perhaps less well \nfollowed) and considered \u201cgood\u201d make reasoning easier. Hence, just by intend-\ning to reason about your code, you already start moving toward a better style \nand structure. Unsurprisingly, most of these practices can be checked by static \ncode analyzers:\n\n\u2022 Avoid using goto statements, as they make remote sections highly \ninterdependent.\n\n\u2022 Avoid using modifiable global variables, as they make all sections that use \nthem dependent.\n\n[image: image17.jpg]  \n\n\n\n31Collective Wisdom from the Experts\n\n\u2022 Each variable should have the smallest possible scope. For example, a \nlocal object can be declared right before its first usage.\n\n\u2022 Make objects immutable whenever relevant.\n\n\u2022 Make the code readable by using spacing, both horizontal and vertical\u2014e.g., \naligning related structures and using an empty line to separate two sections.\n\n\u2022 Make the code self-documenting by choosing descriptive (but relatively \nshort) names for objects, types, functions, etc.\n\n\u2022 If you need a nested section, make it a function.\n\n\u2022 Make your functions short and focused on a single task. The old 24-line \nlimit still applies. Although screen size and resolution have changed, \nnothing has changed in human cognition since the 1960s.\n\n\u2022 Functions should have few parameters (four is a good upper bound). This \ndoes not restrict the data communicated to functions: grouping related \nparameters into a single object localizes object invariants, which simplifies \nreasoning with respect to their coherence and consistency.\n\n\u2022 More generally, each unit of code, from a block to a library, should have \na narrow interface. Less communication reduces the reasoning required. \nThis means that getters that return internal state are a liability\u2014don\u2019t ask \nan object for information to work with. Instead, ask the object to do the \nwork with the information it already has. In other words, encapsulation is \nall\u2014and only\u2014about narrow interfaces.\n\n\u2022 In order to preserve class invariants, usage of setters should be discouraged. \nSetters tend to allow invariants that govern an object\u2019s state to be broken. \n\nAs well as reasoning about its correctness, arguing about your code helps you \nbetter understand it. Communicate the insights you gain for everyone\u2019s benefit.\n\n\n\n32 97 Things Every Programmer Should Know\n\nA Comment on \nComments\nCal Evans\n\niN MY FiRST PROGRAMMiNG CLASS iN COLLEGE, my teacher handed out \ntwo BASIC coding sheets. On the board, the assignment read, \u201cWrite a pro-\ngram to input and average 10 bowling scores.\u201d Then the teacher left the room. \nHow hard could this be? I don\u2019t remember my final solution, but I\u2019m sure it had \na FOR/NEXT loop in it and couldn\u2019t have been more than 15 lines long in total. \nCoding sheets\u2014for you kids reading this, yes, we used to write code out long-\nhand before actually entering it into a computer\u2014allowed for around 70 lines of \ncode each. I was very confused as to why the teacher would have given us two \nsheets. Since my handwriting has always been atrocious, I used the second one \nto recopy my code very neatly, hoping to get a couple of extra points for style.\n\nMuch to my surprise, when I received the assignment back at the start of the \nnext class, I received a barely passing grade. (It was to be an omen to me for the \nrest of my time in college.) Scrawled across the top of my neatly copied code \nwas \u201cNo comments?\u201d\n\nIt was not enough that the teacher and I both knew what the program was sup-\nposed to do. Part of the point of the assignment was to teach me that my code \nshould explain itself to the next programmer coming behind me. It\u2019s a lesson \nI\u2019ve not forgotten.\n\n[image: image18.jpg]  \n\n\n\n33Collective Wisdom from the Experts\n\nComments are not evil. They are as necessary to programming as basic branch-\ning or looping constructs. Most modern languages have a tool akin to javadoc \nthat will parse properly formatted comments to automatically build an API \ndocument. This is a very good start, but not nearly enough. Inside your code \nshould be explanations about what the code is supposed to be doing. Coding \nby the old adage, \u201cIf it was hard to write, it should be hard to read,\u201d does a \ndisservice to your client, your employer, your colleagues, and your future self.\n\nOn the other hand, you can go too far in your commenting. Make sure that \nyour comments clarify your code but do not obscure it. Sprinkle your code \nwith relevant comments explaining what the code is supposed to accomplish. \nYour header comments should give any programmer enough information to \nuse your code without having to read it, while your inline comments should \nassist the next developer in fixing or extending it.\n\nAt one job, I disagreed with a design decision made by those above me. Feel-\ning rather snarky, as young programmers often do, I pasted the text of the email \ninstructing me to use their design into the header comment block of the file. It \nturned out that managers at this particular shop actually reviewed the code when \nit was committed. It was my first introduction to the term career-limiting move.\n\n\n\n34 97 Things Every Programmer Should Know\n\nComment Only \nWhat the Code \nCannot Say\nKevlin Henney\n\nTHE DiFFERENCE BETWEEN THEORY AND PRACTiCE is greater in practice \nthan it is in theory\u2014an observation that certainly applies to comments. In \ntheory, the general idea of commenting code sounds like a worthy one: offer \nthe reader detail, an explanation of what\u2019s going on. What could be more help-\nful than being helpful? In practice, however, comments often become a blight. \nAs with any other form of writing, there is a skill to writing good comments. \nMuch of the skill is in knowing when not to write them.\n\nWhen code is ill-formed, compilers, interpreters, and other tools will be sure \nto object. If the code is in some way functionally incorrect, reviews, static \nanalysis, tests, and day-to-day use in a production environment will flush \nmost bugs out. But what about comments? In The Elements of Programming \nStyle (Computing McGraw-Hill), Kernighan and Plauger note that \u201ca com-\nment is of zero (or negative) value if it is wrong.\u201d And yet such comments \noften litter and survive in a codebase in a way that coding errors never could. \nThey provide a constant source of distraction and misinformation, a subtle \nbut constant drag on a programmer\u2019s thinking.\n\nWhat of comments that are not technically wrong, but add no value to the \ncode? Such comments are noise. Comments that parrot the code offer noth-\ning extra to the reader\u2014stating something once in code and again in natural \nlanguage does not make it any truer or more real. Commented-out code is not \nexecutable code, so it has no useful effect for either reader or runtime. It also \nbecomes stale very quickly. Version-related comments and commented-out \ncode try to address questions of versioning and history. These questions have \nalready been answered (far more effectively) by version control tools.\n\n[image: image19.jpg]  \n\n\n\n35Collective Wisdom from the Experts\n\nA prevalence of noisy comments and incorrect comments in a codebase \nencourages programmers to ignore all comments, either by skipping past \nthem or by taking active measures to hide them. Programmers are resourceful \nand will route around anything perceived to be damage: folding comments \nup; switching coloring scheme so that comments and the background are the \nsame color; scripting to filter out comments. To save a codebase from such \nmisapplications of programmer ingenuity, and to reduce the risk of overlook-\ning any comments of genuine value, comments should be treated as though \nthey were code. Each comment should add some value for the reader, otherwise \nit is waste that should be removed or rewritten.\n\nWhat then qualifies as value? Comments should say something code does not \nand cannot say. A comment explaining what a piece of code should already \nsay is an invitation to change code structure or coding conventions so the code \nspeaks for itself. Instead of compensating for poor method or class names, \nrename them. Instead of commenting sections in long functions, extract \nsmaller functions whose names capture the former sections\u2019 intent. Try to \nexpress as much as possible through code. Any shortfall between what you \ncan express in code and what you would like to express in total becomes a \nplausible candidate for a useful comment. Comment what the code cannot say, \nnot simply what it does not say.\n\n\n\n36 97 Things Every Programmer Should Know\n\nContinuous \nLearning\nClint Shank\n\nWE LiVE iN iNTERESTiNG TiMES. As development gets distributed across the \nglobe, you learn there are lots of people capable of doing your job. You need to \nkeep learning to stay marketable. Otherwise you\u2019ll become a dinosaur, stuck \nin the same job until, one day, you\u2019ll no longer be needed or your job gets out-\nsourced to some cheaper resource.\n\nSo what do you do about it? Some employers are generous enough to provide \ntraining to broaden your skill set. Others may not be able to spare the time or \nmoney for any training at all. To play it safe, you need to take responsibility for \nyour own education.\n\nHere\u2019s a list of ways to keep you learning. Many of these can be found on the \nInternet for free:\n\n\u2022 Read books, magazines, blogs, Twitter feeds, and websites. If you want \nto go deeper into a subject, consider joining a mailing list or newsgroup.\n\n\u2022 If you really want to get immersed in a technology, get hands on\u2014write \nsome code.\n\n\u2022 Always try to work with a mentor, as being the top guy can hinder your \neducation. Although you can learn something from anybody, you can \nlearn a whole lot more from someone smarter or more experienced than \nyou. If you can\u2019t find a mentor, consider moving on.\n\n\u2022 Use virtual mentors. Find authors and developers on the Web who you \nreally like and read everything they write. Subscribe to their blogs.\n\n\u2022 Get to know the frameworks and libraries you use. Knowing how \nsomething works makes you know how to use it better. If they\u2019re open \nsource, you\u2019re really in luck. Use the debugger to step through the code \nto see what\u2019s going on under the hood. You\u2019ll get to see code written and \nreviewed by some really smart people.\n\n[image: image20.jpg]  \n\n\n\n37Collective Wisdom from the Experts\n\n\u2022 Whenever you make a mistake, fix a bug, or run into a problem, try to \nreally understand what happened. It\u2019s likely that someone else ran into \nthe same problem and posted it on the Web. Google is really useful here.\n\n\u2022 A good way to learn something is to teach or speak about it. When people \nare going to listen to you and ask you questions, you\u2019ll be highly motivated \nto learn. Try a lunch-\u2019n\u2019-learn at work, a user group, or a local conference.\n\n\u2022 Join or start a study group (\u00e0 la patterns community) or a local user group \nfor a language, technology, or discipline you are interested in.\n\n\u2022 Go to conferences. And if you can\u2019t go, many conferences put their talks \nonline for free.\n\n\u2022 Long commute? Listen to podcasts.\n\n\u2022 Ever run a static analysis tool over the codebase or look at the warnings \nin your IDE? Understand what they\u2019re reporting and why.\n\n\u2022 Follow the advice of the Pragmatic Programmers* and learn a new lan-\nguage every year. At least learn a new technology or tool. Branching out \ngives you new ideas you can use in your current technology stack.\n\n\u2022 Not everything you learn has to be about technology. Learn the domain \nyou\u2019re working in so you can better understand the requirements and \nhelp solve the business problem. Learning how to be more productive\u2014\nhow to work better\u2014is another good option.\n\n\u2022 Go back to school. \n\nIt would be nice to have the capability that Neo had in The Matrix, and simply \ndownload the information we need into our brains. But we don\u2019t, so it will take \na time commitment. You don\u2019t have to spend every waking hour learning. A \nlittle time\u2014say, each week\u2014is better than nothing. There is (or should be) a life \noutside of work.\n\nTechnology changes fast. Don\u2019t get left behind.\n\n* http://www.pragprog.com/titles/tpp/the-pragmatic-programmer\n\nhttp://www.pragprog.com/titles/tpp/the-pragmatic-programmer\n\n\n38 97 Things Every Programmer Should Know\n\nConvenience Is \nNot an -ility\nGregor Hohpe\n\nMUCH HAS BEEN SAiD about the importance and challenges of designing \ngood APIs. It\u2019s difficult to get right the first time and it\u2019s even more difficult \nto change later\u2014sort of like raising children. Most experienced programmers \nhave learned that a good API follows a consistent level of abstraction, exhib-\nits consistency and symmetry, and forms the vocabulary for an expressive \nlanguage. Alas, being aware of the guiding principles does not automatically \ntranslate into appropriate behavior. Eating sweets is bad for you.\n\nInstead of preaching from on high, I want to pick on a particular API design \n\u201cstrategy,\u201d one that I encounter time and again: the argument of convenience. \nIt typically begins with one of the following \u201cinsights\u201d:\n\n\u2022 I don\u2019t want other classes to have to make two separate calls to do this \none thing.\n\n\u2022 Why should I make another method if it\u2019s almost the same as this method? \nI\u2019ll just add a simple switch.\n\n\u2022 See, it\u2019s very easy: if the second string parameter ends with \u201c.txt\u201d, the \nmethod automatically assumes that the first parameter is a filename, so I \nreally don\u2019t need two methods. \n\nWhile well intended, such arguments are prone to decrease the readability of \ncode using the API. A method invocation like:\n\nparser.processNodes(text, false);\n\nis virtually meaningless without knowing the implementation or at least consult-\ning the documentation. This method was likely designed for the convenience \nof the implementer as opposed to the convenience of the caller\u2014\u201cI don\u2019t want \n\n[image: image21.jpg]  \n\n\n\n39Collective Wisdom from the Experts\n\nthe caller to have to make two separate calls\u201d translated into \u201cI didn\u2019t want to \ncode up two separate methods.\u201d There\u2019s nothing fundamentally wrong with \nconvenience if it\u2019s intended to be the antidote to tediousness, clunkiness, or \nawkwardness. However, if we think a bit more carefully about it, the antidote \nto those symptoms is efficiency, consistency, and elegance, not necessarily \nconvenience. APIs are supposed to hide underlying complexity, so we can real-\nistically expect good API design to require some effort. A single large method \ncould certainly be more convenient to write than a well-thought-out set of \noperations, but would it be easier to use?\n\nThe metaphor of API as a language can guide us toward better design decisions \nin these situations. An API should provide an expressive language, which gives \nthe next layer above sufficient vocabulary to ask and answer useful questions. \nThis does not imply that it should provide exactly one method, or verb, for each \nquestion that may be worth asking. A diverse vocabulary allows us to express \nsubtleties in meaning. For example, we prefer to say run instead of walk(true), \neven though it could be viewed as essentially the same operation, just executed \nat different speeds. A consistent and well-thought-out API vocabulary makes \nfor expressive and easy-to-understand code in the next layer up. More impor-\ntantly, a composable vocabulary allows other programmers to use the API in \nways you may not have anticipated\u2014a great convenience indeed for the users \nof the API! Next time you are tempted to lump a few things together into one \nAPI method, remember that the English language does not have one word \nfor MakeUpYourRoomBeQuietAndDoYourHomeWork, even though it would be really \nconvenient for such a frequently requested operation.\n\n\n\n40 97 Things Every Programmer Should Know\n\nDeploy Early \nand Often\nSteve Berczuk\n\nDEBUGGiNG THE DEPLOYMENT AND iNSTALLATiON PROCESSES is often \nput off until close to the end of a project. In some projects, writing installation \ntools is delegated to a release engineer who takes on the task as a \u201cnecessary \nevil.\u201d Reviews and demonstrations are done from a hand-crafted environment \nto ensure that everything works. The result is that the team gets no experience \nwith the deployment process or the deployed environment until it may be too \nlate to make changes.\n\nThe installation/deployment process is the first thing that the customer sees, \nand a simple one is the first step to having a reliable (or, at least, easy to debug) \nproduction environment. The deployed software is what the customer will \nuse. By not ensuring that the deployment sets up the application correctly, \nyou\u2019ll raise questions with your customers before they get to use your software \nthoroughly.\n\nStarting your project with an installation process will give you time to evolve \nthe process as you move through the product development cycle, and the \nchance to make changes to the application code to make the installation easier. \nRunning and testing the installation process on a clean environment periodi-\ncally also provides a check that you have not made assumptions in the code \nthat rely on the development or test environments.\n\n[image: image22.jpg]  \n\n\n\n41Collective Wisdom from the Experts\n\nPutting deployment last means that the deployment process may need to be \nmore complicated to work around assumptions in the code. What seemed a \ngreat idea in an IDE, where you have full control over an environment, might \nmake for a much more complicated deployment process. It is better to know \nall the trade-offs sooner rather than later.\n\nWhile \u201cbeing able to deploy\u201d doesn\u2019t seem to have a lot of business value \nearly on as compared to seeing an application run on a developer\u2019s laptop, \nthe simple truth is that until you can demonstrate you application on the tar-\nget environment, there is a lot of work to do before you can deliver business \nvalue. If your rationale for putting off a deployment process is that it is trivial, \nthen do it anyway since it is low cost. If it\u2019s too complicated, or if there are too \nmany uncertainties, do what you would do with application code: experiment, \nevaluate, and refactor the deployment process as you go.\n\nThe installation/deployment process is essential to the productivity of your \ncustomers or your professional services team, so you should be testing and \nrefactoring this process as you go. We test and refactor the source code \nthroughout a project. The deployment deserves no less.\n\n\n\n42 97 Things Every Programmer Should Know\n\nDistinguish Business \nExceptions from \nTechnical\nDan Bergh Johnsson\n\nTHERE ARE BASiCALLY TWO REASONS that things go wrong at runtime: \ntechnical problems that prevent us from using the application and business \nlogic that prevents us from misusing the application. Most modern languages, \nsuch as LISP, Java, Smalltalk, and C#, use exceptions to signal both these situa-\ntions. However, the two situations are so different that they should be carefully \nheld apart. It is a potential source of confusion to represent them both using \nthe same exception hierarchy, not to mention the same exception class.\n\nAn unresolvable technical problem can occur when there is a programming \nerror. For example, if you try to access element 83 from an array of size 17, \nthen the program is clearly off track, and some exception should result. The \nsubtler version is calling some library code with inappropriate arguments, \ncausing the same situation on the inside of the library.\n\nIt would be a mistake to attempt to resolve these situations you caused your-\nself. Instead, we let the exception bubble up to the highest architectural level \nand let some general exception-handling mechanism do what it can to ensure \nthat the system is in a safe state, such as rolling back a transaction, logging and \nalerting administration, and reporting back (politely) to the user.\n\nA variant of this situation is when you are in the \u201clibrary situation\u201d and a caller \nhas broken the contract of your method, e.g., passing a totally bizarre argu-\nment or not having a dependent object set up properly. This is on a par with \naccessing the 83rd element from 17: the caller should have checked; not doing \nso is a programmer error on the client side. The proper response is to throw a \ntechnical exception.\n\n[image: image23.jpg]  \n\n\n\n43Collective Wisdom from the Experts\n\nA different, but still technical, situation is when the program cannot proceed \nbecause of a problem in the execution environment, such as an unresponsive \ndatabase. In this situation, you must assume that the infrastructure did what it \ncould to resolve the issue\u2014repairing connections and retrying a reasonable num-\nber of times\u2014and failed. Even if the cause is different, the situation for the calling \ncode is similar: there is little it can do about it. So, we signal the situation through \nan exception that we let bubble up to the general exception-handling mechanism.\n\nIn contrast to these, we have the situation where you cannot complete the call \nfor a domain-logical reason. In this case, we have encountered a situation that \nis an exception, i.e., unusual and undesirable, but not bizarre or programmati-\ncally in error (for example, if I try to withdraw money from an account with \ninsufficient funds). In other words, this kind of situation is a part of the con-\ntract, and throwing an exception is just an alternative return path that is part \nof the model and that the client should be aware of and be prepared to handle. \nFor these situations, it is appropriate to create a specific exception or a separate \nexception hierarchy so that the client can handle the situation on its own terms.\n\nMixing technical exceptions and business exceptions in the same hierarchy \nblurs the distinction and confuses the caller about what the method contract \nis, what conditions it is required to ensure before calling, and what situations \nit is supposed to handle. Separating the cases gives clarity and increases \nthe chances that technical exceptions will be handled by some application \nframework, while the business domain exceptions actually are considered \nand handled by the client code.\n\n\n\n44 97 Things Every Programmer Should Know\n\nDo Lots of \nDeliberate Practice\nJon Jagger\n\nDELiBERATE PRACTiCE iS NOT SiMPLY PERFORMiNG A TASK. If you ask \nyourself, \u201cWhy am I performing this task?\u201d and your answer is, \u201cTo complete \nthe task,\u201d then you\u2019re not doing deliberate practice.\n\nYou do deliberate practice to improve your ability to perform a task. It\u2019s about \nskill and technique. Deliberate practice means repetition. It means performing \nthe task with the aim of increasing your mastery of one or more aspects of the \ntask. It means repeating the repetition. Slowly, over and over again, until you \nachieve your desired level of mastery. You do deliberate practice to master the \ntask, not to complete the task.\n\nThe principal aim of paid development is to finish a product, whereas the \nprincipal aim of deliberate practice is to improve your performance. They are \nnot the same. Ask yourself, how much of your time do you spend developing \nsomeone else\u2019s product? How much developing yourself?\n\nHow much deliberate practice does it take to acquire expertise?\n\n\u2022 Peter Norvig writes* that \u201cit may be that 10,000 hours\u2026is the magic \nnumber.\u201d\n\n\u2022 In Leading Lean Software Development (Addison-Wesley Professional), \nMary Poppendieck notes that \u201cit takes elite performers a minimum of \n10,000 hours of deliberate focused practice to become experts.\u201d\n\n* http://norvig.com/21-days.html\n\n[image: image24.jpg]  \n\nhttp://norvig.com/21-days.html\n\n\n45Collective Wisdom from the Experts\n\nThe expertise arrives gradually over time\u2014not all at once in the 10,000th \nhour! Nevertheless, 10,000 hours is a lot: about 20 hours per week for 10 years. \nGiven this level of commitment, you might be worrying that you\u2019re just not \nexpert material. You are. Greatness is largely a matter of conscious choice. \nYour choice. Research over the last two decades has shown that the main fac-\ntor in acquiring expertise is time spent doing deliberate practice. Innate ability \nis not the main factor. According to Mary Poppendieck:\n\nThere is broad consensus among researchers of expert performance that inborn \ntalent does not account for much more than a threshold; you have to have a mini-\nmum amount of natural ability to get started in a sport or profession. After that, \nthe people who excel are the ones who work the hardest.\n\nThere is little point to deliberately practicing something you are already an \nexpert at. Deliberate practice means practicing something you are not good at. \nPeter Norvig explains:\n\nThe key [to developing expertise] is deliberative practice: not just doing it again \nand again, but challenging yourself with a task that is just beyond your current abil-\nity, trying it, analyzing your performance while and after doing it, and correcting \nany mistakes.\n\nAnd Mary Poppendieck writes:\n\nDeliberate practice does not mean doing what you are good at; it means challeng-\ning yourself, doing what you are not good at. So it\u2019s not necessarily fun.\n\nDeliberate practice is about learning\u2014learning that changes you, learning that \nchanges your behavior. Good luck.\n\n\n\n46 97 Things Every Programmer Should Know\n\nDomain-Specific \nLanguages\nMichael Hunger\n\nWHENEVER YOU LiSTEN TO A DiSCUSSiON BY ExPERTS in any domain, be \nit chess players, kindergarten teachers, or insurance agents, you\u2019ll notice that \ntheir vocabulary is quite different from everyday language. That\u2019s part of what \ndomain-specific languages (DSLs) are about: a specific domain has a specialized \nvocabulary to describe the things that are particular to that domain.\n\nIn the world of software, DSLs are about executable expressions in a language \nspecific to a domain, employing a limited vocabulary and grammar that is \nreadable, understandable, and\u2014hopefully\u2014writable by domain experts. DSLs \ntargeted at software developers or scientists have been around for a long time. \nThe Unix \u201clittle languages\u201d found in configuration files and the languages cre-\nated with the power of LISP macros are some of the older examples.\n\nDSLs are commonly classified as either internal or external:\n\nInternal DSLs \nAre written in a general-purpose programming language whose syntax \nhas been bent to look much more like natural language. This is easier for \nlanguages that offer more syntactic sugar and formatting possibilities (e.g., \nRuby and Scala) than it is for others that do not (e.g., Java). Most internal \nDSLs wrap existing APIs, libraries, or business code and provide a wrap-\nper for less mind-bending access to the functionality. They are directly \nexecutable by just running them. Depending on the implementation and \nthe domain, they are used to build data structures, define dependencies, \nrun processes or tasks, communicate with other systems, or validate user \ninput. The syntax of an internal DSL is constrained by the host language. \nThere are many patterns\u2014e.g., expression builder, method chaining, and \nannotation\u2014that can help you to bend the host language to your DSL. If \nthe host language doesn\u2019t require recompilation, an internal DSL can be \ndeveloped quite quickly working side by side with a domain expert. \n\n[image: image25.jpg]  \n\n\n\n47Collective Wisdom from the Experts\n\nExternal DSLs \nAre textual or graphical expressions of the language\u2014although textual DSLs \ntend to be more common than graphical ones. Textual expressions can be \nprocessed by a toolchain that includes lexer, parser, model transformer, gen-\nerators, and any other type of post-processing. External DSLs are mostly read \ninto internal models that form the basis for further processing. It is helpful to \ndefine a grammar (e.g., in EBNF). A grammar provides the starting point for \ngenerating parts of the toolchain (e.g., editor, visualizer, parser generator). \nFor simple DSLs, a handmade parser may be sufficient\u2014using, for instance, \nregular expressions. Custom parsers can become unwieldy if too much is \nasked of them, so it makes sense to look at tools designed specifically for \nworking with language grammars and DSLs\u2014e.g., openArchitectureWare, \nANTLR, SableCC, AndroMDA. Defining external DSLs as XML dialects \nis also quite common, although readability is often an issue\u2014especially for \nnontechnical readers. \n\nYou must always take the target audience of your DSL into account. Are they \ndevelopers, managers, business customers, or end users? You have to adapt the \ntechnical level of the language, the available tools, syntax help (e.g., IntelliSense), \nearly validation, visualization, and representation to the intended audience. \nBy hiding technical details, DSLs can empower users by giving them the abil-\nity to adapt systems to their needs without requiring the help of developers. It \ncan also speed up development because of the potential distribution of work \nafter the initial language framework is in place. The language can be evolved \ngradually. There are also different migration paths for existing expressions and \ngrammars available.\n\n\n\n48 97 Things Every Programmer Should Know\n\nDon\u2019t Be Afraid \nto Break Things\nMike Lewis\n\nEVERYONE WiTH iNDUSTRY ExPERiENCE has undoubtedly worked on a \nproject where the codebase was precarious at best. The system is poorly factored, \nand changing one thing always manages to break another unrelated feature. \nWhenever a module is added, the coder\u2019s goal is to change as little as possible, \nand hold his breath during every release. This is the software equivalent of \nplaying Jenga with I-beams in a skyscraper, and is bound for disaster.\n\nThe reason that making changes is so nerve-racking is because the system is \nsick. It needs a doctor, otherwise its condition will only worsen. You already \nknow what is wrong with your system, but you are afraid of breaking the eggs \nto make your omelet. A skilled surgeon knows that cuts have to be made in \norder to operate, but she also knows that the cuts are temporary and will heal. \nThe end result of the operation is worth the initial pain, and the patient should \nheal to a better state than he was in before the surgery.\n\nDon\u2019t be afraid of your code. Who cares if something gets temporarily broken \nwhile you move things around? A paralyzing fear of change is what got your \nproject into this state to begin with. Investing the time to refactor will pay for \nitself several times over the lifecycle of your project. An added benefit is that \nyour team\u2019s experience dealing with the sick system makes you all experts \nin knowing how it should work. Apply this knowledge rather than resent it. \nWorking on a system you hate is not how anybody should have to spend his time.\n\n[image: image26.jpg]  \n\n\n\n49Collective Wisdom from the Experts\n\nRedefine internal interfaces, restructure modules, refactor copy\u2013pasted code, \nand simplify your design by reducing dependencies. You can significantly \nreduce code complexity by eliminating corner cases, which often result from \nimproperly coupled features. Slowly transition the old structure into the new \none, testing along the way. Trying to accomplish a large refactor in \u201cone big \nshebang\u201d will cause enough problems to make you consider abandoning the \nwhole effort midway through.\n\nBe the surgeon who isn\u2019t afraid to cut out the sick parts to make room for heal-\ning. The attitude is contagious and will inspire others to start working on those \ncleanup projects they\u2019ve been putting off. Keep a \u201chygiene\u201d list of tasks that the \nteam feels are worthwhile for the general good of the project. Convince man-\nagement that even though these tasks may not produce visible results, they \nwill reduce expenses and expedite future releases. Never stop caring about the \ngeneral \u201chealth\u201d of the code.\n\n\n\n50 97 Things Every Programmer Should Know\n\nDon\u2019t Be Cute with \nYour Test Data\nRod Begbie\n\nIt was getting late. I was throwing in some placeholder data to test the page \nlayout I\u2019d been working on.\n\nI appropriated the members of The Clash for the names of users. Company \nnames? Song titles by the Sex Pistols would do. Now I needed some stock ticker \nsymbols\u2014just some four-letter words in capital letters.\n\nI used those four-letter words.\n\nIt seemed harmless. Just something to amuse myself, and maybe the other \ndevelopers the next day before I wired up the real data source.\n\nThe following morning, a project manager took some screenshots for a \npresentation.\n\nPROGRAMMiNG HiSTORY is littered with these kinds of war stories. Things that \ndevelopers and designers did \u201cthat no one else would see,\u201d which unexpectedly \nbecame visible.\n\nThe leak type can vary but, when it happens, it can be deadly to the person, \nteam, or company responsible. Examples include:\n\n\u2022 During a status meeting, a client clicks on a button that is as yet unimple-\nmented. He is told, \u201cDon\u2019t click that again, you moron.\u201d \n\n\u2022 A programmer maintaining a legacy system has been told to add an error \ndialog, and decides to use the output of existing behind-the-scenes log-\nging to power it. Users are suddenly faced with messages such as \u201cHoly \ndatabase commit failure, Batman!\u201d when something breaks. \n\n\u2022 Someone mixes up the test and live administration interfaces, and does \nsome \u201cfunny\u201d data entry. Customers spot a $1M \u201cBill Gates\u2013shaped \npersonal massager\u201d on sale in your online store. \n\n[image: image27.jpg]  \n\n\n\n51Collective Wisdom from the Experts\n\nTo appropriate the old saying that \u201ca lie can travel halfway around the world \nwhile the truth is putting on its shoes,\u201d in this day and age, a screw-up can be \nDugg, Twittered, and Flibflarbed before anyone in the developer\u2019s time zone is \nawake to do anything about it.\n\nEven your source code isn\u2019t necessarily free of scrutiny. In 2004, when a tarball \nof the Windows 2000 source code made its way onto file-sharing networks, \nsome folks merrily grepped through it for profanity, insults, and other funny \ncontent.* (The comment // TERRIBLE HORRIBLE NO GOOD VERY BAD HACK has, I \nwill admit, become appropriated by me from time to time since!)\n\nIn summary, when writing any text in your code\u2014whether comments, log-\nging, dialogs, or test data\u2014always ask yourself how it will look if it becomes \npublic. It will save some red faces all around.\n\n* http://www.kuro5hin.org/story/2004/2/15/71552/7795\n\nhttp://www.kuro5hin.org/story/2004/2/15/71552/7795\n\n\n52 97 Things Every Programmer Should Know\n\nDon\u2019t Ignore \nThat Error!\nPete Goodliffe\n\nI was walking down the street one evening to meet some friends in a bar. We \nhadn\u2019t shared a beer in some time, and I was looking forward to seeing them \nagain. In my haste, I wasn\u2019t looking where I was going. I tripped over the edge \nof a curb and ended up flat on my face. Well, it serves me right for not paying \nattention, I guess.\n\nIt hurt my leg, but I was in a hurry to meet my friends. So, I pulled myself up \nand carried on. As I walked farther, the pain was getting worse. Although I\u2019d \ninitially dismissed it as shock, I rapidly realized there was something wrong.\n\nBut I hurried on to the bar regardless. I was in agony by the time I arrived. I \ndidn\u2019t have a great night out, because I was terribly distracted. In the morning, \nI went to the doctor and found out I\u2019d fractured my shin bone. Had I stopped \nwhen I felt the pain, I would\u2019ve prevented a lot of extra damage that I caused \nby walking on it. Probably the worst morning after of my life.\n\nTOO MANY PROGRAMMERS write code like my disastrous night out.\n\nError, what error? It won\u2019t be serious. Honestly. I can ignore it. This is not a win-\nning strategy for solid code. In fact, it\u2019s just plain laziness. (The wrong sort.) \nNo matter how unlikely you think an error is in your code, you should always \ncheck for it, and always handle it. Every time. You\u2019re not saving time if you \ndon\u2019t; you\u2019re storing up potential problems for the future.\n\nWe report errors in our code in a number of ways, including:\n\n\u2022 Return codes can be used as the resulting value of a function to mean \n\u201cit didn\u2019t work.\u201d Error return codes are far too easy to ignore. You won\u2019t \nsee anything in the code to highlight the problem. Indeed, it\u2019s become \nnormal practice to ignore some standard C functions\u2019 return values. How \noften do you check the return value from printf?\n\n\u2022 errno is a curious C aberration, a separate global variable set to sig-\nnal error. It\u2019s easy to ignore, hard to use, and leads to all sorts of nasty \n problems\u2014for example, what happens when you have multiple threads \n\n[image: image28.jpg]  \n\n\n\n53Collective Wisdom from the Experts\n\ncalling the same function? Some platforms insulate you from pain here; \nothers do not.\n\n\u2022 Exceptions are a more structured language-supported way of signaling \nand handling errors. And you can\u2019t possibly ignore them. Or can you? I\u2019ve \nseen lots of code like this: \n\ntry {\n\n    // ...do something...\n\n}\n\ncatch (...) {} // ignore errors\n\nThe saving grace of this awful construct is that it highlights the fact that \nyou\u2019re doing something morally dubious.\n\nIf you ignore an error, turn a blind eye, and pretend that nothing has gone wrong, \nyou run great risks. Just as my leg ended up in a worse state than if I\u2019d stopped \nwalking on it immediately, plowing on regardless of the red flags can lead to very \ncomplex failures. Deal with problems at the earliest opportunity. Keep a short \naccount.\n\nNot handling errors leads to:\n\n\u2022 Brittle code. Code that\u2019s filled with exciting, hard-to-find bugs.\n\n\u2022 Insecure code. Crackers often exploit poor error handling to break into \nsoftware systems.\n\n\u2022 Poor structure. If there are errors from your code that are tedious to deal \nwith continually, you probably have a poor interface. Express it so that \nthe errors are less intrusive and their handling is less onerous. \n\nJust as you should check all potential errors in your code, you need to expose \nall potentially erroneous conditions in your interfaces. Do not hide them, pre-\ntending that your services will always work.\n\nWhy don\u2019t we check for errors? There are a number of common excuses. \nWhich of these do you agree with? How would you counter each one?\n\n\u2022 Error handling clutters up the flow of the code, making it harder to read, \nand harder to spot the \u201cnormal\u201d flow of execution.\n\n\u2022 It\u2019s extra work, and I have a deadline looming.\n\n\u2022 I know that this function call will never return an error (printf always \nworks, malloc always returns new memory\u2014if it fails, we have bigger \nproblems\u2026).\n\n\u2022 It\u2019s only a toy program, and needn\u2019t be written to a production-worthy level.\n\n\n\n54 97 Things Every Programmer Should Know\n\nDon\u2019t Just Learn the \nLanguage, Understand \nIts Culture\nAnders Nor\u00e5s\n\niN HiGH SCHOOL, i HAD TO LEARN A FOREiGN LANGUAGE. At the time, I \nthought that I\u2019d get by nicely being good at English, so I chose to sleep through \nthree years of French class. A few years later, I went to Tunisia on vacation. \nArabic is the official language there and, being a former French colony, French \nis also commonly used. English is only spoken in the touristy areas. Because \nof my linguistic ignorance, I found myself confined at the poolside reading \nFinnegans Wake, James Joyce\u2019s tour de force in form and language. Joyce\u2019s playful \nblend of more than 40 languages was a surprising, albeit exhausting, experience. \nRealizing how interwoven foreign words and phrases gave the author new ways \nof expressing himself is something I\u2019ve kept with me in my programming career.\n\nIn their seminal book, The Pragmatic Programmer (Addison-Wesley Profes-\nsional), Andy Hunt and Dave Thomas encourage us to learn a new program-\nming language every year. I\u2019ve tried to live by their advice, and throughout the \nyears, I\u2019ve had the experience of programming in many languages. My most \nimportant lesson from my polyglot adventures is that it takes more than just \nlearning the syntax to learn a language: you need to understand its culture. \n\nYou can write Fortran in any language, but to truly learn a language you have \nto embrace it. \n\nDon\u2019t make excuses if your C# code is a long Main method with mostly static \nhelper methods, but learn why classes make sense. Don\u2019t shy away if you have a \nhard time understanding the lambda expressions used in functional languages\u2014\nforce yourself to use them.\n\n[image: image29.jpg]  \n\n\n\n55Collective Wisdom from the Experts\n\nOnce you\u2019ve learned the ropes of a new language, you\u2019ll be surprised how \nyou\u2019ll start using languages you already know in new ways. \n\nI learned how to use delegates effectively in C# from programming Ruby; \nreleasing the full potential of .NET\u2019s generics gave me ideas on how I could \nmake Java generics more useful; and LINQ made it a breeze to teach myself \nScala.\n\nYou\u2019ll also get a better understanding of design patterns by moving between \ndifferent languages. C programmers find that C# and Java have commoditized \nthe iterator pattern. In Ruby and other dynamic languages, you might still use \na visitor, but your implementation won\u2019t look like the example from the Gang \nof Four book.\n\nSome might argue that Finnegans Wake is unreadable, while others applaud it \nfor its stylistic beauty. To make the book a less daunting read, single language \ntranslations are available. Ironically, the first of these was in French. \n\nCode is in many ways similar. If you write Wakese code with a little Python, \nsome Java, and a hint of Erlang, your projects will be a mess. If you instead \nexplore new languages to expand your mind and get fresh ideas on how you \ncan solve things in different ways, you will find that the code you write in your \ntrusty old language gets more beautiful for every new language you\u2019ve learned.\n\n\n\n56 97 Things Every Programmer Should Know\n\nDon\u2019t Nail Your \nProgram into the \nUpright Position\nVerity Stob\n\ni ONCE WROTE A SPOOF C++ qUiz, in which I satirically suggested the fol-\nlowing strategy for exception handling:\n\nBy dint of plentiful try...catch constructs throughout our codebase, we are \nsometimes able to prevent our applications from aborting. We think of the resul-\ntant state as \u201cnailing the corpse in the upright position.\u201d \n\nDespite my levity, I was actually summarizing a lesson I received at the knee of \nDame Bitter Experience herself.\n\nIt was a base application class in our own, homemade C++ library. It had suf-\nfered the pokings of many programmers\u2019 fingers over the years: nobody\u2019s hands \nwere clean. It contained code to deal with all escaped exceptions from every-\nthing else. Taking our lead from Yossarian in Catch-22, we decided, or rather felt \n(decided implies more thought than went into the construction of this monster) \nthat an instance of this class should live forever or die in the attempt.\n\nTo this end, we intertwined multiple exception handlers. We mixed in \nWindows\u2019 structured exception handling with the native kind (remember \n__try...__except in C++? Me, neither). When things threw unexpectedly, we \ntried calling them again, pressing the parameters harder. Looking back, I like to \nthink that when writing an inner try...catch handler within the catch clause \nof another, some sort of awareness crept over me that I might have accidentally \ntaken a slip road from the motorway of good practice into the aromatic but \ninsalubrious lane of lunacy. However, this is probably retrospective wisdom.\n\n[image: image30.jpg]  \n\n\n\n57Collective Wisdom from the Experts\n\nNeedless to say, whenever something went wrong in applications based on this \nclass, they vanished like Mafia victims at the dockside, leaving behind no useful \ntrail of bubbles to indicate what the hell happened, notwithstanding the dump \nroutines that were supposedly called to record the disaster. Eventually\u2014a long \neventually\u2014we took stock of what we had done, and experienced shame. We \nreplaced the whole mess with a minimal and robust reporting mechanism. But \nthis was many crashes down the line.\n\nI wouldn\u2019t bother you with this\u2014for surely nobody else could ever be as stupid \nas we were\u2014but for an online argument I had recently with a bloke whose \nacademic job title declared he should know better. We were discussing Java \ncode in a remote transaction. If the code failed, he argued, it should catch and \nblock the exception in situ. (\u201cAnd then do what with it?\u201d I asked. \u201cCook it for \nsupper?\u201d)\n\nHe quoted the UI designers\u2019 rule: NEVER LET THE USER SEE AN EXCEP-\nTION REPORT, rather as though this settled the matter, what with it being \nin caps and everything. I wonder if he was responsible for the code in one of \nthose blue-screened ATMs whose photos decorate the feebler blogs, and had \nbeen permanently traumatized.\n\nAnyway, if you should meet him, nod and smile and take no notice, as you \nsidle toward the door.\n\n\n\n58 97 Things Every Programmer Should Know\n\nDon\u2019t Rely on \n\u201cMagic Happens \nHere\u201d\nAlan Griffiths\n\niF YOU LOOK AT ANY ACTiViTY, process, or discipline from far enough away, \nit looks simple. Managers with no experience of development think what pro-\ngrammers do is simple, and programmers with no experience of management \nthink the same of what managers do.\n\nProgramming is something some people do\u2014some of the time. And the hard \npart\u2014the thinking\u2014is the least visible and least appreciated by the uninitiated. \nThere have been many attempts to remove the need for this skilled think-\ning over the decades. One of the earliest and most memorable is the effort \nby Grace Hopper to make programming languages less cryptic\u2014which some \naccounts predicted would remove the need for specialist programmers. The \nresult (COBOL) has contributed to the income of many specialist programmers \nover subsequent decades.\n\nThe persistent vision that software development can be simplified by removing \nprogramming is, to the programmer who understands what is involved, obvi-\nously na\u00efve. But the mental process that leads to this mistake is part of human \nnature, and programmers are just as prone to making it as everyone else.\n\nOn any project, there are likely many things that an individual programmer \ndoesn\u2019t get actively involved in: eliciting requirements from users, getting bud-\ngets approved, setting up the build server, deploying the application to QA \nand production environments, migrating the business from the old processes \nor programs, etc.\n\n[image: image31.jpg]  \n\n\n\n59Collective Wisdom from the Experts\n\nWhen you aren\u2019t actively involved in things, there is an unconscious tendency \nto assume that they are simple and happen \u201cby magic.\u201d While the magic con-\ntinues to happen, all is well. But when\u2014it is usually \u201cwhen\u201d and not \u201cif \u201d\u2014the \nmagic stops, the project is in trouble.\n\nI\u2019ve seen projects lose weeks of developer time because no one understood \nhow they relied on \u201cthe right\u201d version of a DLL being loaded. When things \nstarted failing intermittently, team members looked everywhere else before \nsomeone noticed that \u201ca wrong\u201d version of the DLL was being loaded.\n\nAnother department was running smoothly\u2014projects delivered on time, no \nlate-night debugging sessions, no emergency fixes. So smoothly, in fact, that \nsenior management decided that things \u201cran themselves,\u201d and it could do \nwithout the project manager. Within six months, the projects in the depart-\nment looked just like the rest of the organization\u2014late, buggy, and continually \nbeing patched.\n\nYou don\u2019t have to understand all the magic that makes your project work, \nbut it doesn\u2019t hurt to understand some of it\u2014or to appreciate someone who \nunderstands the bits you don\u2019t.\n\nMost importantly, make sure that when the magic stops, it can be started again.\n\n\n\n60 97 Things Every Programmer Should Know\n\nDon\u2019t Repeat \nYourself\nSteve Smith\n\nOF ALL THE PRiNCiPLES OF PROGRAMMiNG,  Don\u2019t Repeat Yourself (DRY) is \nperhaps one of the most fundamental. The principle was formulated by Andy Hunt \nand Dave Thomas in The Pragmatic Programmer, and underlies many other well-\nknown software development best practices and design patterns. The developer \nwho learns to recognize duplication, and understands how to eliminate it through \nappropriate practice and proper abstraction, can produce much cleaner code than \none who continuously infects the application with unnecessary repetition.\n\nDuplication is Waste\n\nEvery line of code that goes into an application must be maintained, and is a \npotential source of future bugs. Duplication needlessly bloats the codebase, \nresulting in more opportunities for bugs and adding accidental complexity to \nthe system. The bloat that duplication adds to the system also makes it more \ndifficult for developers working with the system to fully understand the entire \nsystem, or to be certain that changes made in one location do not also need \nto be made in other places that duplicate the logic they are working on. DRY \nrequires that \u201cevery piece of knowledge must have a single, unambiguous, \nauthoritative representation within a system.\u201d\n\nRepetition in Process Calls for Automation\n\nMany processes in software development are repetitive and easily automated. \nThe DRY principle applies in these contexts, as well as in the source code of \nthe application. Manual testing is slow, error-prone, and difficult to repeat, \nso automated test suites should be used where possible. Integrating software \ncan be time consuming and error-prone if done manually, so a build process \nshould be run as frequently as possible, ideally with every check-in. Wherever \npainful manual processes exist that can be automated, they should be auto-\nmated and standardized. The goal is to ensure that there is only one way of \naccomplishing the task, and it is as painless as possible.\n\n[image: image32.jpg]  \n\n\n\n61Collective Wisdom from the Experts\n\nRepetition in Logic Calls for Abstraction\n\nRepetition in logic can take many forms. Copy-and-paste if-then or switch-\ncase logic is among the easiest to detect and correct. Many design patterns \nhave the explicit goal of reducing or eliminating duplication in logic within \nan application. If an object typically requires several things to happen before \nit can be used, this can be accomplished with an Abstract Factory or a Factory \nMethod pattern. If an object has many possible variations in its behavior, these \nbehaviors can be injected using the Strategy pattern rather than large if-then \nstructures. In fact, the formulation of design patterns themselves is an attempt \nto reduce the duplication of effort required to solve common problems and \ndiscuss such solutions. In addition, DRY can be applied to structures, such as \ndatabase schema, resulting in normalization.\n\nA Matter of Principle\n\nOther software principles are also related to DRY. The Once and Only Once prin-\nciple, which applies only to the functional behavior of code, can be thought of as \na subset of DRY. The Open/Closed Principle, which states that \u201csoftware entities \nshould be open for extension, but closed for modification,\u201d only works in practice \nwhen DRY is followed. Likewise, the well-known Single Responsibility Principle, \nwhich requires that a class have \u201conly one reason to change,\u201d relies on DRY.\n\nWhen followed with regard to structure, logic, process, and function, the DRY \nprinciple provides fundamental guidance to software developers and aids the \ncreation of simpler, more maintainable, higher-quality applications. While there \nare scenarios where repetition can be necessary to meet performance or other \nrequirements (e.g., data denormalization in a database), it should be used only \nwhere it directly addresses an actual rather than an imagined problem.\n\n\n\n62 97 Things Every Programmer Should Know\n\nCal Evans\n\niT HAS HAPPENED TO EVERY ONE OF US AT SOME POiNT. Your code was \nrolled onto the staging server for system testing, and the testing manager \nwrites back that she has hit a problem. Your first reaction is \u201cQuick, let me fix \nthat\u2014I know what\u2019s wrong.\u201d\n\nIn the bigger sense, though, what is wrong is that as a developer you think you \nshould have access to the staging server.\n\nIn most web-based development environments, the architecture can be broken \ndown like this:\n\n\u2022 Local development and unit testing on the developer\u2019s machine\n\n\u2022 Development server where manual or automated integration testing is \ndone\n\n\u2022 Staging server where the QA team and the users do acceptance testing\n\n\u2022 Production server \n\nYes, there are other servers and services sprinkled in there, like source code \ncontrol and ticketing, but you get the idea. Using this model, a developer\u2014\neven a senior developer\u2014should never have access beyond the development \nserver. Most development is done on a developer\u2019s local machine using his \nfavorite blend of IDEs, virtual machines, and an appropriate sprinkling of \nblack magic for good luck.\n\nDon\u2019t Touch \nThat Code!\n\n[image: image33.jpg]  \n\n\n\n63Collective Wisdom from the Experts\n\nOnce checked into SCC, whether automatically or manually, it should be rolled \nover to the development server, where it can be tested and tweaked if neces-\nsary to make sure everything works together. From this point on, though, the \ndeveloper is a spectator to the process.\n\nThe staging manager should package and roll the code to the staging server \nfor the QA team. Just like developers should have no need to access anything \nbeyond the development server, the QA team and the users have no need to \ntouch anything on the development server. If it\u2019s ready for acceptance test-\ning, cut a release and roll; don\u2019t ask the user to \u201cjust look at something real \nquick\u201d on the development server. Remember, unless you are coding the project \nby yourself, other people have code there and they may not be ready for the user \nto see it. The release manager is the only person who should have access to both.\n\nUnder no circumstances\u2014ever, at all\u2014should a developer have access to a \nproduction server. If there is a problem, your support staff should either fix \nit or request that you fix it. After it\u2019s checked into SCC, they will roll a patch \nfrom there. Some of the biggest programming disasters I\u2019ve been a part of have \ntaken place because someone *cough*me*cough* violated this last rule. If it\u2019s \nbroke, production is not the place to fix it.\n\n\n\n64 97 Things Every Programmer Should Know\n\nEncapsulate \nBehavior, \nNot Just State\nEinar Landre\n\niN SYSTEMS THEORY, containment is one of the most useful constructs when \ndealing with large and complex system structures. In the software industry, \nthe value of containment or encapsulation is well understood. Containment \nis supported by programming language constructs such as subroutines and \nfunctions, modules and packages, classes, and so on.\n\nModules and packages address the larger-scale needs for encapsulation, while \nclasses, subroutines, and functions address the more fine-grained aspects of \nthe matter. Over the years, I have discovered that classes seem to be one of the \nhardest encapsulation constructs for developers to get right. It\u2019s not uncom-\nmon to find a class with a single 3,000-line main method, or a class with only \nset and get methods for its primitive attributes. These examples demonstrate \nthat the developers involved have not fully understood object-oriented think-\ning, having failed to take advantage of the power of objects as modeling con-\nstructs. For developers familiar with the terms POJO (Plain Old Java Object) \nand POCO (Plain Old C# Object or Plain Old CLR Object), this was the intent \nin going back to the basics of OO as a modeling paradigm\u2014the objects are \nplain and simple, but not dumb.\n\nAn object encapsulates both state and behavior, where the behavior is defined \nby the actual state. Consider a door object. It has four states: closed, open, \nclosing, opening. It provides two operations: open and close. Depending on \n\n[image: image34.jpg]  \n\n\n\n65Collective Wisdom from the Experts\n\nthe state, the open and close operations will behave differently. This inherent \nproperty of an object makes the design process conceptually simple. It boils \ndown to two simple tasks: allocation and delegation of responsibility to the \ndifferent objects including the interobject interaction protocols.\n\nHow this works in practice is best illustrated with an example. Let\u2019s say we have \nthree classes: Customer, Order, and Item. A Customer object is the natural place-\nholder for the credit limit and credit validation rules. An Order object knows \nabout its associated Customer, and its addItem operation delegates the actual credit \ncheck by calling customer.validateCredit(item.price()). If the postcondition \nfor the method fails, an exception can be thrown and the purchase aborted.\n\nLess experienced object-oriented developers might decide to wrap all the busi-\nness rules into an object very often referred to as OrderManager or OrderService. \nIn these designs, Order, Customer, and Item are treated as little more than record \ntypes. All logic is factored out of the classes and tied together in one large, \nprocedural method with a lot of internal if-then-else constructs. These meth-\nods are easily broken and are almost impossible to maintain. The reason? The \nencapsulation is broken.\n\nSo, in the end, don\u2019t break the encapsulation, and use the power of your pro-\ngramming language to maintain it.\n\n\n\n66 97 Things Every Programmer Should Know\n\nFloating-Point \nNumbers \nAren\u2019t Real\nChuck Allison\n\nFLOATiNG-POiNT NUMBERS ARE NOT \u201cREAL NUMBERS\u201d in the mathemati-\ncal sense, even though they are called real in some programming languages, \nsuch as Pascal and Fortran. Real numbers have infinite precision and are there-\nfore continuous and nonlossy; floating-point numbers have limited precision, \nso they are finite, and they resemble \u201cbadly behaved\u201d integers, because they\u2019re \nnot evenly spaced throughout their range.\n\nTo illustrate, assign 2147483647 (the largest signed 32-bit integer) to a 32-bit \nfloat variable (x, say), and print it. You\u2019ll see 2147483648. Now print x-64. Still \n2147483648. Now print x-65, and you\u2019ll get 2147483520! Why? Because the \nspacing between adjacent floats in that range is 128, and floating-point opera-\ntions round to the nearest floating-point number.\n\nIEEE floating-point numbers are fixed-precision numbers based on base-two \nscientific notation: 1.d1d2...dp 1 \u00d7 2e, where p is the precision (24 for float, 53 \nfor double). The spacing between two consecutive numbers is 21\u2013p+e, which can \nbe safely approximated by \u03b5|x|, where \u03b5 is the machine epsilon (21\u2013p).\n\nKnowing the spacing in the neighborhood of a floating-point number can help \nyou avoid classic numerical blunders. For example, if you\u2019re performing an \niterative calculation, such as searching for the root of an equation, there\u2019s no \nsense in asking for greater precision than the number system can give in the \nneighborhood of the answer. Make sure that the tolerance you request is no \nsmaller than the spacing there, otherwise you\u2019ll loop forever.\n\nSince floating-point numbers are approximations of real numbers, there is inevi-\ntably a little error present. This error, called roundoff, can lead to surprising results. \n\n[image: image35.jpg]  \n\n\n\n67Collective Wisdom from the Experts\n\nWhen you subtract nearly equal numbers, for example, the most significant \ndigits cancel one another out, so what was the least significant digit (where the \nroundoff error resides) gets promoted to the most significant position in the \nfloating-point result, essentially contaminating any further related computa-\ntions (a phenomenon known as smearing). You need to look closely at your \nalgorithms to prevent such catastrophic cancellation. To illustrate, consider \nsolving the equation x2 \u2013 100000x + 1 = 0 with the quadratic formula. Since \nthe operands in the expression \u2013b + sqrt(b2 \u2013 4) are nearly equal in magnitude, \nyou can instead compute the root r1 = \u2013b \u2013 sqrt(b2 \u2013 4), and then obtain r2 = 1/r1, \nsince for any quadratic equation, ax2 + bx + c = 0, the roots satisfy r1r2 = c/a.\n\nSmearing can occur in even more subtle ways. Suppose a library na\u00efvely com-\nputes ex by the formula 1 + x + x2/2 + x3/3! + \u2026. This works fine for positive x, but \nconsider what happens when x is a large negative number. The even-powered \nterms result in large positive numbers, and subtracting the odd-powered mag-\nnitudes will not even affect the result. The problem here is that the roundoff in \nthe large, positive terms is in a digit position of much greater significance than \nthe true answer. The answer diverges toward positive infinity! The solution \nhere is also simple: for negative x, compute ex = 1/e|x|.\n\nIt should go without saying that you shouldn\u2019t use floating-point numbers for \nfinancial applications\u2014that\u2019s what decimal classes in languages like Python \nand C# are for. Floating-point numbers are intended for efficient scientific \ncomputation. But efficiency is worthless without accuracy, so remember the \nsource of rounding errors, and code accordingly!\n\n\n\n68 97 Things Every Programmer Should Know\n\nFulfill Your \nAmbitions with \nOpen Source\nRichard Monson-Haefel\n\nCHANCES ARE PRETTY GOOD that you are not developing software at work \nthat fulfills your most ambitious software development daydreams. Perhaps \nyou are developing software for a huge insurance company when you would \nrather be working at Google, Apple, Microsoft, or your own startup developing \nthe next big thing. You\u2019ll never get where you want to go developing software for \nsystems you don\u2019t care about.\n\nFortunately, there is an answer to your problem: open source. There are thou-\nsands of open source projects out there, many of them quite active, which offer \nyou any kind of software development experience you could want. If you love \nthe idea of developing operating systems, go help with one of the dozen oper-\nating system projects. If you want to work on music software, animation soft-\nware, cryptography, robotics, PC games, massive online player games, mobile \nphones, or whatever, you\u2019ll almost certainly find at least one open source proj-\nect dedicated to that interest.\n\nOf course, there is no free lunch. You have to be willing to give up your free \ntime because you probably cannot work on an open source video game at your \nday job\u2014you still have a responsibility to your employer. In addition, very few \npeople make money contributing to open source projects\u2014some do, but most \ndon\u2019t. You should be willing to give up some of your free time (less time play-\ning video games and watching TV won\u2019t kill you). The harder you work on an \nopen source project, the faster you\u2019ll realize your true ambitions as a program-\nmer. It\u2019s also important to consider your employee contract\u2014some employers \nmay restrict what you can contribute, even on your own time. In addition, you \nneed to be careful about violating intellectual property laws having to do with \ncopyright, patents, trademarks, and trade secrets.\n\n[image: image36.jpg]  \n\n\n\n69Collective Wisdom from the Experts\n\nOpen source provides enormous opportunities for the motivated program-\nmer. First, you get to see how someone else would implement a solution that \ninterests you\u2014you can learn a lot by reading other people\u2019s source code. Sec-\nond, you get to contribute your own code and ideas to the project\u2014not every \nbrilliant idea you have will be accepted, but some might, and you\u2019ll learn \nsomething new just by working on solutions and contributing code. Third, \nyou\u2019ll meet great people with the same passion for the type of software that you \nhave\u2014these open source friendships can last a lifetime. Fourth, assuming you \nare a competent contributor, you\u2019ll be able to add real-world experience in the \ntechnology that actually interests you.\n\nGetting started with open source is pretty easy. There is a wealth of documen-\ntation out there on the tools you\u2019ll need (source code management, editors, \nprogramming languages, build systems, etc.). Find the project you want to \nwork on first and learn about the tools that project uses. The documentation \non projects themselves will be light in most cases, but this perhaps matters less \nbecause the best way to learn is to investigate the code yourself. If you want \nto get involved, you could offer to help out with the documentation. Or you \ncould start by volunteering to write test code. While that may not sound excit-\ning, the truth is you learn much faster by writing test code for other people\u2019s \nsoftware than almost any other activity in software. Write test code, really \ngood test code. Find bugs, suggest fixes, make friends, work on software you \nlike, and fulfill your software development ambitions.\n\n\n\n70 97 Things Every Programmer Should Know\n\nThe Golden Rule \nof API Design\nMichael Feathers\n\nAPi DESiGN iS TOUGH, PARTiCULARLY iN THE LARGE. If you are designing \nan API that is going to have hundreds or thousands of users, you have to think \nabout how you might change it in the future and whether your changes might \nbreak client code. Beyond that, you have to think about how users of your API \naffect you. If one of your API classes uses one of its own methods internally, \nyou have to remember that a user could subclass your class and override it, and \nthat could be disastrous. You wouldn\u2019t be able to change that method because \nsome of your users have given it a different meaning. Your future internal \nimplementation choices are at the mercy of your users.\n\nAPI developers solve this problem in various ways, but the easiest way is to \nlock down the API. If you are working in Java, you might be tempted to make \nmost of your classes and methods final. In C#, you might make your classes \nand methods sealed. Regardless of the language you are using, you might be \ntempted to present your API through a singleton or use static factory meth-\nods to guard it from people who might override behavior and use your code \nin ways that may constrain your choices later. This all seems reasonable, but \nis it really?\n\nOver the past decade, we\u2019ve gradually realized that unit testing is an extremely \nimportant part of practice, but that lesson has not completely permeated the \nindustry. The evidence is all around us. Take an arbitrary untested class that \n\n[image: image37.jpg]  \n\n\n\n71Collective Wisdom from the Experts\n\nuses a third-party API and try to write unit tests for it. Most of the time, you\u2019ll \nrun into trouble. You\u2019ll find that the code using the API is stuck to it like glue. \nThere\u2019s no way to impersonate the API classes so that you can sense your code\u2019s \ninteractions with them, or supply return values for testing.\n\nOver time, this will get better, but only if we start to see testing as a real use \ncase when we design APIs. Unfortunately, it\u2019s a little bit more involved than \njust testing our code. That\u2019s where the Golden Rule of API Design fits in: It\u2019s \nnot enough to write tests for an API you develop; you have to write unit tests for \ncode that uses your API. When you follow this rule, you learn firsthand the \nhurdles that your users will have to overcome when they try to test their code \nindependently.\n\nThere is no one way to make it easy for developers to test code that uses your \nAPI. static, final, and sealed are not inherently bad constructs. They can be \nuseful at times. But it is important to be aware of the testing issue and, to do \nthat, you have to experience it yourself. Once you have, you can approach it as \nyou would any other design challenge.\n\n\n\n72 97 Things Every Programmer Should Know\n\nThe Guru Myth\nRyan Brush\n\nANYONE WHO HAS WORKED iN SOFTWARE LONG ENOUGH has heard \nquestions like this:\n\nI\u2019m getting exception XYZ. Do you know what the problem is? \n\nThose asking the question rarely bother to include stack traces, error logs, or \nany context leading to the problem. They seem to think you operate on a dif-\nferent plane, that solutions appear to you without analysis based on evidence. \nThey think you are a guru.\n\nWe expect such questions from those unfamiliar with software; to them, sys-\ntems can seem almost magical. What worries me is seeing this in the software \ncommunity. Similar questions arise in program design, such as \u201cI\u2019m building \ninventory management. Should I use optimistic locking?\u201d Ironically, people \nasking the question are often better equipped to answer it than the question\u2019s \nrecipient. The questioners presumably know the context, know the require-\nments, and can read about the advantages and disadvantages of different strat-\negies. Yet they expect you to give an intelligent answer without context. They \nexpect magic.\n\nIt\u2019s time for the software industry to dispel this guru myth. \u201cGurus\u201d are human. \nThey apply logic and systematically analyze problems like the rest of us. They \ntap into mental shortcuts and intuition. Consider the best programmer you\u2019ve \never met: at one point, that person knew less about software than you do now. \nIf someone seems like a guru, it\u2019s because of years dedicated to learning and \nrefining thought processes. A \u201cguru\u201d is simply a smart person with relentless \ncuriosity.\n\n[image: image14.jpg]\n\n73Collective Wisdom from the Experts\n\nOf course, there remains a huge variance in natural aptitude. Many hack-\ners out there are smarter, more knowledgeable, and more productive than I \nmay ever be. Even so, debunking the guru myth has a positive impact. For \ninstance, when working with someone smarter than me, I am sure to do the \nlegwork, to provide enough context so that person can efficiently apply his or \nher skills. Removing the guru myth also means removing a perceived barrier \nto improvement. Instead of a magical barrier, I see a continuum along which \nI can advance.\n\nFinally, one of software\u2019s biggest obstacles is smart people who purposefully \npropagate the guru myth. This might be done out of ego, or as a strategy to \nincrease one\u2019s value as perceived by a client or employer. Ironically, this atti-\ntude can make smart people less valuable, since they don\u2019t contribute to the \ngrowth of their peers. We don\u2019t need gurus. We need experts willing to develop \nother experts in their field. There is room for all of us.\n\n\n\n74 97 Things Every Programmer Should Know\n\nHard Work Does \nNot Pay Off\nOlve Maudal\n\nAS A PROGRAMMER, YOU\u2019LL FiND THAT working hard often does not pay off. \nYou might fool yourself and a few colleagues into believing that you are con-\ntributing a lot to a project by spending long hours at the office. But the truth is \nthat by working less, you might achieve more\u2014sometimes much more. If you \nare trying to be focused and \u201cproductive\u201d for more than 30 hours a week, you \nare probably working too hard. You should consider reducing your workload \nto become more effective and get more done.\n\nThis statement may seem counterintuitive and even controversial, but it is a \ndirect consequence of the fact that programming and software development \nas a whole involve a continuous learning process. As you work on a project, \nyou will understand more of the problem domain and, hopefully, find more \neffective ways of reaching the goal. To avoid wasted work, you must allow time \nto observe the effects of what you are doing, reflect on the things that you see, \nand change your behavior accordingly.\n\nProfessional programming is usually not like running hard for a few kilome-\nters, where the goal can be seen at the end of a paved road. Most software \nprojects are more like a long orienteering marathon. In the dark. With only a \nsketchy map as guidance. If you just set off in one direction, running as fast as \nyou can, you might impress some, but you are not likely to succeed. You need \nto keep a sustainable pace, and you need to adjust the course when you learn \nmore about where you are and where you are heading.\n\n[image: image38.jpg]  \n\n\n\n75Collective Wisdom from the Experts\n\nIn addition, you always need to learn more about software development in \ngeneral and programming techniques in particular. You probably need to read \nbooks, go to conferences, communicate with other professionals, experiment \nwith new implementation techniques, and learn about powerful tools that sim-\nplify your job. As a professional programmer, you must keep yourself updated \nin your field of expertise\u2014just as brain surgeons and pilots are expected to \nkeep themselves up to date in their own fields of expertise. You need to spend \nevenings, weekends, and holidays educating yourself; therefore, you cannot \nspend your evenings, weekends, and holidays working overtime on your cur-\nrent project. Do you really expect brain surgeons to perform surgery 60 hours \na week, or pilots to fly 60 hours a week? Of course not: preparation and educa-\ntion are an essential part of their profession.\n\nBe focused on the project, contribute as much as you can by finding smart \nsolutions, improve your skills, reflect on what you are doing, and adapt your \nbehavior. Avoid embarrassing yourself, and our profession, by behaving like \na hamster in a cage spinning the wheel. As a professional programmer, you \nshould know that trying to be focused and \u201cproductive\u201d 60 hours a week is not \na sensible thing to do. Act like a professional: prepare, effect, observe, reflect, \nand change.\n\n\n\n76 97 Things Every Programmer Should Know\n\nHow to Use a \nBug Tracker\nMatt Doar\n\nWHETHER YOU CALL THEM bugs,  defects, or even design side effects, there is \nno getting away from them. Knowing how to submit a good bug report, as well \nas what to look for in one, are key skills for keeping a project moving along \nnicely.\n\nA good bug report needs to convey three things:\n\n\u2022 How to reproduce the bug, as precisely as possible, and how often this \nwill make the bug appear\n\n\u2022 What should have happened, at least in your opinion\n\n\u2022 What actually happened, or at least as much information as you have \nrecorded\n\nThe amount and quality of information reported in a bug says as much about \nthe reporter as it does about the bug. Angry, terse bugs (\u201cThis function sucks!\u201d) \ntell the developers that you were having a bad time, but not much else. A bug \nwith plenty of context to make it easier to reproduce earns the respect of every-\none, even if it stops a release.\n\nBugs are like a conversation, with all the history right there in front of every-\none. Don\u2019t blame others or deny the bug\u2019s very existence. Instead, ask for more \ninformation or consider what you could have missed.\n\n[image: image39.jpg]  \n\n\n\n77Collective Wisdom from the Experts\n\nChanging the status of a bug\u2014e.g., Open to Closed\u2014is a public statement of \nwhat you think of the bug. Taking the time to explain why you think the bug \nshould be closed will save tedious hours spent later on justifying it to frus-\ntrated managers and customers. Changing the priority of a bug is a similar \npublic statement, and just because it\u2019s trivial to you doesn\u2019t mean it isn\u2019t stop-\nping someone else from using the product.\n\nDon\u2019t overload a bug\u2019s fields for your own purposes. Adding \u201cVITAL:\u201d to the \nsubject field may make it easier for you to sort the results of some report, but it \nwill eventually be copied by others and inevitably mistyped, or will need to be \nremoved for use in some other report. Use a new value or a new field instead, \nand document how the field is supposed to be used so other people don\u2019t have \nto repeat themselves.\n\nMake sure that everyone knows how to find the bugs that the team is supposed \nto be working on. This can usually be done using a public query with an obvi-\nous name. Make sure everyone is using the same query, and don\u2019t update this \nquery without first informing the team that you\u2019re changing what everyone is \nworking on.\n\nFinally, remember that a bug is not a standard unit of work any more than a \nline of code is a precise measurement of effort.\n\n\n\n78 97 Things Every Programmer Should Know\n\nImprove Code \nby Removing It\nPete Goodliffe\n\nLess is more. It\u2019s a quite trite little maxim, but sometimes it really is true.\n\nOne of the improvements I\u2019ve made to our codebase over the last few weeks is \nto remove chunks of it.\n\nWe\u2019d written the software following XP tenets, including YAGNI (that is, You \nAren\u2019t Gonna Need It). Human nature being what it is, we inevitably fell short \nin a few places.\n\nI observed that the product was taking too long to execute certain tasks\u2014\nsimple tasks that should have been near instantaneous. This was because they \nwere overimplemented\u2014festooned with extra bells and whistles that were not \nrequired, but at the time had seemed like a good idea.\n\nSo I\u2019ve simplified the code, improved the product performance, and reduced \nthe level of global code entropy simply by removing the offending features \nfrom the codebase. Helpfully, my unit tests tell me that I haven\u2019t broken any-\nthing else during the operation.\n\nA simple and thoroughly satisfying experience.\n\nSo why did the unnecessary code end up there in the first place? Why did one \nprogrammer feel the need to write extra code, and how did it get past review \nor the pairing process? Almost certainly something like:\n\n[image: image28.jpg]\n\n79Collective Wisdom from the Experts\n\n\u2022 It was a fun bit of extra stuff, and the programmer wanted to write it. \n(Hint: Write code because it adds value, not because it amuses you.)\n\n\u2022 Someone thought that it might be needed in the future, so felt it was best \nto code it now. (Hint: That isn\u2019t YAGNI. If you don\u2019t need it right now, don\u2019t \nwrite it right now.)\n\n\u2022 It didn\u2019t appear to be that big an \u201cextra,\u201d so it was easier to implement it \nrather than go back to the customer to see whether it was really required. \n(Hint: It always takes longer to write and to maintain extra code. And the \ncustomer is actually quite approachable. A small, extra bit of code snow-\nballs over time into a large piece of work that needs maintenance.)\n\n\u2022 The programmer invented extra requirements that were neither docu-\nmented nor discussed in order to justify the extra feature. The requirement \nwas actually bogus. (Hint: Programmers do not set system requirements; the \ncustomer does.) \n\nWhat are you working on right now? Is it all needed?\n\n\n\n80 97 Things Every Programmer Should Know\n\nInstall Me\nMarcus Baker\n\ni AM NOT THE SLiGHTEST BiT iNTERESTED iN YOUR PROGRAM.\n\nI am surrounded by problems and have a to-do list as long as my arm. The \nonly reason I am at your website right now is because I have heard an unlikely \nrumor that every one of my problems will be eliminated by your software. \nYou\u2019ll forgive me if I\u2019m skeptical.\n\nIf eyeball-tracking studies are correct, I\u2019ve already read the title and I\u2019m scan-\nning for blue underlined text marked Download now. As an aside, if I arrived \nat this page with a Linux browser from a UK IP, chances are I would like the \nLinux version from a European mirror, so please don\u2019t ask. Assuming the file \ndialog opens straight away, I consign the thing to my download folder and \ncarry on reading.\n\nWe all constantly perform cost-benefit analysis of everything we do. If your \nproject drops below my threshold for even a second, I will ditch it and go on to \nsomething else. Instant gratification is best.\n\nThe first hurdle is install. Don\u2019t think that\u2019s much of a problem? Go to your \ndownload folder now and have a look around. Full of .tar and .zip files, right? \nWhat percentage of those have you unpacked? How many have you installed? \nIf you are like me, only a third are doing more than acting as hard drive filler.\n\nI may want doorstep convenience, but I don\u2019t want you entering my house \nuninvited. Before typing install, I would like to know exactly where you are \nputting stuff. It\u2019s my computer, and I like to keep it tidy when I can. I also want \nto be able to remove your program the instant I am disenchanted with it. If \nI suspect that\u2019s impossible, I won\u2019t install it in the first place. My machine is \nstable right now, and I want to keep it that way.\n\n[image: image40.jpg]  \n\n\n\n81Collective Wisdom from the Experts\n\nIf your program is GUI based, then I want to do something simple and see \na result. Wizards don\u2019t help, because they do stuff that I don\u2019t understand. \nChances are, I want to read a file or write one. I don\u2019t want to create projects, \nimport directories, or tell you my email address. If all is working, on to the \ntutorial.\n\nIf your software is a library, then I carry on reading your web page looking for \na quick start guide. I want the equivalent of \u201cHello world\u201d in a five-line no-\nbrainer with exactly the output described by your website. No big XML files \nor templates to fill out, just a single script. Remember, I have also downloaded \nyour rival\u2019s framework. You know, the one who always claims to be so much \nbetter than yours in the forums? If all is working, on to the tutorial.\n\nThere is a tutorial, isn\u2019t there? One that talks to me in language I can understand?\n\nAnd if the tutorial mentions my problem, I\u2019ll cheer up. Now that I\u2019m reading \nabout the things I can do, it starts to get interesting, fun even. I\u2019ll lean back \nand sip my tea\u2014did I mention I was from the UK?\u2014and I\u2019ll play with your \nexamples and learn to use your creation. If it solves my problem, I\u2019ll send you \na thank-you email. I\u2019ll send you bug reports when it crashes, and suggestions \nfor features, too. I\u2019ll even tell all my friends how your software is the best, even \nthough I never did try your rival\u2019s. And all because you took such care over my \nfirst tentative steps.\n\nHow could I ever have doubted you?\n\n\n\n82 97 Things Every Programmer Should Know\n\nInterprocess Communication \nAffects Application \nResponse Time\nRandy Stafford\n\nRESPONSE TiME iS CRiTiCAL TO SOFTWARE USABiLiTY. Few things are as \nfrustrating as waiting for some software system to respond, especially when \nour interaction with the software involves repeated cycles of stimulus and \nresponse. We feel as if the software is wasting our time and affecting our pro-\nductivity. However, the causes of poor response time are less well appreciated, \nespecially in modern applications. Much performance management literature \nstill focuses on data structures and algorithms, issues that can make a differ-\nence in some cases but are far less likely to dominate performance in modern \nmultitier enterprise applications.\n\nWhen performance is a problem in such applications, my experience has been \nthat examining data structures and algorithms isn\u2019t the right place to look for \nimprovements. Response time depends most strongly on the number of remote \ninterprocess communications (IPCs) conducted in response to a stimulus. \nWhile there can be other local bottlenecks, the number of remote interprocess \ncommunications usually dominates. Each remote interprocess communication \ncontributes some nonnegligible latency to the overall response time, and these \nindividual contributions add up, especially when they are incurred in sequence.\n\nA prime example is ripple loading in an application using object-relational \nmapping. Ripple loading describes the sequential execution of many database \ncalls to select the data needed for building a graph of objects (see Lazy Load* \nin Martin Fowler\u2019s Patterns of Enterprise Application Architecture [Addison-\nWesley Professional]). When the database client is a middle-tier application \nserver rendering a web page, these database calls are usually executed sequen-\ntially in a single thread. Their individual latencies accumulate, contributing to \nthe overall response time. Even if each database call takes only 10 milliseconds, \n\n* http://martinfowler.com/eaaCatalog/lazyLoad.html\n\n[image: image41.jpg]  \n\nhttp://martinfowler.com/eaaCatalog/lazyLoad.html\n\n\n83Collective Wisdom from the Experts\n\na page requiring 1,000 calls (which is not uncommon) will exhibit at least a \n10-second response time. Other examples include web-service invocation, \nHTTP requests from a web browser, distributed object invocation, request\u2013\nreply messaging, and data-grid interaction over custom network protocols. \nThe more remote IPCs needed to respond to a stimulus, the greater the \nresponse time will be.\n\nThere are a few relatively obvious and well-known strategies for reducing \nthe number of remote interprocess communications per stimulus. One strat-\negy is to apply the principle of parsimony, optimizing the interface between \nprocesses so that exactly the right data for the purpose at hand is exchanged \nwith the minimum amount of interaction. Another strategy is to parallelize \nthe interprocess communications where possible, so that the overall response \ntime becomes driven mainly by the longest-latency IPC. A third strategy is to \ncache the results of previous IPCs, so that future IPCs may be avoided by hit-\nting local cache instead.\n\nWhen you\u2019re designing an application, be mindful of the number of interprocess \ncommunications in response to each stimulus. When analyzing applications \nthat suffer from poor performance, I have often found IPC-to-stimulus ratios \nof thousands-to-one. Reducing this ratio, whether by caching or parallelizing \nor some other technique, will pay off much more than changing data structure \nchoice or tweaking a sorting algorithm.\n\n\n\n84 97 Things Every Programmer Should Know\n\nKeep the Build \nClean\nJohannes Brodwall\n\nHAVE YOU EVER LOOKED AT a list of compiler warnings the length of an \nessay on bad coding and thought to yourself, \u201cYou know, I really should do \nsomething about that\u2026but I don\u2019t have time just now\u201d? On the other hand, \nhave you ever looked at a lone warning that appeared in a compilation and \njust fixed it?\n\nWhen I start a new project from scratch, there are no warnings, no clutter, no \nproblems. But as the codebase grows, if I don\u2019t pay attention, the clutter, the \ncruft, the warnings, and the problems can start piling up. When there\u2019s a lot of \nnoise, it\u2019s much harder to find the warning that I really want to read among the \nhundreds of warnings I don\u2019t care about.\n\nTo make warnings useful again, I try to use a zero-tolerance policy for warn-\nings from the build. Even if the warning isn\u2019t important, I deal with it. If it\u2019s \nnot critical but still relevant, I fix it. If the compiler warns about a potential \nnull-pointer exception, I fix the cause\u2014even if I \u201cknow\u201d the problem will \nnever show up in production. If the embedded documentation (Javadoc or \nsimilar) refers to parameters that have been removed or renamed, I clean up \nthe documentation.\n\nIf it\u2019s something I really don\u2019t care about and that really doesn\u2019t matter, I ask the \nteam if we can change our warning policy. For example, I find that documenting \n\n[image: image42.jpg]  \n\n\n\n85Collective Wisdom from the Experts\n\nthe parameters and return value of a method in many cases doesn\u2019t add any \nvalue, so it shouldn\u2019t be a warning if they are missing. Or, upgrading to a new \nversion of the programming language may make code that was previously OK \nnow emit warnings. For example, when Java 5 introduced generics, all the old \ncode that didn\u2019t specify the generic type parameter would give a warning. This \nis a sort of warning I don\u2019t want to be nagged about (at least, not yet). Having a \nset of warnings that are out of step with reality does not serve anyone.\n\nBy making sure that the build is always clean, I will not have to decide that a \nwarning is irrelevant every time I encounter it. Ignoring things is mental work, \nand I need to get rid of all the unnecessary mental work I can. Having a clean \nbuild also makes it easier for someone else to take over my work. If I leave the \nwarnings, someone else will have to wade through what is relevant and what \nis not. Or more likely, that person will just ignore all the warnings, including \nthe significant ones.\n\nWarnings from your build are useful. You just need to get rid of the noise to \nstart noticing them. Don\u2019t wait for a big cleanup. When something appears that \nyou don\u2019t want to see, deal with it right away. You should fix the source of the \nwarning, suppress the warning, or fix the warning policies of your tool. Keep-\ning the build clean is not just about keeping it free of compilation errors or \ntest failures: warnings are also an important and critical part of code hygiene.\n\n\n\n86 97 Things Every Programmer Should Know\n\nKnow How to Use \nCommand-Line Tools\nCarroll Robinson\n\nTODAY, MANY SOFTWARE DEVELOPMENT TOOLS are packaged in the form \nof integrated development environments (IDEs). Microsoft\u2019s Visual Studio and \nthe open source Eclipse are two popular examples, though there are many oth-\ners. There is a lot to like about IDEs. Not only are they easy to use, but they \nalso relieve the programmer of thinking about a lot of little details involving \nthe build process.\n\nEase of use, however, has its downside. Typically, when a tool is easy to use, \nit\u2019s because the tool is making decisions for you and doing a lot of things auto-\nmatically, behind the scenes. Thus, if an IDE is the only programming envi-\nronment that you ever use, you may never fully understand what your tools are \nactually doing. You click a button, some magic occurs, and an executable file \nappears in the project folder.\n\nBy working with command-line build tools, you will learn a lot more about \nwhat the tools are doing when your project is being built. Writing your own \nmake files will help you to understand all of the steps (compiling, assembling, \nlinking, etc.) that go into building an executable file. Experimenting with the \nmany command-line options for these tools is a valuable educational expe-\nrience as well. To get started with using command-line build tools, you can \nuse open source command-line tools such as GCC, or you can use the ones \nsupplied with your proprietary IDE. After all, a well-designed IDE is just a \ngraphical frontend to a set of command-line tools.\n\n[image: image43.jpg]  \n\n\n\n87Collective Wisdom from the Experts\n\nIn addition to improving your understanding of the build process, there are some \ntasks that can be performed more easily or more efficiently with command-line \ntools than with an IDE. For example, the search and replace capabilities pro-\nvided by the grep and sed utilities are often more powerful than those found \nin IDEs. Command-line tools inherently support scripting, which allows for \nthe automation of tasks such as producing scheduled daily builds, creating \nmultiple versions of a project, and running test suites. In an IDE, this kind of \nautomation may be more difficult (if not impossible) to do, as build options \nare usually specified using GUI dialog boxes and the build process is invoked \nwith a mouse click. If you never step outside of the IDE, you may not even \nrealize that these kinds of automated tasks are possible.\n\nBut wait. Doesn\u2019t the IDE exist to make development easier and to improve \nthe programmer\u2019s productivity? Well, yes. The suggestion presented here is \nnot that you should stop using IDEs. The suggestion is that you should \u201clook \nunder the hood\u201d and understand what your IDE is doing for you. The best way \nto do that is to learn to use command-line tools. Then, when you go back to \nusing your IDE, you\u2019ll have a much better understanding of what it is doing for \nyou and how you can control the build process. On the other hand, once you \nmaster the use of command-line tools and experience the power and flexibility \nthat they offer, you may find that you prefer the command line over the IDE.\n\n\n\n88 97 Things Every Programmer Should Know\n\nKnow Well More Than \nTwo Programming \nLanguages\nRussel Winder\n\nTHE PSYCHOLOGY OF PROGRAMMiNG: people have known for a long time \nnow that programming expertise is related directly to the number of different \nprogramming paradigms that a programmer is comfortable with\u2014that is, not \nthat he just knows about or knows a bit of, but that he can genuinely program \nwith.\n\nEvery programmer starts with one programming language. That language \nhas a dominating effect on the way that programmer thinks about software. \nNo matter how many years of experience the programmer gets using that \nlanguage, if she stays with that language, she will know only that language. \nA one-language programmer is constrained in her thinking by that language.\n\nA programmer who learns a second language will be challenged, especially if that \nlanguage has a different computational model than the first. C, Pascal, Fortran\u2014\nall have the same fundamental computational model. Switching from Fortran \nto C introduces a few, but not many, challenges. Moving from C or Fortran to \nC++ or Ada introduces fundamental challenges in the way programs behave. \nMoving from C++ to Haskell is a significant change and hence a significant \nchallenge. Moving from C to Prolog is a very definite challenge.\n\nWe can enumerate a number of paradigms of computation: procedural, object-\noriented, functional, logic, dataflow, etc. Moving among these paradigms creates \nthe greatest challenges.\n\nWhy are these challenges good? That has to do with the way we think about \nthe implementation of algorithms and the idioms and patterns of implemen-\ntation that apply. In particular, cross-fertilization is at the core of expertise. \nIdioms for problem solutions that apply in one language may not be possible \nin another language. Trying to port the idioms from one language to another \nteaches us about both languages and about the problem being solved.\n\n[image: image44.jpg]  \n\n\n\n89Collective Wisdom from the Experts\n\nCross-fertilization in the use of programming languages has huge effects. Per-\nhaps the most obvious is the increased and increasing use of declarative modes \nof expression in systems implemented in imperative languages. Anyone versed \nin functional programming can easily apply a declarative approach even when \nusing a language such as C. Using declarative approaches generally leads to \nshorter and more comprehensible programs. C++, for instance, certainly takes \nthis on board with its wholehearted support for generic programming, which \nalmost necessitates a declarative mode of expression.\n\nThe consequence of all this is that it behooves every programmer to be well \nskilled in programming in at least two different paradigms, and ideally at least \nthe aforementioned five. Programmers should always be interested in learning \nnew languages, preferably from an unfamiliar paradigm. Even if their day job \nalways uses the same programming language, the increased sophistication of \nuse of that language when a person can cross-fertilize from other paradigms \nshould not be underestimated. Employers should take this into account and \nallow room in their training budget for employees to learn languages that \nare not currently being used, as a way of increasing the sophistication of the \nlanguages that are being used.\n\nAlthough it\u2019s a start, a one-week training course is not sufficient to learn a new \nlanguage: it generally takes a good few months of use, even if part-time, to gain \na proper working knowledge of a language. It is the idioms of use, not just the \nsyntax and computational model, that are the important factors.\n\n\n\n90 97 Things Every Programmer Should Know\n\nKnow Your IDE\nHeinz Kabutz\n\niN THE 1980S, our programming environments were typically nothing bet-\nter than glorified text editors\u2026if we were lucky. Syntax highlighting, which \nwe take for granted nowadays, was a luxury that certainly was not available \nto everyone. Pretty printers to format our code nicely were usually external \ntools that had to be run to correct our spacing. Debuggers were also separate \nprograms run to step through our code, but with a lot of cryptic keystrokes.\n\nDuring the 1990s, companies began to recognize the potential income that \nthey could derive from equipping programmers with better and more useful \ntools. The Integrated Development Environment (IDE) combined the previ-\nous editing features with a compiler, debugger, pretty printer, and other tools. \nDuring that time, menus and the mouse also became popular, which meant \nthat developers no longer needed to learn cryptic key combinations to use \ntheir editors. They could simply select their command from the menu.\n\nIn the 21st century, IDEs have become so commonplace that they are given \naway for free by companies wishing to gain market share in other areas. The \nmodern IDE is equipped with an amazing array of features. My favorite is \nautomated refactoring, particularly Extract Method, where I can select and \nconvert a chunk of code into a method. The refactoring tool will pick up all the \nparameters that need to be passed into the method, which makes it extremely \neasy to modify code. My IDE will even detect other chunks of code that could \nalso be replaced by this method and ask me whether I would like to replace \nthem, too.\n\nAnother amazing feature of modern IDEs is the ability to enforce style rules \nwithin a company. For example, in Java, some programmers have started \nmaking all parameters final (which, in my opinion, is a waste of time). \n\n[image: image45.jpg]  \n\n\n\n91Collective Wisdom from the Experts\n\nHowever, since they have such a style rule, all I would need to do to follow \nit is set it up in my IDE: I would get a warning for any non-final parameter. \nStyle rules can also be used to find probable bugs, such as comparing auto-\nboxed objects for reference equality, e.g., using == on primitive values that are \nautoboxed into reference objects.\n\nUnfortunately, modern IDEs do not require us to invest effort to learn how \nto use them. When I first programmed C on Unix, I had to spend quite a bit of \ntime learning how the vi editor worked, due to its steep learning curve. This time \nspent up front paid off handsomely over the years. I am even typing the draft of \nthis article with vi. Modern IDEs have a very gradual learning curve, which can \nhave the effect that we never progress beyond the most basic usage of the tool.\n\nMy first step in learning an IDE is to memorize the keyboard shortcuts. Since \nmy fingers are on the keyboard when I\u2019m typing my code, pressing Ctrl+Shift+I \nto inline a variable prevents breaking the flow, whereas switching to navigate \na menu with my mouse interrupts it. These interruptions lead to unnecessary \ncontext switches, making me much less productive if I try to do everything the \nlazy way. The same rule also applies to keyboard skills: learn to touch type; you \nwon\u2019t regret the time invested up front.\n\nLastly, as programmers we have time-proven Unix streaming tools that can \nhelp us manipulate our code. For example, if during a code review, I noticed \nthat the programmers had named lots of classes the same, I could find these \nvery easily using the tools find, sed, sort, uniq, and grep, like this:\n\nfind . -name \"*.java\" | sed 's/.*\\///' | sort | uniq -c | grep -v \"^ *1 \" | sort -r\n\nWe expect a plumber coming to our house to be able to use his blowtorch. Let\u2019s \nspend a bit of time to study how to become more effective with our IDE.\n\n\n\n92 97 Things Every Programmer Should Know\n\nKnow Your Limits\nGreg Colvin\n\nMan\u2019s got to know his limitations.\n\u2014Dirty Harry\n\nYOUR RESOURCES ARE LiMiTED. You only have so much time and money to \ndo your work, including the time and money needed to keep your knowledge, \nskills, and tools up to date. You can only work so hard, so fast, so smart, and so \nlong. Your tools are only so powerful. Your target machines are only so power-\nful. So you have to respect the limits of your resources.\n\nHow to respect those limits? Know yourself, know your people, know your \nbudgets, and know your stuff. Especially, as a software engineer, know the \nspace and time complexity of your data structures and algorithms, and the \narchitecture and performance characteristics of your systems. Your job is to \ncreate an optimal marriage of software and systems.\n\nSpace and time complexity are given as the function O(f(n)), which for n \nequal the size of the input is the asymptotic space or time required as n grows \nto infinity. Important complexity classes \nfor f(n) include ln(n), n, n ln(n), ne, and \nen. As graphing these functions clearly \nshows, as n gets bigger, O(ln(n)) is ever so \nmuch smaller than O(n) and O(n ln(n)), \nwhich are ever so much smaller than \nO(ne) and O(en). As Sean Parent puts it, \nfor achievable n, all complexity classes \namount to near-constant, near-linear, or \nnear-infinite.\n\n[image: image46.jpg]  \n\n[image: image47.jpg] e'n\u00ba nin(n) /n In(n) \n\n\n\n93Collective Wisdom from the Experts\n\nComplexity analysis is measured in \nterms of an abstract machine, but \nsoftware runs on real machines. \nModern computer systems are orga-\nnized as hierarchies of physical and \nvirtual machines, including language \nruntimes, operating systems, CPUs, \ncache memory, random-access mem-\nory, disk drives, and networks. This \ntable shows the limits on random \naccess time and storage capacity for a \ntypical networked server.\n\nNote that capacity and speed vary by several orders of magnitude. Caching \nand lookahead are used heavily at every level of our systems to hide this varia-\ntion, but they only work when access is predictable. When cache misses are \nfrequent, the system will be thrashing. For example, to randomly inspect every \nbyte on a hard drive could take 32 years. Even to randomly inspect every byte \nin RAM could take 11 minutes. Random access is not predictable. What is? \nThat depends on the system, but reaccessing recently used items and accessing \nitems sequentially are usually a win.\n\nAlgorithms and data structures vary in how effectively they use caches. For \ninstance:\n\n\u2022 Linear search makes good use of lookahead, but requires O(n) comparisons.\n\n\u2022 Binary search of a sorted array requires only O(log(n))  comparisons.\n\n\u2022 Search of a van Emde Boas tree is O(log(n)) and cache-oblivious.\n\nHow to choose? In the last analysis, by measuring. The table below shows the \ntime required to search arrays of 64-bit integers via these three methods. On my \ncomputer:\n\n\u2022 Linear search is competitive for \nsmall arrays, but loses exponen-\ntially for larger arrays.\n\n\u2022 van Emde Boas wins hands \ndown, thanks to its predictable \naccess pattern.\n\nSearch time (ns)\n\n8 50 90 40\n\n64 180 150 70\n\n512 1,200 230 100\n\n4,096 17,000 320 160\nLinear Binary vEB\n\n \nYou pays your money and you takes your choice.\n\n\u2014Punch\n\nAccess time  Capacity\n\nRegister < 1 ns 64 b \n\nCache line 64 B\n\n    L1 cache 1 ns 64 KB\n\n    L2 cache 4 ns 8 MB\n\nRAM 20 ns 32 GB\n\nDisk 10 ms 10 TB\n\nLAN 20 ms > 1 PB\n\nInternet 100 ms > 1 ZB\n\n\n\n94 97 Things Every Programmer Should Know\n\nKnow Your \nNext Commit\nDan Bergh Johnsson\n\ni TAPPED THREE PROGRAMMERS ON THEiR SHOULDERS and asked what \nthey were doing. \u201cI am refactoring these methods,\u201d the first answered. \u201cI am \nadding some parameters to this web action,\u201d the second answered. The third \nanswered, \u201cI am working on this user story.\u201d\n\nIt might seem that the first two were engrossed in the details of their work, \nwhile only the third could see the bigger picture, and that he had the better \nfocus. However, when I asked when and what they would commit, the picture \nchanged dramatically. The first two were pretty clear about what files would be \ninvolved, and would be finished within an hour or so. The third programmer \nanswered, \u201cOh, I guess I will be ready within a few days. I will probably add a \nfew classes and might change those services in some way.\u201d\n\nThe first two did not lack a vision of the overall goal. They had selected tasks \nthey thought led in a productive direction, and could be finished within a \ncouple of hours. Once they had finished those tasks, they would select a new \nfeature or refactoring to work on. All the code written was thus done with a \nclear purpose and a limited, achievable goal in mind.\n\nThe third programmer had not been able to decompose the problem and was \nworking on all aspects at once. He had no idea of what it would take, basi-\ncally doing speculative programming, hoping to arrive at some point where he \nwould be able to commit. Most probably, the code written at the start of this \nlong session was poorly matched for the solution that came out in the end.\n\n[image: image48.jpg]  \n\n\n\n95Collective Wisdom from the Experts\n\nWhat would the first two programmers do if their tasks took more than two \nhours? After realizing they had taken on too much, they would most likely \nthrow away their changes, define smaller tasks, and start over. To keep work-\ning would have lacked focus and led to speculative code entering the reposi-\ntory. Instead, changes would be thrown away, but the insights kept.\n\nThe third programmer might keep on guessing and desperately try to patch \ntogether his changes into something that could be committed. After all, you \ncannot throw away code changes you have done\u2014that would be wasted work, \nwouldn\u2019t it? Unfortunately, not throwing the code away leads to slightly odd \ncode that lacks a clear purpose entering the repository.\n\nAt some point, even the commit-focused programmers might fail to find \nsomething useful they thought could be finished in two hours. Then, they \nwould go directly into speculative mode, playing around with the code and, of \ncourse, throwing away the changes whenever some insight led them back on \ntrack. Even these seemingly unstructured hacking sessions have purpose: to \nlearn about the code to be able to define a task that would constitute a produc-\ntive step.\n\nKnow your next commit. If you cannot finish, throw away your changes, then \ndefine a new task you believe in with the insights you have gained. Do specula-\ntive experimentation whenever needed, but do not let yourself slip into specu-\nlative mode without noticing. Do not commit guesswork into your repository.\n\n\n\n96 97 Things Every Programmer Should Know\n\nLarge, Interconnected \nData Belongs to \na Database\nDiomidis Spinellis\n\niF YOUR APPLiCATiON is going to handle a large, persistent, interconnected \nset of data elements, don\u2019t hesitate to store it in a relational database. In the \npast, RDBMSs used to be expensive, scarce, complex, and unwieldy beasts. \nThis is no longer the case. Nowadays, RDBMS systems are easy to find\u2014it is \nlikely that the system you\u2019re using already has one or two installed. Some very \ncapable RDBMSs, like MySQL and PostgreSQL, are available as open source \nsoftware, so cost of purchase is no longer an issue. Even better, so-called \nembedded database systems can be linked as libraries directly into your appli-\ncation, requiring almost no setup or management\u2014two notable open source \nones are SQLite and HSQLDB. These systems are extremely efficient.\n\nIf your application\u2019s data is larger than the system\u2019s RAM, an indexed RDBMS \ntable will perform orders of magnitude faster than your library\u2019s map collec-\ntion type, which will thrash virtual memory pages. Modern database offer-\nings can easily grow with your needs. With proper care, you can scale up an \nembedded database to a larger database system when required. Later on, you \ncan switch from a free, open source offering to a better-supported or more \npowerful proprietary system.\n\nOnce you get the hang of SQL, writing database-centric applications is a joy. \nAfter you\u2019ve stored your properly normalized data in the database, it\u2019s easy to \nextract facts efficiently with a readable SQL query; there\u2019s no need to write \nany complex code. Similarly, a single SQL command can perform complex data \nchanges. For one-off modifications\u2014say, a change in the way you organize your \npersistent data\u2014you don\u2019t even need to write code: just fire up the database\u2019s \ndirect SQL interface. This same interface also allows you to experiment with \nqueries, sidestepping a regular programming language\u2019s compile\u2013edit cycle.\n\n[image: image49.jpg]  \n\n\n\n97Collective Wisdom from the Experts\n\nAnother advantage of basing your code around an RDBMS involves the han-\ndling of relationships between your data elements. You can describe consis-\ntency constraints on your data in a declarative way, avoiding the risk of the \ndangling pointers you get if you forget to update your data in an edge case. For \nexample, you can specify that if a user is deleted, then the messages sent by that \nuser should be removed as well.\n\nYou can also create efficient links between the entities stored in the database \nany time you want, simply by creating an index. There is no need to perform \nexpensive and extensive refactorings of class fields. In addition, coding around \na database allows multiple applications to access your data in a safe way. This \nmakes it easy to upgrade your application for concurrent use and also to code \neach part of your application using the most appropriate language and platform. \nFor instance, you could write the XML backend of a web-based application in \nJava, some auditing scripts in Ruby, and a visualization interface in Processing.*\n\nFinally, keep in mind that the RDBMS will sweat hard to optimize your SQL \ncommands, allowing you to concentrate on your application\u2019s functional-\nity rather than on algorithmic tuning. Advanced database systems will even \ntake advantage of multicore processors behind your back. And, as technology \nimproves, so will your application\u2019s performance.\n\n* http://www.processing.org/\n\nhttp://www.processing.org/\n\n\n98 97 Things Every Programmer Should Know\n\nLearn Foreign \nLanguages\nKlaus Marquardt\n\nPROGRAMMERS NEED TO COMMUNiCATE. A lot.\n\nThere are periods in a programmer\u2019s life when most communication seems to \nbe with the computer\u2014more precisely, with the programs running on that com-\nputer. This communication is about expressing ideas in a machine-readable way. \nThis remains an exhilarating prospect: programs are ideas turned into reality, \nwith virtually no physical substance involved.\n\nProgrammers need to be fluent in the language of the machine, whether real \nor virtual, and in the abstractions that can be related to that language via devel-\nopment tools. It is important to learn many different abstractions, otherwise \nsome ideas become incredibly hard to express. Good programmers need to be \nable to stand outside their daily routine, to be aware of other languages that \nare expressive for other purposes. The time always comes when this pays off.\n\nBeyond communication with machines, programmers need to communicate \nwith their peers. Today\u2019s large projects are more social endeavors than simply \nthe applied art of programming. It is important to understand and express \nmore than the machine-readable abstractions can. Most of the best program-\nmers I know are also very fluent in their mother tongue, and typically in other \nlanguages as well. This is not just about communication with others: speaking \na language well also leads to a clarity of thought that is indispensable when \nabstracting a problem. And this is what programming is also about.\n\n[image: image50.jpg]  \n\n\n\n99Collective Wisdom from the Experts\n\nBeyond communication with machine, self, and peers, a project has many \nstakeholders, most with a different or no technical background. They live in \ntesting, quality, and deployment; in marketing and sales; they are end users \nin some office (or store or home). You need to understand them and their \nconcerns. This is almost impossible if you cannot speak their language\u2014the \nlanguage of their world, their domain. While you might think a conversation \nwith them went well, they probably didn\u2019t.\n\nIf you talk to accountants, you need a basic knowledge of cost-center account-\ning, of tied capital, capital employed, et al. If you talk to marketing or lawyers, \nsome of their jargon and language (and thus, their minds) should be familiar \nto you. All these domain-specific languages need to be mastered by someone \nin the project\u2014ideally, the programmers. Programmers are ultimately respon-\nsible for bringing the ideas to life via a computer.\n\nAnd, of course, life is more than software projects. As noted by Charlemagne, \nto know another language is to have another soul. For your contacts beyond the \nsoftware industry, you will appreciate knowing foreign languages. To know \nwhen to listen rather than talk. To know that most language is without words.\n\nWhereof one cannot speak, thereof one must be silent. \n\u2014Ludwig Wittgenstein\n\nhttp://en.wikipedia.org/wiki/Charlemagne\n\n\n100 97 Things Every Programmer Should Know\n\nLearn to Estimate\nGiovanni Asproni\n\nAS A PROGRAMMER, you need to be able to provide estimates to your man-\nagers, colleagues, and users for the tasks you need to perform, so that they \nwill have a reasonably accurate idea of the time, costs, technology, and other \nresources needed to achieve their goals.\n\nTo be able to estimate well, it is obviously important to learn some estimation \ntechniques. First of all, however, it is fundamental to learn what estimates are, \nand what they should be used for\u2014as strange as it may seem, many developers \nand managers don\u2019t really know this.\n\nThe following exchange between a project manager and a programmer is not \natypical:\n\nProject Manager: Can you give me an estimate of the time necessary to \ndevelop feature xyz? \nProgrammer: One month. \nProject Manager: That\u2019s far too long! We\u2019ve only got one week. \nProgrammer: I need at least three. \nProject Manager: I can give you two at most. \nProgrammer: Deal! \n\nThe programmer, at the end, comes up with an \u201cestimate\u201d that matches what \nis acceptable for the manager. But since it is seen to be the programmer\u2019s esti-\nmate, the manager will hold the programmer accountable to it. To understand \nwhat is wrong with this conversation, we need three definitions\u2014estimate, \ntarget, and commitment:\n\n[image: image51.jpg]  \n\n\n\n101Collective Wisdom from the Experts\n\n\u2022 An estimate is an approximate calculation or judgment of the value, number, \nquantity, or extent of something. This definition implies that an estimate is \na factual measure based on hard data and previous experience\u2014hopes and \nwishes must be ignored when calculating it. The definition also implies that, \nbeing approximate, an estimate cannot be precise, e.g., a development task \ncannot be estimated to last 234.14 days.\n\n\u2022 A target is a statement of a desirable business objective, e.g., \u201cThe system \nmust support at least 400 concurrent users.\u201d\n\n\u2022 A commitment is a promise to deliver specified functionality at a certain \nlevel of quality by a certain date or event. One example could be \u201cThe \nsearch functionality will be available in the next release of the product.\u201d \n\nEstimates, targets, and commitments are independent from one another, \nbut targets and commitments should be based on sound estimates. As Steve \nMcConnell notes, \u201cThe primary purpose of software estimation is not to pre-\ndict a project\u2019s outcome; it is to determine whether a project\u2019s targets are real-\nistic enough to allow the project to be controlled to meet them.\u201d Thus, the \npurpose of estimation is to make proper project management and planning \npossible, allowing the project stakeholders to make commitments based on \nrealistic targets.\n\nWhat the manager in the preceding conversation was really asking the pro-\ngrammer was to make a commitment based on an unstated target that the \nmanager had in mind, not to provide an estimate. The next time you are asked \nto provide an estimate, make sure everybody involved knows what they are \ntalking about, and your projects will have a better chance of succeeding. Now \nit\u2019s time to learn some techniques.\u2026\n\n\n\n102 97 Things Every Programmer Should Know\n\nLearn to Say, \n\u201cHello, World\u201d\nThomas Guest\n\nPAUL LEE, username leep, more commonly known as Hoppy, had a reputa-\ntion as the local expert on programming issues. I needed help. I walked across \nto Hoppy\u2019s desk and asked whether he could take a look at some code for me.\n\n\u201cSure,\u201d said Hoppy, \u201cpull up a chair.\u201d I took care not to topple the empty cola \ncans stacked in a pyramid behind him.\n\n\u201cWhat code?\u201d\n\n\u201cIn a function in a file,\u201d I said.\n\n\u201cSo, let\u2019s take a look at this function.\u201d Hoppy moved aside a copy of K&R and \nslid his keyboard in front of me.\n\n\u201cWhere\u2019s the IDE?\u201d Apparently, Hoppy had no IDE running, just some editor \nthat I couldn\u2019t operate. He grabbed back the keyboard. A few keystrokes later, we \nhad the file open\u2014it was quite a big file\u2014and were looking at the function\u2014it \nwas quite a big function. He paged down to the conditional block I wanted to \nask about.\n\n\u201cWhat would this clause actually do if x is negative?\u201d I asked. \u201cSurely it\u2019s wrong.\u201d\n\nI\u2019d been trying all morning to find a way to force x to be negative, but the big \nfunction in the big file was part of a big project, and the cycle of recompil-\ning and then rerunning my experiments was wearing me down. Couldn\u2019t an \nexpert like Hoppy just tell me the answer?\n\n[image: image52.jpg]  \n\n\n\n103Collective Wisdom from the Experts\n\nHoppy admitted he wasn\u2019t sure. To my surprise, he didn\u2019t reach for K&R. \nInstead, he copied the code block into a new editor buffer, reindented it, \nwrapped it up in a function. A short while later, he had coded up a main func-\ntion that looped forever, prompting the user for input values, passing them to \nthe function, printing out the result. He saved the buffer as a new file, tryit.c. \nAll of this I could have done for myself, though perhaps not as quickly. But his \nnext step was wonderfully simple and, at the time, quite foreign to my way of \nworking:\n\n$ cc tryit.c && ./a.out\n\nLook! His actual program, conceived just a few minutes earlier, was now up \nand running. We tried a few values and confirmed my suspicions (so I\u2019d been \nright about something!) and then he cross-checked the relevant section of \nK&R. I thanked Hoppy and left, again taking care not to disturb his cola can \npyramid.\n\nBack at my own desk, I closed down my IDE. I\u2019d become so used to working \non a big project within a big product that I\u2019d started to think that was what I \nshould be doing. A general-purpose computer can do little tasks, too. I opened \na text editor and began typing:\n\n#include <stdio.h>\n\nint main()\n\n{\n\nprintf(\"Hello, World\\n\");\n\nreturn 0;\n\n}\n\n\n\n104 97 Things Every Programmer Should Know\n\nLet Your Project \nSpeak for Itself\nDaniel Lindner\n\nYOUR PROjECT PROBABLY HAS A VERSiON CONTROL SYSTEM iN PLACE. \n\nPerhaps it is connected to a continuous integration server that verifies correct-\nness by automated tests. That\u2019s great.\n\nYou can include tools for static code analysis in your continuous integration \nserver to gather code metrics. These metrics provide feedback about specific \naspects of your code, as well as their evolution over time. When you install \ncode metrics, there will always be a red line that you do not want to cross. Let\u2019s \nassume you started with 20% test coverage and never want to fall below 15%. \nContinuous integration helps you keep track of all these numbers, but you still \nhave to check regularly. Imagine you could delegate this task to the project \nitself and rely on it to report when things get worse.\n\nYou need to give your project a voice. This can be done by email or instant \nmessaging, informing the developers about the latest decline or improvement \nin numbers. But it\u2019s even more effective to embody the project in your office \nby using an extreme feedback device (XFD).\n\nThe idea of XFDs is to drive a physical device such as a lamp, a portable foun-\ntain, a toy robot, or even a USB rocket launcher, based on the results of the \nautomatic analysis. Whenever your limits are broken, the device alters its state. \nIn case of a lamp, it will light up, bright and obvious. You can\u2019t miss the message \neven if you\u2019re hurrying out the door to get home.\n\n[image: image53.jpg]  \n\n\n\n105Collective Wisdom from the Experts\n\nDepending on the type of extreme feedback device, you can hear the build \nbreak, see the red warning signals in your code, or even smell your code smells. \nThe devices can be replicated at different locations if you work on a distributed \nteam. You can place a traffic light in your project manager\u2019s office, indicating \noverall project health state. Your project manager will appreciate it.\n\nLet your creativity guide you in choosing an appropriate device. If your culture \nis rather geeky, you might look for ways to equip your team mascot with radio-\ncontrolled toys. If you want a more professional look, invest in sleek designer \nlamps. Search the Internet for more inspiration. Anything with a power plug \nor a remote control has the potential to be used as an extreme feedback device.\n\nThe extreme feedback device acts as the voice box of your project. The project \nnow resides physically with the developers, complaining to or praising them \naccording to the rules the team has chosen. You can drive this personification \nfurther by applying speech-synthesis software and a pair of loudspeakers. Now \nyour project really speaks for itself.\n\n\n\n106 97 Things Every Programmer Should Know\n\nThe Linker Is Not a \nMagical Program\nWalter Bright\n\nDEPRESSiNGLY OFTEN (happened to me again just before I wrote this), the \nview that many programmers have of the process of going from source code to \na statically linked executable in a compiled language is:\n\n1. Edit source code.\n2. Compile source code into object files.\n3. Something magical happens.\n4. Run executable.\n\nStep 3 is, of course, the linking step. Why would I say such an outrageous \nthing? I\u2019ve been doing tech support for decades, and I get the following con-\ncerns again and again:\n\n1. The linker says def is defined more than once.\n2. The linker says abc is an unresolved symbol.\n3. Why is my executable so large? \n\nFollowed by \u201cWhat do I do now?\u201d usually with the phrases \u201cseems to\u201d and \n\u201csomehow\u201d mixed in, and an aura of utter bafflement. It\u2019s the \u201cseems to\u201d and \n\u201csomehow\u201d that indicate that the linking process is viewed as a magical pro-\ncess, presumably understandable only by wizards and warlocks. The process of \ncompiling does not elicit these kinds of phrases, implying that programmers \ngenerally understand how compilers work, or at least what they do.\n\nA linker is a stupid, pedestrian, straightforward program. All it does is concate-\nnate together the code and data sections of the object files, connect the references \nto symbols with their definitions, pull unresolved symbols out of the library, and \nwrite out an executable. That\u2019s it. No spells! No magic! The tedium in writing a \nlinker is typically all about decoding and generating the usually ridiculously over-\ncomplicated file formats, but that doesn\u2019t change the essential nature of a linker.\n\n[image: image54.jpg]  \n\n\n\n107Collective Wisdom from the Experts\n\nSo, let\u2019s say the linker is saying def is defined more than once. Many program-\nming languages, such as C, C++, and D, have both declarations and defini-\ntions. Declarations normally go into header files, like:\n\nextern int iii;\n\nwhich generates an external reference to the symbol iii. A definition, on the \nother hand, actually sets aside storage for the symbol, usually appears in the \nimplementation file, and looks like this:\n\nint iii = 3;\n\nHow many definitions can there be for each symbol? As in the film Highlander, \nthere can be only one. So, what if a definition of iii appears in more than one \nimplementation file?\n\n// File a.c\n\nint iii = 3;\n\n// File b.c\n\ndouble iii(int x) { return 3.7; }\n\nThe linker will complain about iii being multiply defined.\n\nNot only can there be only one, there must be one. If iii appears only as a \ndeclaration, but never a definition, the linker will complain about iii being an \nunresolved symbol.\n\nTo determine why an executable is the size it is, take a look at the map file \nthat linkers optionally generate. A map file is nothing more than a list of all \nthe symbols in the executable, along with their addresses. This tells you what \nmodules were linked in from the library, and the sizes of each module. Now \nyou can see where the bloat is coming from. Often, there will be library mod-\nules that you have no idea why were linked in. To figure it out, temporarily \nremove the suspicious module from the library, and relink. The undefined \nsymbol error then generated will indicate who is referencing that module.\n\nAlthough it is not always immediately obvious why you get a particular \nlinker message, there is nothing magical about linkers. The mechanics are \nstraightforward; it\u2019s the details you have to figure out in each case.\n\n\n\n108 97 Things Every Programmer Should Know\n\nThe Longevity of \nInterim Solutions\nKlaus Marquardt\n\nWHY DO WE CREATE iNTERiM SOLUTiONS?\n\nTypically, there is some immediate problem to solve. It might be internal to the \ndevelopment team, some tooling that fills a gap in the toolchain. It might be exter-\nnal, visible to end users, such as a workaround that addresses missing functionality.\n\nIn most systems and teams, you will find some software that is somewhat segregated \nfrom the system, that is considered a draft to be changed sometime, that does not fol-\nlow the standards and guidelines that shaped the rest of the code. Inevitably, you will \nhear developers complaining about these. The reasons for their creation are many \nand varied, but the key to an interim solution\u2019s success is simple: it is useful.\n\nInterim solutions, however, acquire inertia (or momentum, depending on your \npoint of view). Because they are there, ultimately useful and widely accepted, \nthere is no immediate need to do anything else. Whenever a stakeholder has \nto decide what action adds the most value, there will be many that are ranked \nhigher than proper integration of an interim solution. Why? Because it is there, \nit works, and it is accepted. The only perceived downside is that it does not fol-\nlow the chosen standards and guidelines\u2014except for a few niche markets, this \nis not considered to be a significant force.\n\nSo the interim solution remains in place. Forever.\n\nAnd if problems arise with that interim solution, it is unlikely that there will be \nprovision for an update that brings it into line with accepted production qual-\nity. What to do? A quick interim update on that interim solution often does the \njob, and will most likely be well received. It exhibits the same strengths as the \ninitial interim solution\u2026it is just more up to date.\n\nIs this a problem?\n\nThe answer depends on your project, and on your personal stake in the produc-\ntion code standards. When the system contains too many interim solutions, its \n\n[image: image55.jpg]  \n\n\n\n109Collective Wisdom from the Experts\n\nentropy or internal complexity grows and its maintainability decreases. How-\never, this is probably the wrong question to ask first. Remember that we are talk-\ning about a solution. It may not be your preferred solution\u2014it is unlikely to be \nanyone\u2019s preferred solution\u2014but the motivation to rework this solution is weak.\n\nSo what can we do if we see a problem?\n\n1. Avoid creating an interim solution in the first place.\n\n2. Change the forces that influence the decision of the project manager.\n\n3. Leave it as is. \n\nLet\u2019s examine these options more closely:\n\n1. Avoidance is simply not an option in many cases. There is an actual prob-\nlem to solve, and the standards have turned out to be too restrictive. You \nmight spend some energy trying to change the standards\u2014an honorable, \nalbeit tedious, endeavor\u2014and that change will not be effective in time for \nyour problem at hand.\n\n2. The forces are rooted in the project culture, which resists volitional \nchange. It could be successful in very small projects\u2014especially if it\u2019s only \nyou\u2014and you just happen to clean the mess without asking in advance. \nIt could also be successful if the project is such a mess that it is visibly \nstalled, and some time for cleaning up is commonly accepted.\n\n3. The status quo automatically applies if the previous option does not. \n\nYou will create many solutions; some of them will be interim, most of them will \nbe useful. The best way to overcome interim solutions is to make them super-\nfluous, to provide a more elegant and useful solution. May you be granted the \nserenity to accept the things you cannot change, the courage to change the \nthings you can, and the wisdom to know the difference.\n\nhttp://en.wikipedia.org/wiki/Serenity_prayer\n\n\n110 97 Things Every Programmer Should Know\n\nMake Interfaces Easy to \nUse Correctly and Hard \nto Use Incorrectly\nScott Meyers\n\nONE OF THE MOST COMMON TASKS in software development is interface \nspecification. Interfaces occur at the highest level of abstraction (user inter-\nfaces), at the lowest (function interfaces), and at levels in between (class inter-\nfaces, library interfaces, etc.). Regardless of whether you work with end users \nto specify how they\u2019ll interact with a system, collaborate with developers to \nspecify an API, or declare functions private to a class, interface design is an \nimportant part of your job. If you do it well, your interfaces will be a pleasure \nto use and will boost others\u2019 productivity. If you do it poorly, your interfaces \nwill be a source of frustration and errors.\n\nGood interfaces are:\n\nEasy to use correctly\nPeople using a well-designed interface almost always use the interface cor-\nrectly, because that\u2019s the path of least resistance. In a GUI, they almost \nalways click on the right icon, button, or menu entry, because it\u2019s the obvi-\nous and easy thing to do. In an API, they almost always pass the correct \nparameters with the correct values, because that\u2019s what\u2019s most natural. \nWith interfaces that are easy to use correctly, things just work. \n\nHard to use incorrectly\nGood interfaces anticipate mistakes people might make, and make them \ndifficult\u2014ideally, impossible\u2014to commit. A GUI might disable or remove \ncommands that make no sense in the current context, for example, or an \nAPI might eliminate argument-ordering problems by allowing parameters \nto be passed in any order. \n\n[image: image56.jpg]  \n\n\n\n111Collective Wisdom from the Experts\n\nA good way to design interfaces that are easy to use correctly is to exercise \nthem before they exist. Mock up a GUI\u2014possibly on a whiteboard or using \nindex cards on a table\u2014and play with it before any underlying code has been \ncreated. Write calls to an API before the functions have been declared. Walk \nthrough common use cases and specify how you want the interface to behave. \nWhat do you want to be able to click on? What do you want to be able to pass? \nEasy-to-use interfaces seem natural, because they let you do what you want \nto do. You\u2019re more likely to come up with such interfaces if you develop them \nfrom a user\u2019s point of view. (This perspective is one of the strengths of test-first \nprogramming.)\n\nMaking interfaces hard to use incorrectly requires two things. First, you must \nanticipate errors users might make and find ways to prevent them. Second, \nyou must observe how an interface is misused during early release and modify \nthe interface\u2014yes, modify the interface!\u2014to prevent such errors. The best way \nto prevent incorrect use is to make such use impossible. If users keep wanting \nto undo an irrevocable action, try to make the action revocable. If they keep \npassing the wrong value to an API, do your best to modify the API to take the \nvalues that users want to pass.\n\nAbove all, remember that interfaces exist for the convenience of their users, \nnot their implementers.\n\n\n\n112 97 Things Every Programmer Should Know\n\nMake the Invisible \nMore Visible\nJon Jagger\n\nMANY ASPECTS OF iNViSiBiLiTY are rightly lauded as software principles to \nuphold. Our terminology is rich in invisibility metaphors\u2014mechanism trans-\nparency and information hiding, to name but two. Software and the process of \ndeveloping it can be, to paraphrase Douglas Adams, mostly invisible:\n\n\u2022 Source code has no innate presence, no innate behavior, and doesn\u2019t obey \nthe laws of physics. It\u2019s visible when you load it into an editor, but close \nthe editor and it\u2019s gone. Think about it too long and, like the tree falling \ndown with no one to hear it, you start to wonder if it exists at all. \n\n\u2022 A running application has presence and behavior, but reveals nothing of \nthe source code it was built from. Google\u2019s home page is pleasingly minimal; \nthe goings on behind it are surely substantial. \n\n\u2022 If you\u2019re 90% done and endlessly stuck trying to debug your way through \nthe last 10%, then you\u2019re not 90% done, are you? Fixing bugs is not mak-\ning progress. You aren\u2019t paid to debug. Debugging is waste. It\u2019s good to \nmake waste more visible so you can see it for what it is and start thinking \nabout trying not to create it in the first place. \n\n\u2022 If your project is apparently on track, and one week later it\u2019s six months \nlate, you have problems\u2014the biggest of which is probably not that it\u2019s six \nmonths late, but the invisibility force fields powerful enough to hide six \nmonths of lateness! Lack of visible progress is synonymous with lack of \nprogress. \n\n[image: image57.jpg]  \n\n\n\n113Collective Wisdom from the Experts\n\nInvisibility can be dangerous. You think more clearly when you have some-\nthing concrete to tie your thinking to. You manage things better when you can \nsee them and see them constantly changing:\n\n\u2022 Writing unit tests provides evidence about how easy the code unit is to \nunit test. It helps reveal the presence (or absence) of developmental quali-\nties you\u2019d like the code to exhibit, such as low coupling and high cohesion. \n\n\u2022 Running unit tests provides evidence about the code\u2019s behavior. It helps \nreveal the presence (or absence) of runtime qualities you\u2019d like the appli-\ncation to exhibit, such as robustness and correctness. \n\n\u2022 Using bulletin boards and cards makes progress visible and concrete. \nTasks can be seen as Not Started, In Progress, or Done without reference \nto a hidden project management tool and without having to chase pro-\ngrammers for fictional status reports. \n\n\u2022 Doing incremental development increases the visibility of development \nprogress (or lack of it) by increasing the frequency of development evi-\ndence. Completion of releasable software reveals reality; estimates do not. \n\nIt\u2019s best to develop software with plenty of regular visible evidence. Visibility \ngives confidence that progress is genuine and not an illusion, deliberate and \nnot unintentional, repeatable and not accidental.\n\n\n\n114 97 Things Every Programmer Should Know\n\nMessage Passing Leads \nto Better Scalability \nin Parallel Systems\nRussel Winder\n\nPROGRAMMERS ARE TAUGHT from the very outset of their study of computing \nthat concurrency\u2014and especially parallelism, a special subset of concurrency\u2014\nis hard, that only the very best can ever hope to get it right, and even they get it \nwrong. Invariably, there is great focus on threads, semaphores, monitors, and \nhow hard it is to get concurrent access to variables to be thread-safe.\n\nTrue, there are many difficult problems, and they can be very hard to solve. \nBut what is the root of the problem? Shared memory. Almost all the problems \nof concurrency that people go on and on about relate to the use of shared \nmutable memory: race conditions, deadlock, livelock, etc. The answer seems \nobvious: either forgo concurrency or eschew shared memory!\n\nForgoing concurrency is almost certainly not an option. Computers have more \nand more cores on an almost quarterly basis, so harnessing true parallelism \nbecomes more and more important. We can no longer rely on ever-increasing \nprocessor clock speeds to improve application performance. Only by exploit-\ning parallelism will the performance of applications improve. Obviously, not \nimproving performance is an option, but it is unlikely to be acceptable to users.\n\nSo can we eschew shared memory? Definitely.\n\nInstead of using threads and shared memory as our programming model, we \ncan use processes and message passing. Process here just means a protected \nindependent state with executing code, not necessarily an operating system \nprocess. Languages such as Erlang (and occam before it) have shown that \n\n[image: image44.jpg]\n\n115Collective Wisdom from the Experts\n\nprocesses are a very successful mechanism for programming concurrent and \nparallel systems. Such systems do not have all the synchronization stresses \nthat shared-memory, multithreaded systems have. Moreover, there is a formal \nmodel\u2014Communicating Sequential Processes (CSP)\u2014that can be applied as \npart of the engineering of such systems.\n\nWe can go further and introduce dataflow systems as a way of computing. In \na dataflow system, there is no explicitly programmed control flow. Instead, a \ndirected graph of operators, connected by data paths, is set up and then data \nis fed into the system. Evaluation is controlled by the readiness of data within \nthe system. Definitely no synchronization problems.\n\nThat said, languages such as C, C++, Java, Python, and Groovy are the prin-\ncipal languages of systems development, and all of these are presented to \nprogrammers as languages for developing shared-memory, multithreaded \nsystems. So what can be done? The answer is to use\u2014or, if they don\u2019t exist, \ncreate\u2014libraries and frameworks that provide process models and message \npassing, avoiding all use of shared mutable memory.\n\nAll in all, not programming with shared memory, but instead using message \npassing, is likely to be the most successful way of implementing systems that \nharness the parallelism that is now endemic in computer hardware. Perhaps  \nbizarrely, although processes predate threads as a unit of concurrency, the \nfuture seems to be in using threads to implement processes.\n\n\n\n116 97 Things Every Programmer Should Know\n\nLinda Rising\n\nMAYBE iT\u2019S BECAUSE MOST OF THEM ARE SMART PEOPLE, but in all the \nyears I\u2019ve taught and worked side by side with programmers, it seems that \nmost of them thought that since the problems they were struggling with were \ndifficult, the solutions should be just as difficult for everyone (maybe even \nfor themselves a few months after the code was written) to understand and \nmaintain.\n\nI remember one incident with Joe, a student in my data structures class, who \nhad to come in to show me what he\u2019d written. \u201cBetcha can\u2019t guess what it does!\u201d \nhe crowed.\n\n\u201cYou\u2019re right,\u201d I agreed, without spending too much time on his example and \nwondering how to get an important message across. \u201cI\u2019m sure you\u2019ve been \nworking hard on this. I wonder, though, if you haven\u2019t forgotten something \nimportant. Say, Joe, don\u2019t you have a younger brother?\u201d\n\n\u201cYep. Sure do! Phil! He\u2019s in your Intro class. He\u2019s learning to program, too!\u201d Joe \nannounced proudly.\n\n\u201cThat\u2019s great,\u201d I replied. \u201cI wonder if he could read this code.\u201d\n\n\u201cNo way!\u201d said Joe. \u201cThis is hard stuff!\u201d\n\n\u201cJust suppose,\u201d I suggested, \u201cthat this was real, working code, and that in a few \nyears, Phil was hired to make a maintenance update. What have you done for \nhim?\u201d Joe just stared at me, blinking. \u201cWe know that Phil is really smart, right?\u201d \n\nA Message to \nthe Future\n\n[image: image58.jpg]  \n\n\n\n117Collective Wisdom from the Experts\n\nJoe nodded. \u201cAnd I hate to say it, but I\u2019m pretty smart, too!\u201d Joe grinned. \u201cSo if \nI can\u2019t easily understand what you\u2019ve done here and your very smart younger \nbrother will likely puzzle over this, what does that mean about what you\u2019ve \nwritten?\u201d Joe looked at his code a little differently, it seemed to me. \u201cHow \nabout this,\u201d I suggested in my best \u201cI\u2019m your friendly mentor\u201d voice, \u201cThink of \nevery line of code you write as a message for someone in the future\u2014someone \nwho might be your younger brother. Pretend you\u2019re explaining to this smart \nperson how to solve this tough problem.\n\n\u201cIs this what you\u2019d like to imagine? That the smart programmer in the future \nwould see your code and say, \u2018Wow! This is great! I can understand perfectly \nwhat\u2019s been done here and I\u2019m amazed at what an elegant\u2014no, wait\u2014what a \nbeautiful piece of code this is. I\u2019m going to show the other folks on my team. \nThis is a masterpiece!\u2019\n\n\u201cJoe, do you think you can write code that solves this difficult problem but \nwill be so beautiful it will sing? Yes, just like a haunting melody. I think that \nanyone who can come up with the very difficult solution you have here could \nalso write something beautiful. Hmm\u2026I wonder if I should start grading on \nbeauty? What do you think, Joe?\u201d\n\nJoe picked up his work and looked at me, a little smile creeping across his face. \n\u201cI got it, prof, I\u2019m off to make the world better for Phil. Thanks.\u201d\n\n\n\n118 97 Things Every Programmer Should Know\n\nMissing \nOpportunities for \nPolymorphism\nKirk Pepperdine\n\nPOLYMORPHiSM iS ONE OF THE GRAND iDEAS that is fundamental to OO. \nThe word, taken from Greek, means many (poly) forms (morph). In the con-\ntext of programming, polymorphism refers to many forms of a particular class \nof objects or method. But polymorphism isn\u2019t simply about alternate implemen-\ntations. Used carefully, polymorphism creates tiny localized execution contexts \nthat let us work without the need for verbose if-then-else blocks. Being in a \ncontext allows us to do the right thing directly, whereas being outside of that \ncontext forces us to reconstruct it so that we can then do the right thing. With \ncareful use of alternate implementations, we can capture context that can help \nus produce less code that is more readable. This is best demonstrated with \nsome code, such as the following (unrealistically) simple shopping cart:\n\npublic class ShoppingCart {\n\nprivate ArrayList<Item> cart = new ArrayList<Item>();\n\npublic void add(Item item) { cart.add(item); }\n\npublic Item takeNext() { return cart.remove(0);  }\n\npublic boolean isEmpty() { return cart.isEmpty(); }\n\n}\n\nLet\u2019s say our webshop offers items that can be downloaded and items that need \nto be shipped. Let\u2019s build another object that supports these operations:\n\npublic class Shipping {\n\npublic boolean ship(Item item, SurfaceAddress address) { ... }\n\npublic boolean ship(Item item, EMailAddress address { ... }\n\n}\n\nWhen a client has completed checkout, we need to ship the goods:\nwhile (!cart.isEmpty()) {\n\nshipping.ship(cart.takeNext(), ???);\n\n}\n\n[image: image59.jpg]  \n\n\n\n119Collective Wisdom from the Experts\n\nThe ??? parameter isn\u2019t some new fancy elvis operator; it\u2019s asking whether I \nshould email or snail-mail the item. The context needed to answer this ques-\ntion no longer exists. We have could captured the method of shipment in a \nboolean or enum and then used an if-then-else to fill in the missing parameter. \nAnother solution would be to create two classes that both extend Item. Let\u2019s \ncall these DownloadableItem and SurfaceItem. Now let\u2019s write some code. I\u2019ll pro-\nmote Item to be an interface that supports a single method, ship. To ship the \ncontents of the cart, we will call item.ship(shipper). Classes DownloadableItem \nand SurfaceItem will both implement ship:\n\npublic class DownloadableItem implements Item {\n\npublic boolean ship(Shipping shipper, Customer customer) {\n\nshipper.ship(this, customer.getEmailAddress());\n\n}\n\n}\n\npublic class SurfaceItem implements Item {\n\npublic boolean ship(Shipping shipper, Customer customer) {\n\nshipper.ship(this, customer.getSurfaceAddress());\n\n}\n\n}\n\nIn this example, we\u2019ve delegated the responsibility of working with Shipping \nto each Item. Since each item knows how it\u2019s best shipped, this arrangement \nallows us to get on with it without the need for an if-then-else. The code also \ndemonstrates a use of two patterns that often play well together: Command \nand Double Dispatch. Effective use of these patterns relies on careful use of \npolymorphism. When that happens, there will be a reduction in the number \nof if-then-else blocks in our code.\n\nWhile there are cases where it\u2019s much more practical to use if-then-else instead \nof polymorphism, it is more often the case that a more polymorphic coding style \nwill yield a smaller, more readable and less fragile codebase. The number of \nmissed opportunities is a simple count of the if-then-else statements in our code.\n\n\n\n120 97 Things Every Programmer Should Know\n\nNews of the \nWeird: Testers Are \nYour Friends\nBurk Hufnagel\n\nWHETHER THEY CALL THEMSELVES Quality Assurance or Quality Con-\ntrol, many programmers call them Trouble. In my experience, programmers \noften have an adversarial relationship with the people who test their software. \n\u201cThey\u2019re too picky\u201d and \u201cThey want everything perfect\u201d are common com-\nplaints. Sound familiar?\n\nI\u2019m not sure why, but I\u2019ve always had a different view of testers. Maybe it\u2019s \nbecause the \u201ctester\u201d at my first job was the company secretary. Margaret was \na very nice lady who kept the office running, and tried to teach a couple of \nyoung programmers how to behave professionally in front of customers. She \nalso had a gift for finding any bug, no matter how obscure, in mere moments.\n\nBack then, I was working on a program written by an accountant who thought \nhe was a programmer. Needless to say, it had some serious problems. When I \nthought I had a piece straightened out, Margaret would try to use it, and, more \noften than not, it would fail in some new way after just a few keystrokes. It \nwas at times frustrating and embarrassing, but she was such a pleasant person \nthat I never thought to blame her for making me look bad. Eventually, the day \ncame when Margaret was able to cleanly start the program, enter an invoice, \nprint it, and shut it down. I was thrilled. Even better, when we installed it on \nour customer\u2019s machine, it all worked. They never saw any problems because \nMargaret had helped me find and fix them first.\n\n[image: image60.jpg]  \n\n\n\n121Collective Wisdom from the Experts\n\nSo that\u2019s why I say testers are your friends. You may think the testers make you \nlook bad by reporting trivial issues. But when customers are thrilled because \nthey weren\u2019t bothered by all those \u201clittle things\u201d that QC made you fix, then \nyou look great. See what I mean?\n\nImagine this: you\u2019re test-driving a utility that uses \u201cgroundbreaking artificial \nintelligence algorithms\u201d to find and fix concurrency problems. You fire it up \nand immediately notice they misspelled \u201cintelligence\u201d on the splash screen. A \nlittle inauspicious, but it\u2019s just a typo, right? Then you notice the configuration \nscreen uses checkboxes where there should be radio buttons, and some of the \nkeyboard shortcuts don\u2019t work. Now, none of these is a big deal, but as the \nerrors add up, you begin to wonder about the programmers. If they can\u2019t get \nthe simple things right, what are the odds that their AI can really find and fix \nsomething tricky like concurrency issues?\n\nThey could be geniuses who were so focused on making the AI insanely great \nthat they didn\u2019t notice those trivial things, and without \u201cpicky testers\u201d pointing \nout the problems, you wound up finding them. And now you\u2019re questioning \nthe competency of the programmers.\n\nSo, as strange as it may sound, those testers who seem determined to expose \nevery little bug in your code really are your friends.\n\n\n\n122 97 Things Every Programmer Should Know\n\nOne Binary\nSteve Freeman\n\ni\u2019VE SEEN SEVERAL PROjECTS where the build rewrites some part of the \ncode to generate a custom binary for each target environment. This always \nmakes things more complicated than they should be, and introduces a risk \nthat the team may not have consistent versions on each installation. At a mini-\nmum, it involves building multiple, near-identical copies of the software, each \nof which then has to be deployed to the right place. It means more moving \nparts than necessary, which means more opportunities to make a mistake.\n\nI once worked on a team where every property change had to be checked in \nfor a full build cycle, so the testers were left waiting whenever they needed \na minor adjustment (did I mention that the build took too long as well?). I \nalso worked on a team where the system administrators insisted on rebuilding \nfrom scratch for production (using the same scripts that we did), which meant \nthat we had no proof that the version in production was the one that had been \nthrough testing. And so on.\n\nThe rule is simple: Build a single binary that you can identify and promote \nthrough all the stages in the release pipeline. Hold environment-specific \ndetails in the environment. This could mean, for example, keeping them in \nthe component container, in a known file, or in the path.\n\n[image: image61.jpg]  \n\n\n\n123Collective Wisdom from the Experts\n\nIf your team either has a code-mangling build or stores all the target settings \nwith the code, that suggests that no one has thought through the design care-\nfully enough to separate those features that are core to the application and \nthose that are platform-specific. Or it could be worse: the team knows what to \ndo but can\u2019t prioritize the effort to make the change.\n\nOf course, there are exceptions: you might be building for targets that have \nsignificantly different resource constraints, but that doesn\u2019t apply to the major-\nity of us who are writing \u201cdatabase to screen and back again\u201d applications. \nAlternatively, you might be living with some legacy mess that\u2019s too hard to fix \nright now. In such cases, you have to move incrementally\u2014but start as soon \nas possible.\n\nAnd one more thing: keep the environment information versioned, too. There\u2019s \nnothing worse than breaking an environment configuration and not being \nable to figure out what changed. The environmental information should be \nversioned separately from the code, since they\u2019ll change at different rates and \nfor different reasons. Some teams use distributed version control systems for \nthis (such as bazaar and git), since they make it easier to push changes made \nin production environments\u2014as inevitably happens\u2014back to the repository.\n\n\n\n124 97 Things Every Programmer Should Know\n\nOnly the Code \nTells the Truth\nPeter Sommerlad\n\nTHE ULTiMATE SEMANTiCS OF A PROGRAM is given by the running code. If \nthis is in binary form only, it will be a difficult read! The source code should, \nhowever, be available if it is your program, any typical commercial software \ndevelopment, an open source project, or code in a dynamically interpreted \nlanguage. When you look at the source code, the meaning of the program \nshould be apparent. To know what a program does, the source is ultimately all \nyou can be sure of looking at. Even the most accurate requirements document \ndoes not tell the whole truth: it does not contain the detailed story of what the \nprogram is actually doing, only the high-level intentions of the requirements \nanalyst. A design document may capture a planned design, but it will lack the \nnecessary detail of the implementation. These documents may have lost sync \nwith the current implementation\u2026or may simply have been lost. Or never \nwritten in the first place. The source code may be the only thing left.\n\nWith this in mind, ask yourself how clearly your code is telling you or any \nother programmer what it is doing.\n\nYou might say, \u201cOh, my comments will tell you everything you need to know.\u201d \nBut keep in mind that comments are not running code. They can be just as \nwrong as other forms of documentation. There has been a tradition of say-\ning that comments are unconditionally a good thing, so some programmers \nunquestioningly write more and more comments, even restating and explaining \ntrivia already obvious in the code. This is the wrong way to clarify your code. \n\n[image: image62.jpg]  \n\n\n\n125Collective Wisdom from the Experts\n\nIf your code needs comments, consider refactoring it so it doesn\u2019t. Lengthy \ncomments can clutter screen space and might even be hidden automatically by \nyour IDE. If you need to explain a change, do so in the version control system \ncheck-in message and not in the code.\n\nWhat can you do to actually make your code tell the truth as clearly as pos-\nsible? Strive for good names. Structure your code with respect to cohesive \nfunctionality, which also eases naming. Decouple your code to achieve \northogonality. Write automated tests explaining the intended behavior and \ncheck the interfaces. Refactor mercilessly when you learn how to code a \nsimpler, better solution. Make your code as simple as possible to read and \nunderstand.\n\nTreat your code like any other composition, such as a poem, an essay, a pub-\nlic blog, or an important email. Craft what you express carefully, so that it \ndoes what it should and communicates as directly as possible what it is doing; \nso that it still communicates your intention when you are no longer around. \nRemember that useful code is used much longer than ever intended. Mainte-\nnance programmers will thank you. And, if you are a maintenance program-\nmer and the code you are working on does not tell the truth easily, apply the \naforementioned guidelines in a proactive manner. Establish some sanity in the \ncode, and keep your own sanity.\n\n\n\n126 97 Things Every Programmer Should Know\n\nOwn (and Refactor) \nthe Build\nSteve Berczuk\n\niT iS NOT UNCOMMON for teams that are otherwise highly disciplined about \ncoding practices to neglect build scripts, either out of a belief that they are \nmerely an unimportant detail or from a fear that they are complex and need to \nbe tended to by the cult of release engineering. Unmaintainable build scripts \nwith duplication and errors cause problems of the same magnitude as those in \npoorly factored code.\n\nOne rationale for why disciplined, skilled developers treat the build as some-\nthing secondary to their work is that build scripts are often written in a differ-\nent language than source code. Another is that the build is not really \u201ccode.\u201d \nThese justifications fly in the face of the reality that most software developers \nenjoy learning new languages, and that the build is what creates executable \nartifacts for developers and end users to test and run. The code is useless with-\nout being built, and the build is what defines the component architecture of \nthe application. The build is an essential part of the development process, and \ndecisions about the build process can make the code and the coding simpler.\n\nBuild scripts written using the wrong idioms are difficult to maintain and, \nmore significantly, improve. It is worth spending some time to understand \nthe right way to make a change. Bugs can appear when an application is built \nwith the wrong version of a dependency or when a build-time configuration \nis wrong.\n\n[image: image22.jpg]\n\n127Collective Wisdom from the Experts\n\nTraditionally, testing has been something that was always left to the \u201cQuality \nAssurance\u201d team. We now realize that testing as we code is necessary to being \nable to deliver value predictably. In much the same way, the build process \nneeds to be owned by the development team.\n\nUnderstanding the build can simplify the entire development lifecycle and \nreduce costs. A simple-to-execute build allows a new developer to get started \nquickly and easily. Automating configuration in the build can enable you to \nget consistent results when multiple people are working on a project, avoiding \nan \u201cit works for me\u201d conversation. Many build tools allow you to run reports \non code quality, allowing you to sense potential problems early. By spending \ntime understanding how to make the build yours, you can help yourself and \neveryone else on your team. You can focus on coding features, benefiting your \nstakeholders and making work more enjoyable.\n\nLearn enough of your build process to know when and how to make changes. \nBuild scripts are code. They are too important to be left to someone else, if for \nno other reason than because the application is not complete until it is built. The \njob of programming is not complete until we have delivered working software.\n\n\n\n128 97 Things Every Programmer Should Know\n\nPair Program and \nFeel the Flow\nGudny Hauknes, Kari R\u00f8ssland, and \nAnn Katrin Gagnat\n\niMAGiNE THAT YOU ARE TOTALLY ABSORBED by what you are doing\u2014\nfocused, dedicated, and involved. You may have lost track of time. You prob-\nably feel happy. You are experiencing flow. It is difficult to both achieve and \nmaintain flow for a whole team of developers since there are so many interrup-\ntions, interactions, and other distractions that can easily break it.\n\nIf you have already practiced pair programming, you are probably familiar with \nhow pairing contributes to flow. If you have not, we want to use our experiences \nto motivate you to start right now! To succeed with pair programming, both \nindividual team members and the team as a whole have to put forth some effort.\n\nAs a team member, be patient with developers less experienced than you. Con-\nfront your fears about being intimidated by more skilled developers. Realize \nthat people are different, and value it. Be aware of your own strengths and \nweaknesses, as well as those of other team members. You may be surprised by \nhow much you can learn from your colleagues.\n\nAs a team, introduce pair programming to promote distribution of skills and \nknowledge throughout the project. You should solve your tasks in pairs and \nrotate pairs and tasks frequently. Agree upon a rule of rotation. Put the rule \naside or adjust it when necessary. Our experience is that you do not necessarily \nneed to complete a task before rotating it to another pair. Interrupting a task \nto pass it to another pair may sound counterintuitive, but we have found that \nit works.\n\nThere are numerous situations where flow can be broken, but where pair pro-\ngramming helps you keep it:\n\n\u2022 Reduce the \u201ctruck factor.\u201d It\u2019s a slightly morbid thought experiment, \nbut how many of your team members would have to be hit by a truck \nbefore the team became unable to complete the final deliverable? In \nother words, how dependent is your delivery on certain team members? \n\n[image: image63.jpg]  \n\n\n\n129Collective Wisdom from the Experts\n\nIs knowledge privileged or shared? If you have been rotating tasks among \npairs, there is always someone else who has the knowledge and can com-\nplete the work. Your team\u2019s flow is not as affected by the \u201ctruck factor.\u201d \n\n\u2022 Solve problems effectively. If you are pair programming and you run into \na challenging problem, you always have someone to discuss it with. Such \ndialog is more likely to open up possibilities than if you are stuck by your-\nself. As the work rotates, your solution will be revisited and reconsidered \nby the next pair, so it does not matter if you did not choose the optimal \nsolution initially. \n\n\u2022 Integrate smoothly. If your current task involves calling another piece of \ncode, you hope the names of the methods, the docs, and the tests are \ndescriptive enough to give you a grasp of what it does. If not, pairing with \na developer who was involved in writing that code will give you better \noverview and faster integration into your own code. Additionally, you \ncan use the discussion as an opportunity to improve the naming, docs, \nand testing. \n\n\u2022 Mitigate interruptions. If someone comes over to ask you a question, or \nyour phone rings, or you have to answer an urgent email, or you have to \nattend a meeting, your pair programming partner can keep on coding. \nWhen you return, your partner is still in the flow and you will quickly \ncatch up and rejoin him. \n\n\u2022 Bring new team members up to speed quickly. With pair programming, \nand a suitable rotation of pairs and tasks, newcomers quickly get to know \nboth the code and the other team members. \n\nFlow makes you incredibly productive. But it is also vulnerable. Do what you \ncan to get it, and hold on to it when you\u2019ve got it!\n\n\n\n130 97 Things Every Programmer Should Know\n\nPrefer Domain-\nSpecific Types to \nPrimitive Types\nEinar Landre\n\nON SEPTEMBER 23, 1999, the $327.6 million Mars Climate Orbiter was lost \nwhile entering orbit around Mars due to a software error back on Earth. \nThe error was later called the metric mix-up. The ground-station software \nwas working in pounds, while the spacecraft expected newtons, leading the \nground station to underestimate the power of the spacecraft\u2019s thrusters by a \nfactor of 4.45.\n\nThis is one of many examples of software failures that could have been pre-\nvented if stronger and more domain-specific typing had been applied. It is \nalso an example of the rationale behind many features in the Ada language, \none of whose primary design goals was to implement embedded safety-critical \nsoftware. Ada has strong typing with static checking for both primitive types \nand user-defined types:\n\ntype Velocity_In_Knots is new Float range 0.0 .. 500.00;\n\ntype Distance_In_Nautical_Miles is new Float range 0.0 .. 3000.00;\n\nVelocity: Velocity_In_Knots;\n\nDistance: Distance_In_Nautical_Miles;\n\nSome_Number: Float;\n\nSome_Number:= Distance + Velocity; -- Will be caught by the compiler as a type error.\n\n[image: image64.jpg]  \n\n\n\n131Collective Wisdom from the Experts\n\nDevelopers in less demanding domains might also benefit from applying \nmore domain-specific typing, where they might otherwise continue to use \nthe primitive data types offered by the language and its libraries, such as \nstrings and floats. In Java, C++, Python, and other modern languages, the \nabstract data type is known as class. Using classes such as Velocity_In_Knots \nand Distance_In_Nautical_Miles adds a lot of value with respect to code quality:\n\n\u2022 The code becomes more readable, as it expresses concepts of a domain, \nnot just Float or String.\n\n\u2022 The code becomes more testable, as the code encapsulates behavior that \nis easily testable.\n\n\u2022 The code facilitates reuse across applications and systems. \n\nThe approach is equally valid for users of both statically and dynamically \ntyped languages. The only difference is that developers using statically typed \nlanguages get some help from the compiler, while those embracing dynami-\ncally typed languages are more likely to rely on their unit tests. The style of \nchecking may be different, but the motivation and style of expression is not.\n\nThe moral is to start exploring domain-specific types for the purpose of \ndeveloping quality software.\n\n\n\n132 97 Things Every Programmer Should Know\n\nPrevent Errors\nGiles Colborne\n\nERROR MESSAGES are the most critical interactions between the user and the \nrest of the system. They happen when communication between the user and \nthe system is near the breaking point.\n\nIt is easy to think of an error as being caused by a wrong input from the user. \nBut people make mistakes in predictable, systematic ways. So it is possible to \n\u201cdebug\u201d the communication between the user and the rest of the system just as \nyou would between other system components.\n\nFor instance, say you want the user to enter a date within an allowed range. \nRather than letting the user enter any date, it is better to offer a device such as \na list or calendar showing only the allowed dates. This eliminates any chance \nof the user entering a date outside of the range.\n\nFormatting errors are another common problem. For instance, if a user is pre-\nsented with a Date text field and enters an unambiguous date such as \u201cJuly \n29, 2012,\u201d it is unreasonable to reject it simply because it is not in a preferred \nformat (such as \u201cDD/MM/YYYY\u201d). It is worse still to reject \u201c29 / 07 / 2012\u201d \nbecause it contains extra spaces\u2014this kind of problem is particularly hard for \nusers to understand, as the date appears to be in the desired format.\n\nThis error occurs because it is easier to reject the date than parse the three or \nfour most common date formats. These kinds of petty errors lead to user frus-\ntration, which in turn lead to additional errors as the user loses concentration. \nInstead, respect users\u2019 preference to enter information, not data.\n\nAnother way of avoiding formatting errors is to offer cues\u2014for instance, \nwith a label within the field showing the desired format (\u201cDD/MM/YYYY\u201d). \nAnother cue might be to divide the field into three text boxes of two, two, and \nfour characters.\n\n[image: image65.jpg]  \n\n\n\n133Collective Wisdom from the Experts\n\nCues are different from instructions: cues tend to be hints; instructions are \nverbose. Cues occur at the point of interaction; instructions appear before the \npoint of interaction. Cues provide context; instructions dictate use.\n\nIn general, instructions are ineffective at preventing error. Users tend to assume \nthat interfaces will work in line with their past experience (\u201cSurely everyone \nknows what \u2018July 29, 2012\u2019 means?\u201d). So instructions go unread. Cues nudge \nusers away from errors.\n\nAnother way of avoiding errors is to offer defaults. For instance, users typically \nenter values that correspond to today, tomorrow, my birthday, my deadline, or \nthe date I entered last time I used this form. Depending on context, one of these \nis likely to be a good choice as a smart default.\n\nWhatever the cause, systems should be tolerant of errors. You can facilitate this \nby providing multiple levels of undo to all actions\u2014and, in particular, actions \nthat have the potential to destroy or amend users\u2019 data.\n\nLogging and analyzing undo actions can also highlight where the interface \nis drawing users into unconscious errors, such as persistently clicking on the \n\u201cwrong\u201d button. These errors are often caused by misleading cues or interac-\ntion sequences that you can redesign to prevent further error.\n\nWhichever approach you take, most errors are systematic\u2014the result of mis-\nunderstandings between the user and the software. Understanding how users \nthink, interpret information, make decisions, and input data will help you \ndebug the interactions between your software and your users.\n\n\n\n134 97 Things Every Programmer Should Know\n\nThe Professional \nProgrammer\nRobert C. Martin (Uncle Bob)\n\nWHAT iS A PROFESSiONAL PROGRAMMER?\n\nThe single most important trait of a professional programmer is personal \nresponsibility. Professional programmers take responsibility for their career, \ntheir estimates, their schedule commitments, their mistakes, and their work-\nmanship. A professional programmer does not pass that responsibility off on \nothers.\n\n\u2022 If you are a professional, then you are responsible for your own career. You \nare responsible for reading and learning. You are responsible for staying \nup to date with the industry and the technology. Too many program-\nmers feel that it is their employer\u2019s job to train them. Sorry, this is just \ndead wrong. Do you think doctors behave that way? Do you think law-\nyers behave that way? No, they train themselves on their own time, and \ntheir own nickel. They spend much of their off-hours reading journals \nand decisions. They keep themselves up to date. And so must we. The \nrelationship between you and your employer is spelled out nicely in your \nemployment contract. In short: your employer promises to pay you, and \nyou promise to do a good job. \n\n\u2022 Professionals take responsibility for the code they write. They do not release \ncode unless they know it works. Think about that for a minute. How can \nyou possibly consider yourself a professional if you are willing to release \ncode that you are not sure of? Professional programmers expect QA to \nfind nothing because they don\u2019t release their code until they\u2019ve thoroughly \ntested it. Of course, QA will find some problems, because no one is per-\nfect. But as professionals, our attitude must be that we will leave nothing \nfor QA to find. \n\n[image: image66.jpg]  \n\n\n\n135Collective Wisdom from the Experts\n\n\u2022 Professionals are team players. They take responsibility for the output of \nthe whole team, not just their own work. They help one another, teach one \nanother, learn from one another, and even cover for one another when \nnecessary. When one teammate falls down, the others step in, knowing \nthat one day they\u2019ll be the ones to need cover. \n\n\u2022 Professionals do not tolerate big bug lists. A huge bug list is sloppy. Systems \nwith thousands of issues in the issue-tracking database are tragedies of \ncarelessness. Indeed, in most projects, the very need for an issue-tracking \nsystem is a symptom of carelessness. Only the very biggest systems should \nhave bug lists so long that automation is required to manage them. \n\n\u2022 Professionals do not make a mess. They take pride in their workmanship. \nThey keep their code clean, well structured, and easy to read. They follow \nagreed-upon standards and best practices. They never, ever rush. Imagine \nthat you are having an out-of-body experience watching a doctor per-\nform open-heart surgery on you. This doctor has a deadline (in the literal \nsense). He must finish before the heart-lung bypass machine damages too \nmany of your blood cells. How do you want him to behave? Do you want \nhim to behave like the typical software developer, rushing and making a \nmess? Do you want him to say, \u201cI\u2019ll go back and fix this later\u201d? Or do you \nwant him to hold carefully to his disciplines, taking his time, confident \nthat his approach is the best approach he can reasonably take. Do you \nwant a mess, or professionalism? \n\nProfessionals are responsible. They take responsibility for their own careers. \nThey take responsibility for making sure their code works properly. They \ntake responsibility for the quality of their workmanship. They do not aban-\ndon their principles when deadlines loom. Indeed, when the pressure \nmounts, professionals hold ever tighter to the disciplines they know are right.\n\n\n\n136 97 Things Every Programmer Should Know\n\nPut Everything \nUnder Version \nControl\nDiomidis Spinellis\n\nPUT EVERYTHiNG iN ALL YOUR PROjECTS UNDER VERSiON CONTROL. \n\nThe resources you need are there: free tools like Subversion, Git, Mercurial, \nand CVS; plentiful disk space; cheap and powerful servers; ubiquitous net-\nworking; and even project-hosting services. After you\u2019ve installed the version \ncontrol software, all you need in order to put your work in its repository is \nto issue the appropriate command in a clean directory containing your code. \nAnd there are just two new basic operations to learn: you commit your code \nchanges to the repository and you update your working version of the project \nwith the repository\u2019s version.\n\nOnce your project is under version control, you can obviously track its his-\ntory, see who wrote what code, and refer to a file or project version through a \nunique identifier. More importantly, you can make bold code changes without \nfear\u2014no more commented-out code just in case you need it in the future, \nbecause the old version lives safely in the repository. You can (and should) tag \na software release with a symbolic name so that you can easily revisit in the \nfuture the exact version of the software your customer runs. You can create \nbranches of parallel development: most projects have an active development \nbranch and one or more maintenance branches for released versions that are \nactively supported.\n\nA version control system minimizes friction among developers. When pro-\ngrammers work on independent software parts, these get integrated almost by \nmagic. When they step on one another\u2019s toes, the system notices and allows \nthem to sort out the conflicts. With some additional setup, the system can \nnotify all developers for each committed change, establishing a common \nunderstanding of the project\u2019s progress.\n\n[image: image67.jpg]  \n\n\n\n137Collective Wisdom from the Experts\n\nWhen you set up your project, don\u2019t be stingy: place all the project\u2019s assets \nunder version control. In addition to the source code, include the documenta-\ntion, tools, build scripts, test cases, artwork, and even libraries. With the com-\nplete project safely tucked into the (regularly backed up) repository, the potential \ndamage of losing your disk or data is minimized. Setting up for development \non a new machine involves simply checking out the project from the reposi-\ntory. This simplifies distributing, building, and testing the code on different \nplatforms: on each machine, a single update command will ensure that the \nsoftware is the current version.\n\nOnce you\u2019ve seen the beauty of working with a version control system, follow-\ning a couple of rules will make you and your team even more effective:\n\n\u2022 Commit each logical change in a separate operation. Lumping many changes \ntogether in a single commit will make it difficult to disentangle them in the \nfeature. This is especially important when you make project-wide refactor-\nings or style changes, which can easily obscure other modifications. \n\n\u2022 Accompany each commit with an explanatory message. At a minimum, \ndescribe succinctly what you\u2019ve changed, but if you also want to record \nthe change\u2019s rationale, this is the best place to store it. \n\n\u2022 Finally, avoid committing code that will break a project\u2019s build, otherwise \nyou\u2019ll become unpopular with the project\u2019s other developers. \n\nLife under a version control system is too good to ruin it with easily avoidable \nmissteps.\n\n\n\n138 97 Things Every Programmer Should Know\n\nPut the Mouse Down \nand Step Away \nfrom the Keyboard\nBurk Hufnagel\n\nYOU\u2019VE BEEN FOCUSED FOR HOURS on some gnarly problem, and there\u2019s \nno solution in sight. So you get up to stretch your legs or to hit the vending \nmachines and, on the way back, the answer suddenly becomes obvious.\n\nDoes this scenario sound familiar? Ever wonder why it happens? The trick is \nthat while you\u2019re coding, the logical part of your brain is active and the creative \nside is shut out. It can\u2019t present anything to you until the logical side takes a \nbreak.\n\nHere\u2019s a real-life example: I was cleaning up some legacy code and ran into an \n\u201cinteresting\u201d method. It was designed to verify that a string contained a valid \ntime using the format hh:mm:ss xx, where hh represents the hour, mm repre-\nsents minutes, ss represents seconds, and xx is either AM or PM.\n\nThe method used the following code to convert two characters (representing \nthe hour) into a number, and verify it was within the proper range:\n\ntry {\n\nInteger.parseInt(time.substring(0, 2));\n\n} catch (Exception x) {\n\nreturn false;\n\n}\n\nif (Integer.parseInt(time.substring(0, 2)) > 12) {\n\nreturn false;\n\n}\n\nThe same code appeared twice more, with appropriate changes to the charac-\nter offset and upper limit, to test the minutes and seconds. The method ended \nwith these lines to check for AM and PM:\n\n[image: image68.jpg]  \n\n\n\n139Collective Wisdom from the Experts\n\nif (!time.substring(9, 11).equals(\"AM\") &\n\n!time.substring(9, 11).equals(\"PM\")) {\n\nreturn false;\n\n}\n\nIf none of this series of comparisons failed, returning false, the method \nreturned true.\n\nIf the preceding code seems wordy and difficult to follow, don\u2019t worry. I \nthought so, too\u2014which meant I\u2019d found something worth cleaning up. I refac-\ntored it and wrote a few unit tests, just to make sure it still worked.\n\nWhen I finished, I felt pleased with the results. The new version was easy to \nread, half the size, and more accurate because the original code tested only the \nupper boundary for the hours, minutes, and seconds.\n\nWhile getting ready for work the next day, an idea popped in my head: why not \nvalidate the string using a regular expression? After a few minutes of typing, I \nhad a working implementation in just one line of code. Here it is:\n\npublic static boolean validateTime(String time) {\n\nreturn time.matches(\"(0[1-9]|1[0-2]):[0-5][0-9]:[0-5][0-9] ([AP]M)\");\n\n}\n\nThe point of this story is not that I eventually replaced over 30 lines of code \nwith just one. The point is that until I got away from the computer, I thought \nmy first attempt was the best solution to the problem.\n\nSo, the next time you hit a nasty problem, do yourself a favor. Once you really \nunderstand the problem, go do something involving the creative side of your \nbrain\u2014sketch out the problem, listen to some music, or just take a walk out-\nside. Sometimes the best thing you can do to solve a problem is to put the \nmouse down and step away from the keyboard.\n\n\n\n140 97 Things Every Programmer Should Know\n\nRead Code\nKarianne Berg\n\nWE PROGRAMMERS ARE WEiRD CREATURES. We love writing code. But \nwhen it comes to reading it, we usually shy away. After all, writing code is \nso much more fun, and reading code is hard\u2014sometimes almost impossible. \nReading other people\u2019s code is particularly hard. Not necessarily because other \npeople\u2019s code is bad, but because they probably think and solve problems in a \ndifferent way than you. But did you ever consider that reading someone else\u2019s \ncode could improve your own?\n\nThe next time you read some code, stop and think for a moment. Is the code \neasy or hard to read? If it is hard to read, why is that? Is the formatting poor? \nIs naming inconsistent or illogical? Are several concerns mixed together in the \nsame piece of code? Perhaps the choice of language prohibits the code from \nbeing readable. Try to learn from other people\u2019s mistakes, so that your code \nwon\u2019t contain the same ones. You may receive a few surprises. For example, \ndependency-breaking techniques may be good for low coupling, but they can \nsometimes also make code harder to read. And what some people call elegant \ncode, others call unreadable.\n\nIf the code is easy to read, stop to see if there is something useful you can learn \nfrom it. Maybe there\u2019s a design pattern in use that you don\u2019t know about, or \nhad previously struggled to implement. Perhaps the methods are shorter and \ntheir names more expressive than yours. Some open source projects are full of \ngood examples of how to write brilliant, readable code\u2014while others serve as \nexamples of the exact opposite! Check out some of their code and take a look.\n\n[image: image69.jpg]  \n\n\n\n141Collective Wisdom from the Experts\n\nReading your own old code, from a project you are not currently working on, \ncan also be an enlightening experience. Start with some of your oldest code \nand work your way forward to the present. You will probably find that it is \nnot at all as easy to read as when you wrote it. Your early code may also have \na certain embarrassing entertainment value, kind of in the same way as being \nreminded of all the things you said when you were drinking in the pub last \nnight. Look at how you have developed your skills over the years\u2014it can be \ntruly motivating. Observe what areas of the code are hard to read, and con-\nsider whether you are still writing code in the same way today.\n\nSo, the next time you feel the need to improve your programming skills, don\u2019t \nread another book. Read code.\n\n\n\n142 97 Things Every Programmer Should Know\n\nRead the \nHumanities\nKeith Braithwaite\n\niN ALL BUT THE SMALLEST DEVELOPMENT PROjECT, people work with \npeople. In all but the most abstracted field of research, people write software \nfor people to support them in some goal of theirs. People write software with \npeople for people. It\u2019s a people business. Unfortunately, what is taught to pro-\ngrammers too often equips them very poorly to deal with people they work for \nand with. Luckily, there is an entire field of study that can help.\n\nFor example, Ludwig Wittgenstein makes a very good case in Philosophical \nInvestigations (Wiley-Blackwell), and elsewhere, that any language we use to \nspeak to one another is not\u2014cannot be\u2014a serialization format for getting a \nthought or idea or picture out of one person\u2019s head and into another\u2019s. Already, \nwe should be on our guard against misunderstanding when we \u201cgather require-\nments.\u201d Wittgenstein also shows that our ability to understand one another at \nall does not arise from shared definitions, it arises from a shared experience, \nfrom a form of life. This may be one reason why programmers who are steeped \nin their problem domain tend to do better than those who stand apart from it.\n\nLakoff and Johnson present us with a catalog of Metaphors We Live By (Uni-\nversity of Chicago Press), suggesting that language is largely metaphorical, and \nthat these metaphors offer an insight into how we understand the world. Even \nseemingly concrete terms like cash flow, which we might encounter in talk-\ning about a financial system, can be seen as metaphorical: \u201cmoney is a fluid.\u201d \nHow does that metaphor influence the way we think about systems that handle \nmoney? Or we might talk about layers in a stack of protocols, with some high \nlevel and some low level. This is powerfully metaphorical: the user is \u201cup\u201d and \nthe technology is \u201cdown.\u201d This exposes our thinking about the structure of the \nsystems we build. It can also mark a lazy habit of thought that we might benefit \nfrom breaking from time to time.\n\n[image: image70.jpg]  \n\n\n\n143Collective Wisdom from the Experts\n\nMartin Heidegger studied closely the ways that people experience tools. Pro-\ngrammers build and use tools, we think about and create and modify and \nrecreate tools. Tools are objects of interest to us. But for its users, as Heiddeger \nshows in Being and Time (Harper Perennial), a tool becomes an invisible thing \nunderstood only in use. For users, tools only become objects of interest when \nthey don\u2019t work. This difference in emphasis is worth bearing in mind whenever \nusability is under discussion.\n\nEleanor Rosch overturned the Aristotelean model of the categories by which \nwe organize our understanding of the world. When programmers ask users \nabout their desires for a system, we tend to ask for definitions built out of \npredicates. This is very convenient for us. The terms in the predicates can very \neasily become attributes on a class or columns in a table. These sorts of catego-\nries are crisp, disjoint, and tidy. Unfortunately, as Rosch showed in \u201cNatural \nCategories\u201d* and later works, that just isn\u2019t how people in general understand \nthe world. They understand it in ways that are based on examples. Some exam-\nples, so-called prototypes, are better than others and so the resulting categories \nare fuzzy, they overlap, they can have rich internal structure. Insofar as we \ninsist on Aristotelean answers, we can\u2019t ask users the right questions about the \nuser\u2019s world, and will struggle to come to the common understanding we need.\n\n* Cognitive Psychology 4: 328\u201350 (1973)\n\n\n\n144 97 Things Every Programmer Should Know\n\nReinvent the \nWheel Often\nJason P. Sage\n\nJust use something that exists\u2014it\u2019s silly to reinvent the wheel.\u2026\n\nHAVE YOU EVER HEARD THiS OR SOME VARiATiON THEREOF? Sure you \nhave! Every developer and student probably hears comments like this fre-\nquently. Why, though? Why is reinventing the wheel so frowned upon? \nBecause, more often than not, existing code is working code. It has already \ngone through some sort of quality control and rigorous testing, and is being \nused successfully. Additionally, the time and effort invested in reinvention are \nunlikely to pay off as well as using an existing product or codebase. Should you \nbother reinventing the wheel? Why? When?\n\nPerhaps you have seen publications about patterns in software development, \nor books on software design. These books can be sleepers, regardless of how \nwonderful the information contained in them is. The same way that watching \na movie about sailing is very different from going sailing, so too is using exist-\ning code versus designing your own software from the ground up, testing it, \nbreaking it, repairing it, and improving it along the way.\n\nReinventing the wheel is not just an exercise in where to place code constructs: it \nis about how to get an intimate knowledge of the inner workings of various com-\nponents that already exist. Do you know how memory managers work? Virtual \npaging? Could you implement these yourself? How about double-linked lists? \nDynamic array classes? ODBC clients? Could you write a graphical user inter-\nface that works like a popular one you know and like? Can you create your \nown web-browser widgets? Do you know when to write a multiplexed system \nversus a multithreaded one? How to decide between a file- or a memory-based \ndatabase? \n\n[image: image71.jpg]  \n\n\n\n145Collective Wisdom from the Experts\n\nMost developers simply have never created these types of core software imple-\nmentations themselves and therefore do not have an intimate knowledge of \nhow they work. The consequence is that all these kinds of software are viewed \nas mysterious black boxes that just work. Understanding only the surface of \nthe water is not enough to reveal the hidden dangers beneath. Not knowing \nthe deeper things in software development will limit your ability to create \nstellar work.\n\nReinventing the wheel and getting it wrong is more valuable than nailing it first \ntime. There are lessons learned from trial and error that have an emotional \ncomponent to them that reading a technical book alone just cannot deliver!\n\nLearned facts and book smarts are crucial, but becoming a great programmer is \nas much about acquiring experience as it is about collecting facts. Reinventing \nthe wheel is as important to a developer\u2019s education and skill as weightlifting is \nto a body builder.\n\n\n\n146 97 Things Every Programmer Should Know\n\nResist the \nTemptation of the \nSingleton Pattern\nSam Saariste\n\nTHE SiNGLETON PATTERN SOLVES MANY OF YOUR PROBLEMS. You know \nthat you only need a single instance. You have a guarantee that this instance \nis initialized before it\u2019s used. It keeps your design simple by having a global \naccess point. It\u2019s all good. What\u2019s not to like about this classic design pattern?\n\nQuite a lot, it turns out. Tempting they may be, but experience shows that most \nsingletons really do more harm than good. They hinder testability and harm \nmaintainability. Unfortunately, this additional wisdom is not as widespread as \nit should be, and singletons continue to be irresistible to many programmers. \nBut they are worth resisting:\n\n\u2022 The single-instance requirement is often imagined. In many cases, it\u2019s pure \nspeculation that no additional instances will be needed in the future. \nBroadcasting such speculative properties across an application\u2019s design \nis bound to cause pain at some point. Requirements will change. Good \ndesign embraces this. Singletons don\u2019t. \n\n\u2022 Singletons cause implicit dependencies between conceptually independent \nunits of code. This is problematic both because they are hidden and because \nthey introduce unnecessary coupling between units. This code smell \nbecomes pungent when you try to write unit tests, which depend on loose \ncoupling and the ability to selectively substitute a mock implementation for \na real one. Singletons prevent such straightforward mocking. \n\n\u2022 Singletons also carry implicit persistent state, which again hinders unit \ntesting. Unit testing depends on tests being independent of one another, \nso the tests can be run in any order and the program can be set to a known \nstate before the execution of every unit test. Once you have introduced \nsingletons with mutable state, this may be hard to achieve. In addition, \nsuch globally accessible persistent state makes it harder to reason about \nthe code, especially in a multithreaded environment. \n\n[image: image72.jpg]  \n\n\n\n147Collective Wisdom from the Experts\n\n\u2022 Multithreading introduces further pitfalls to the singleton pattern. As straight-\nforward locking on access is not very efficient, the so-called double-checked \nlocking pattern (DCLP) has gained in popularity. Unfortunately, this may \nbe a further form of fatal attraction. It turns out that in many languages, \nDCLP is not thread-safe and, even where it is, there are still opportunities \nto get it subtly wrong. \n\nThe cleanup of singletons may present a final challenge:\n\n\u2022 There is no support for explicitly killing singletons. This can be a serious issue \nin some contexts\u2014for example, in a plug-in architecture where a plug-in \ncan only be safely unloaded after all its objects have been cleaned up. \n\n\u2022 There is no order to the implicit cleanup of singletons at program exit. \nThis can be troublesome for applications that contain singletons with \ninterdependencies. When shutting down such applications, one single-\nton may access another that has already been destroyed. \n\nSome of these shortcomings can be overcome by introducing additional \nmechanisms. However, this comes at the cost of additional complexity in code \nthat could have been avoided by choosing an alternative design.\n\nTherefore, restrict your use of the Singleton pattern to the classes that truly \nmust never be instantiated more than once. Don\u2019t use a singleton\u2019s global access \npoint from arbitrary code. Instead, direct access to the singleton should come \nfrom only a few well-defined places, from where it can be passed around via its \ninterface to other code. This other code is unaware, and so does not depend on \nwhether a singleton or any other kind of class implements the interface. This \nbreaks the dependencies that prevented unit testing and improves the main-\ntainability. So, the next time you are thinking about implementing or accessing \na singleton, I hope you\u2019ll pause and think again.\n\n\n\n148 97 Things Every Programmer Should Know\n\nThe Road to Performance \nIs Littered with Dirty \nCode Bombs\nKirk Pepperdine\n\nMORE OFTEN THAN NOT, performance tuning a system requires you to alter \ncode. When we need to alter code, every chunk that is overly complex or \nhighly coupled is a dirty code bomb lying in wait to derail the effort. The first \ncasualty of dirty code will be your schedule. If the way forward is smooth, it \nwill be easy to predict when you\u2019ll finish. Unexpected encounters with dirty \ncode will make it very difficult to make a sane prediction.\n\nConsider the case where you find an execution hot spot. The normal course \nof action is to reduce the strength of the underlying algorithm. Let\u2019s say you \nrespond to your manager\u2019s request for an estimate with an answer of 3\u20134 hours. \nAs you apply the fix, you quickly realize that you\u2019ve broken a dependent part. \nSince closely related things are often necessarily coupled, this breakage is most \nlikely expected and accounted for. But what happens if fixing that dependency \nresults in other dependent parts breaking? Furthermore, the farther away the \ndependency is from the origin, the less likely you are to recognize it as such and \naccount for it in your estimate. All of a sudden, your 3\u20134-hour estimate can eas-\nily balloon to 3\u20134 weeks. Often, this unexpected inflation in the schedule hap-\npens one or two days at a time. It is not uncommon to see \u201cquick\u201d refactorings \neventually taking several months to complete. In these instances, the damage to \nthe credibility and political capital of the responsible team will range from severe \nto terminal. If only we had a tool to help us identify and measure this risk.\u2026\n\nIn fact, we have many ways of measuring and controlling the degree and depth \nof coupling and complexity of our code. Software metrics can be used to count \nthe occurrences of specific features in our code. The values of these counts do \n\n[image: image73.jpg]  \n\n\n\n149Collective Wisdom from the Experts\n\ncorrelate with code quality. Two of a number of metrics that measure coupling \nare fan-in and fan-out. Consider fan-out for classes: it is defined as the number \nof classes referenced either directly or indirectly from a class of interest. You \ncan think of this as a count of all the classes that must be compiled before your \nclass can be compiled. Fan-in, on the other hand, is a count of all classes that \ndepend upon the class of interest. Knowing fan-out and fan-in, we can calcu-\nlate an instability factor using I = fo / (fi + fo). As I approaches 0, the package \nbecomes more stable. As I approaches 1, the package becomes unstable. Pack-\nages that are stable are low-risk targets for recoding, whereas unstable packages \nare more likely to be filled with dirty code bombs. The goal in refactoring is to \nmove I closer to 0.\n\nWhen using metrics, one must remember that they are only rules of thumb. \nBased purely on math, we can see that increasing fi without changing fo will \nmove I closer to 0. There is, however, a downside to a very large fan-in value: \nthese classes will be more difficult to alter without breaking dependents. Also, \nwithout addressing fan-out, you\u2019re not really reducing your risks, so some balance \nmust be applied.\n\nOne downside to software metrics is that the huge array of numbers that met-\nrics tools produce can be intimidating to the uninitiated. That said, software \nmetrics can be a powerful tool in our fight for clean code. They can help us \nto identify and eliminate dirty code bombs before they are a serious risk to a \nperformance-tuning exercise.\n\n\n\n150 97 Things Every Programmer Should Know\n\nSimplicity Comes \nfrom Reduction\nPaul W. Homer\n\n\u201cDO iT AGAiN\u2026,\u201d my boss told me as his finger pressed hard on the Delete key. \nI watched the computer screen with an all-too-familiar sinking feeling, as my \ncode\u2014line after line\u2014disappeared into oblivion.\n\nMy boss, Stefan, wasn\u2019t always the most vocal of people, but he knew bad code \nwhen he saw it. And he knew exactly what to do with it.\n\nI had arrived in my present position as a student programmer with lots of \nenergy and plenty of enthusiasm but absolutely no idea how to code. I had this \nhorrible tendency to think that the solution to every problem was to add in \nanother variable some place. Or throw in another line. On a bad day, instead of \nthe logic getting better with each revision, my code gradually got larger, more \ncomplex, and further away from working consistently.\n\nIt\u2019s natural, particularly when you\u2019re in a rush, to just want to make the most \nminimal changes to an existing block of code, even if it is awful. Most pro-\ngrammers will preserve bad code, fearing that starting anew will require sig-\nnificantly more effort than just going back to the beginning. That can be true \nfor code that is close to working, but there is just some code that is beyond all \nhelp.\n\n[image: image74.jpg]  \n\n\n\n151Collective Wisdom from the Experts\n\nMore time gets wasted in trying to salvage bad work than it should. Once \nsomething becomes a resource sink, it needs to be discarded. Quickly.\n\nNot that one should easily toss away all of that typing, naming, and formatting. \nMy boss\u2019s reaction was extreme, but it did force me to rethink the code on the \nsecond (or occasionally third) attempt. Still, the best approach to fixing bad \ncode is to flip into a mode where the code is mercilessly refactored, shifted \naround, or deleted.\n\nThe code should be simple. There should be a minimal number of variables, \nfunctions, declarations, and other syntactic language necessities. Extra lines, \nextra variables\u2026extra anything, really, should be purged immediately. What\u2019s \nthere, what\u2019s left, should be just enough to get the job done, completing the \nalgorithm or performing the calculations. Anything and everything else is just \nextra, unwanted noise, introduced accidentally, obscuring the flow, and hiding \nthe important stuff.\n\nOf course, if that doesn\u2019t do it, then just delete it all and type it in over again. \nDrawing from one\u2019s memory in that way can often help cut through a lot of \nunnecessarily clutter.\n\n\n\n152 97 Things Every Programmer Should Know\n\nThe Single \nResponsibility \nPrinciple\nRobert C. Martin (Uncle Bob)\n\nONE OF THE MOST FOUNDATiONAL PRiNCiPLES OF GOOD DESiGN iS:\n\nGather together those things that change for the same reason, and separate those \nthings that change for different reasons. \n\nThis principle is often known as the single responsibility principle, or SRP. In \nshort, it says that a subsystem, module, class, or even a function, should not \nhave more than one reason to change. The classic example is a class that has \nmethods that deal with business rules, reports, and databases:\n\npublic class Employee {\n\npublic Money calculatePay() ...\n\npublic String reportHours() ...\n\npublic void save() ...\n\n}\n\nSome programmers might think that putting these three functions together \nin the same class is perfectly appropriate. After all, classes are supposed to \nbe collections of functions that operate on common variables. However, the \nproblem is that the three functions change for entirely different reasons. The \ncalculatePay function will change whenever the business rules for calculating \npay do. The reportHours function will change whenever someone wants a dif-\nferent format for the report. The save function will change whenever the DBAs \nchange the database schema. These three reasons to change combine to make \nEmployee very volatile. It will change for any of those reasons. More importantly, \nany classes that depend upon Employee will be affected by those changes.\n\nGood system design means that we separate the system into components that \ncan be independently deployed. Independent deployment means that if we \nchange one component, we do not have to redeploy any of the others. However, \nif Employee is used heavily by many other classes in other components, then every \nchange to Employee is likely to cause the other components to be redeployed, \n\n[image: image75.jpg]  \n\n\n\n153Collective Wisdom from the Experts\n\nthus negating a major benefit of component design (or SOA, if you prefer the \ntrendier name). The following simple partitioning resolves the issues: \n\npublic class Employee {\n\npublic Money calculatePay() ...\n\n}\n\npublic class EmployeeReporter {\n\npublic String reportHours(Employee e) ...\n\n}\n\npublic class EmployeeRepository {\n\npublic void save(Employee e) ...\n\n}\n\nEach class can be placed in a component of its own. Or rather, all the reporting \nclasses can go into the reporting component. All the database-related classes \ncan go into the repository component. And all the business rules can go into \nthe business rule component.\n\nThe astute reader will see that there are still dependencies in the above solution. \nThat Employee is still depended upon by the other classes. So if Employee is modi-\nfied, the other classes will likely have to be recompiled and redeployed. Thus, \nEmployee cannot be modified and then independently deployed. However, the \nother classes can be modified and independently deployed. No modification of \none of them can force any of the others to be recompiled or redeployed. Even \nEmployee could be independently deployed through a careful use of the depen-\ndency inversion principle (DIP), but that\u2019s a topic for a different book.*\n\nCareful application of the SRP, separating things that change for different \nreasons, is one of the keys to creating designs that have an independently \ndeployable component structure.\n\n* http://www.amazon.com/dp/0135974445/\n\nhttp://www.amazon.com/dp/0135974445/\n\n\n154 97 Things Every Programmer Should Know\n\nStart from Yes\nAlex Miller\n\nRECENTLY, i WAS AT A GROCERY STORE, searching high and low for \u201cedam-\name\u201d (which I only vaguely knew was some kind of a vegetable). I wasn\u2019t sure \nwhether this was something I\u2019d find in the vegetable section, the frozen sec-\ntion, or in a can. I gave up and tracked down an employee to help me out. She \ndidn\u2019t know, either!\n\nThe employee could have responded in many different ways. She could have \nmade me feel ignorant for not knowing where to look, or given me vague pos-\nsibilities, or even just told me they didn\u2019t have the item. But instead, she treated \nthe request as an opportunity to find a solution and help a customer. She called \nother employees and within minutes had guided me to the exact item, nestled \nin the frozen section.\n\nThe employee in this case looked at a request and started from the premise \nthat we would solve the problem and satisfy the request. She started from yes \ninstead of starting from no.\n\nWhen I was first placed in a technical leadership role, I felt that my job was to \nprotect my beautiful software from the ridiculous stream of demands coming \nfrom product managers and business analysts. I started most conversations \nseeing a request as something to defeat, not something to grant.\n\nAt some point, I had an epiphany that maybe there was a different way to work \nthat merely involved shifting my perspective from starting at no to starting at \nyes. In fact, I\u2019ve come to believe that starting from yes is actually an essential \npart of being a technical leader.\n\nThis simple change radically altered how I approached my job. As it turns \nout, there are a lot of ways to say yes. When someone says to you, \u201cHey, this \n\n[image: image76.jpg]  \n\n\n\n155Collective Wisdom from the Experts\n\napp would really be the bee\u2019s knees if we made all the windows round and \ntranslucent!\u201d, you could reject it as ridiculous. But it\u2019s frequently better to start \nwith \u201cWhy?\u201d instead. Often, there is some actual and compelling reason why \nthat person is asking for round, translucent windows in the first place. For \nexample, you may be just about to sign a big, new customer with a standards \ncommittee that mandates round, translucent windows.\n\nUsually, you\u2019ll find that when you know the context of the request, new pos-\nsibilities open up. It\u2019s common for the request to be accomplished with the \nexisting product in some other way, allowing you to say yes with no work at \nall: \u201cActually, in the user preferences, you can download the round, translucent \nwindows skin and turn it on.\u201d\n\nSometimes the other person will simply have an idea that you find incom-\npatible with your view of the product. I find it\u2019s usually helpful to turn that \n\u201cWhy?\u201d on yourself. Sometimes the act of voicing the reason will make it clear \nthat your first reaction doesn\u2019t make sense. If not, you might need to kick it up \na notch and bring in other key decision makers. Remember, the goal of all of \nthis is to say yes to the other person and try to make it work, not just for him \nbut for you and your team as well.\n\nIf you can voice a compelling explanation as to why the feature request is \nincompatible with the existing product, then you are likely to have a produc-\ntive conversation about whether you are building the right product. Regardless \nof how that conversation concludes, everyone will focus more sharply on what \nthe product is, and what it is not.\n\nStarting from yes means working with your colleagues, not against them.\n\n\n\n156 97 Things Every Programmer Should Know\n\nStep Back and \nAutomate, Automate, \nAutomate\nCay Horstmann\n\ni WORKED WiTH PROGRAMMERS WHO, when asked to produce a count of \nthe lines of code in a module, pasted the files into a word processor and used \nits \u201cline count\u201d feature. And they did it again next week. And the week after. \nIt was bad.\n\nI worked on a project that had a cumbersome deployment process, involving \ncode signing and moving the result to a server, requiring many mouse clicks. \nSomeone automated it, and the script ran hundreds of times during final test-\ning, far more often than anticipated. It was good.\n\nSo, why do people do the same task over and over instead of stepping back and \ntaking the time to automate it?\n\nCommon misconception #1: Automation is only for testing\nSure, test automation is great, but why stop there? Repetitive tasks abound \nin any project: version control, compiling, building JAR files, documenta-\ntion generation, deployment, and reporting. For many of these tasks, the \nscript is mightier than the mouse. Executing tedious tasks becomes faster \nand more reliable.\n\nCommon misconception #2: I have an IDE, so I don\u2019t have to automate\nDid you ever have a \u201cBut it (checks out/builds/passes tests) on my \nmachine?\u201d argument with your teammates? Modern IDEs have thousands \nof potential settings, and it is essentially impossible to ensure that all team \nmembers have identical configurations. Build automation systems such as \nAnt or Autotools give you control and repeatability.\n\n[image: image77.jpg]  \n\n\n\n157Collective Wisdom from the Experts\n\nCommon misconception #3: I need to learn exotic tools in order to automate\nYou can go a long way with a decent shell language (such as bash or Power-\nShell) and a build automation system. If you need to interact with websites, \nuse a tool such as iMacros or Selenium.\n\nCommon misconception #4: I can\u2019t automate this task because I can\u2019t deal with \nthese file formats\n\nIf a part of your process requires Word documents, spreadsheets, or \nimages, it may indeed be challenging to automate it. But is that really nec-\nessary? Can you use plain text? Comma-separated values? XML? A tool \nthat generates a drawing from a text file? Often, a slight tweak in the pro-\ncess can yield good results with a dramatic reduction in tediousness.\n\nCommon misconception #5: I don\u2019t have the time to figure it out\nYou don\u2019t have to learn all of bash or Ant to get started. Learn as you go. \nWhen you have a task that you think can and should be automated, learn \njust enough about your tools to do it. And do it early in a project when \ntime is usually easier to find. Once you have been successful, you (and \nyour boss) will see that it makes sense to invest in automation.\n\n\n\n158 97 Things Every Programmer Should Know\n\nTake Advantage of \nCode Analysis Tools\nSarah Mount\n\nTHE VALUE OF TESTiNG is something that is drummed into software devel-\nopers from the early stages of their programming journey. In recent years, the \nrise of unit testing, test-driven development, and agile methods has attested to \na surge of interest in making the most of testing throughout all phases of the \ndevelopment cycle. However, testing is just one of many tools that you can use \nto improve the quality of code.\n\nBack in the mists of time, when C was still a new phenomenon, CPU time and \nstorage of any kind were at a premium. The first C compilers were mindful of \nthis and so cut down on the number of passes through the code they made \nby removing some semantic analyses. This meant that the compiler checked \nfor only a small subset of the bugs that could be detected at compile time. \nTo compensate, Stephen Johnson wrote a tool called lint\u2014which removes the \nfluff from your code\u2014that implemented some of the static analyses that had \nbeen removed from its sister C compiler. Static analysis tools, however, gained \na reputation for giving large numbers of false-positive warnings and warnings \nabout stylistic conventions that aren\u2019t always necessary to follow.\n\nThe current landscape of languages, compilers, and static analysis tools is very \ndifferent. Memory and CPU time are now relatively cheap, so compilers can \nafford to check for more errors. Almost every language boasts at least one tool \nthat checks for violations of style guides, common gotchas, and sometimes cun-\nning errors that can be hard to catch, such as potential null pointer dereferences. \n\n[image: image78.jpg]  \n\n\n\n159Collective Wisdom from the Experts\n\nThe more sophisticated tools, such as Splint for C or Pylint for Python, are \nconfigurable, meaning that you can choose which errors and warnings the tool \nemits with a configuration file, via command-line switches, or in your IDE. \nSplint will even let you annotate your code in comments to give it better hints \nabout how your program works.\n\nIf all else fails, and you find yourself looking for simple bugs or standards vio-\nlations that are not caught by your compiler, IDE, or lint tools, then you can \nalways roll your own static checker. This is not as difficult as it might sound. \nMost languages, particularly ones branded dynamic, expose their abstract syn-\ntax tree and compiler tools as part of their standard library. It is well worth \ngetting to know the dusty corners of standard libraries that are used by the \ndevelopment team of the language you are using, as these often contain hid-\nden gems that are useful for static analysis and dynamic testing. For example, \nthe Python standard library contains a disassembler which tells you the byte-\ncode used to generate some compiled code or code object. This sounds like \nan obscure tool for compiler writers on the python-dev team, but it is actually \nsurprisingly useful in everyday situations. One thing this library can disassemble \nis your last stack trace, giving you feedback on exactly which bytecode instruc-\ntion threw the last uncaught exception.\n\nSo, don\u2019t let testing be the end of your quality assurance\u2014take advantage of \nanalysis tools, and don\u2019t be afraid to roll your own.\n\n\n\n160 97 Things Every Programmer Should Know\n\nTest for Required \nBehavior, Not \nIncidental Behavior\nKevlin Henney\n\nA COMMON PiTFALL iN TESTiNG is to assume that exactly what an imple-\nmentation does is precisely what you want to test for. At first glance, this \nsounds more like a virtue than a pitfall. Phrased another way, however, the \nissue becomes more obvious: a common pitfall in testing is to hardwire tests \nto the specifics of an implementation, where those specifics are incidental and \nhave no bearing on the desired functionality.\n\nWhen tests are hardwired to implementation incidentals, changes to the imple-\nmentation that are actually compatible with the required behavior may cause \ntests to fail, leading to false positives. Programmers typically respond either \nby rewriting the test or by rewriting the code. Assuming that a false positive is \nactually a true positive is often a consequence of fear, uncertainty, or doubt. It \nhas the effect of raising the status of incidental behavior to required behavior. \nIn rewriting a test, programmers either refocus the test on the required behav-\nior (good) or simply hardwire it to the new implementation (not good). Tests \nneed to be sufficiently precise, but they also need to be accurate.\n\nFor example, in a three-way comparison, such as Java\u2019s String.compareTo or C\u2019s \nstrcmp, the requirements on the result are that it is negative if the lefthand side \nis less than the right, positive if the lefthand side is greater than the right, and \nzero if they are considered equal. This style of comparison is used in many \nAPIs, including the comparator for C\u2019s qsort function and compareTo in Java\u2019s \nComparable interface. Although the specific values \u20131 and +1 are commonly used \n\n[image: image79.jpg]  \n\n\n\n161Collective Wisdom from the Experts\n\nin implementations to signify less than and greater than, respectively, program-\nmers often mistakenly assume that these values represent the actual requirement \nand consequently write tests that nail this assumption up in public.\n\nA similar issue arises with tests that assert spacing, precise wording, and other \naspects of textual formatting and presentation that are incidental. Unless you \nare writing, for example, an XML generator that offers configurable format-\nting, spacing should not be significant to the outcome. Likewise, hardwiring \nplacement of buttons and labels on UI controls reduces the option to change \nand refine these incidentals in the future. Minor changes in implementation \nand inconsequential changes in formatting suddenly become build breakers.\n\nOverspecified tests are often a problem with whitebox approaches to unit test-\ning. Whitebox tests use the structure of the code to determine the test cases \nneeded. The typical failure mode of whitebox testing is that the tests end \nup asserting that the code does what the code does. Simply restating what \nis already obvious from the code adds no value and leads to a false sense of \nprogress and security.\n\nTo be effective, tests need to state contractual obligations rather than par-\nrot implementations. They need to take a blackbox view of the units under \ntest, sketching out the interface contracts in executable form. Therefore, align \ntested behavior with required behavior.\n\n\n\n162 97 Things Every Programmer Should Know\n\nTest Precisely \nand Concretely\nKevlin Henney\n\niT iS iMPORTANT TO TEST for the desired, essential behavior of a unit of code, \nrather than for the incidental behavior of its particular implementation. But \nthis should not be taken or mistaken as an excuse for vague tests. Tests need to \nbe both accurate and precise.\n\nSomething of a tried, tested, and testing classic, sorting routines offer an illus-\ntrative example. Implementing a sorting algorithm is not necessarily an every-\nday task for a programmer, but sorting is such a familiar idea that most people \nbelieve they know what to expect from it. This casual familiarity, however, can \nmake it harder to see past certain assumptions.\n\nWhen programmers are asked, \u201cWhat would you test for?\u201d, by far and away \nthe most common response is something like, \u201cThe result of sorting is a sorted \nsequence of elements.\u201d While this is true, it is not the whole truth. When \nprompted for a more precise condition, many programmers add that the result-\ning sequence should be the same length as the original. Although correct, this is \nstill not enough. For example, given the following sequence:\n\n3 1 4 1 5 9 \n\nThe following sequence satisfies a postcondition of being sorted in non-\ndescending order and having the same length as the original sequence:\n\n3 3 3 3 3 3 \n\nAlthough it satisfies the spec, it is also most certainly not what was meant! \nThis example is based on an error taken from real production code (fortu-\nnately caught before it was released), where a simple slip of a keystroke or a \nmomentary lapse of reason led to an elaborate mechanism for populating the \nwhole result with the first element of the given array.\n\nThe full postcondition is that the result is sorted and that it holds a permuta-\ntion of the original values. This appropriately constrains the required behavior. \n\n[image: image79.jpg]\n\n163Collective Wisdom from the Experts\n\nThat the result length is the same as the input length comes out in the wash \nand doesn\u2019t need restating.\n\nEven stating the postcondition in the way described is not enough to give you a \ngood test. A good test should be readable. It should be comprehensible and simple \nenough that you can see readily that it is correct (or not). Unless you already have \ncode lying around for checking that a sequence is sorted and that one sequence \ncontains a permutation of values in another, it is quite likely that the test code will \nbe more complex than the code under test. As Tony Hoare observed:\n\nThere are two ways of constructing a software design: one way is to make it so \nsimple that there are obviously no deficiencies and the other is to make it so com-\nplicated that there are no obvious deficiencies. \n\nUsing concrete examples eliminates this accidental complexity and opportu-\nnity for accident. For example, given the following sequence:\n\n3 1 4 1 5 9 \n\nThe result of sorting is the following:\n1 1 3 4 5 9 \n\nNo other answer will do. Accept no substitutes.\n\nConcrete examples help to illustrate general behavior in an accessible and \nunambiguous way. The result of adding an item to an empty collection is not \nsimply that it is not empty: it is that the collection now has a single item, and that \nthe single item held is the item added. Two or more items would qualify as not \nempty, and would also be wrong. A single item of a different value would also be \nwrong. The result of adding a row to a table is not simply that the table is one row \nbigger; it\u2019s also that the row\u2019s key can be used to recover the row added. And so on.\n\nIn specifying behavior, tests should not simply be accurate: they must also be precise.\n\n\n\n164 97 Things Every Programmer Should Know\n\nTest While You \nSleep (and over \nWeekends)\nRajith Attapattu\n\nRELAx. I am not referring to offshore development centers, overtime on week-\nends, or working the night shift. Rather, I want to draw your attention to how \nmuch computing power we have at our disposal. Specifically, how much we \nare not harnessing to make our lives as programmers a little easier. Are you \nconstantly finding it difficult to get enough computing power during the work \nday? If so, what are your test servers doing outside of normal work hours? \nMore often than not, the test servers are idling overnight and over the week-\nend. You can use this to your advantage.\n\n\u2022 Have you been guilty of committing a change without running all the \ntests? One of the main reasons programmers don\u2019t run test suites before \ncommitting code is because of the length of time they may take. When \ndeadlines are looming and push comes to shove, humans naturally start \ncutting corners. One way to address this is to break down your large test \nsuite into two or more profiles. A smaller, mandatory test profile that is \nquick to run will help to ensure that tests are run before each commit. \nAll of the test profiles (including the mandatory profile\u2014just to be sure) \ncan be automated to run overnight, ready to report their results in the \nmorning. \n\n\u2022 Have you had enough opportunity to test the stability of your product? \nLonger-running tests are vital for identifying memory leaks and other \nstability issues. They are seldom run during the day, as it will tie up time \nand resources. You could automate a soak test to be run during the night, \nand a bit longer over the weekend. From 6:00 PM Friday to 6:00 AM the \nfollowing Monday, there are 60 hours\u2019 worth of potential testing time. \n\n[image: image80.jpg]  \n\n\n\n165Collective Wisdom from the Experts\n\n\u2022 Are you getting quality time on your performance testing environment? I \nhave seen teams bickering with each other to get time on the performance \ntesting environment. In most cases, neither team gets enough quality \ntime during the day, while the environment is virtually idle after hours. \nThe servers and the network are not as busy during the night or over the \nweekend. It\u2019s an ideal time to run some quality performance tests. \n\n\u2022 Are there too many permutations to test manually? In many cases, your \nproduct is targeted to run on a variety of platforms. For example, both \n32-bit and 64-bit, on Linux, Solaris, and Windows, or simply on differ-\nent versions of the same operating system. To make matters worse, many \nmodern applications expose themselves to a plethora of transport mech-\nanisms and protocols (HTTP, AMQP, SOAP, CORBA, etc.). Manually \ntesting all of these permutations is very time consuming and most likely \ndone close to a release due to resource pressure. Alas, it may be too late in \nthe cycle to catch certain nasty bugs. \n\nAutomated tests run during the night or over weekends will ensure that all \nthese permutations are tested more often. With a little bit of thinking and \nsome scripting knowledge, you can schedule a few cron jobs to kick off some \ntesting at night and over the weekend. There are also many testing tools out \nthere that could help. Some organizations even have server grids that pool \nservers across different departments and teams to ensure that resources are \nutilized efficiently. If this is available in your organization, you can submit tests \nto be run at night or over weekends.\n\n\n\n166 97 Things Every Programmer Should Know\n\nTesting Is the Engineering \nRigor of Software \nDevelopment\nNeal Ford\n\nDEVELOPERS LOVE TO USE TORTURED METAPHORS when trying to explain \nwhat it is they do to family members, spouses, and other nontechies. We fre-\nquently resort to bridge building and other \u201chard\u201d engineering disciplines. \nAll these metaphors fall down quickly, though, when you start trying to push \nthem too hard. It turns out that software development is not like many of the \n\u201chard\u201d engineering disciplines in lots of important ways.\n\nCompared to \u201chard\u201d engineering, the software development world is at about \nthe same place the bridge builders were when the common strategy was to \nbuild a bridge and then roll something heavy over it. If it stayed up, it was \na good bridge. If not, well, time to go back to the drawing board. Over the \npast few thousand years, engineers have developed mathematics and physics \nthey can use for a structural solution without having to build it to see what \nit does. We don\u2019t have anything like that in software, and perhaps never will \nbecause software is in fact very different. For a deep-dive exploration of the \ncomparison between software \u201cengineering\u201d and regular engineering, \u201cWhat \nis Software Design?\u201d, written by Jack Reeves in C++ Journal in 1992, is a clas-\nsic.* Even though it was written almost two decades ago, it is still remarkably \naccurate. Reeves painted a gloomy picture in this comparison, but the thing \nthat was missing in 1992 was a strong testing ethos for software.\n\n* http://www.developerdotstar.com/mag/articles/reeves_design.html\n\n[image: image81.jpg]  \n\nhttp://www.developerdotstar.com/mag/articles/reeves_design.html\n\n\n167Collective Wisdom from the Experts\n\nTesting \u201chard\u201d things is tough because you have to build them to test them, \nwhich discourages speculative building just to see what will happen. But the \nbuilding process in software is ridiculously cheap. We\u2019ve developed an entire \necosystem of tools that make it easy to do just that: unit testing, mock objects, \ntest harnesses, and lots of other stuff. Other engineers would love to be able \nto build something and test it under realistic conditions. As software devel-\nopers, we should embrace testing as the primary (but not the only) verifica-\ntion mechanism for software. Rather than waiting for some sort of calculus for \nsoftware, we already have the tools at our disposal to ensure good engineering \npractices. Viewed in this light, we now have ammunition against managers \nwho tell us \u201cwe don\u2019t have time to test.\u201d A bridge builder would never hear \nfrom his boss, \u201cDon\u2019t bother doing structural analysis on that building\u2014we \nhave a tight deadline.\u201d The recognition that testing is indeed the path to repro-\nducibility and quality in software allows us as developers to push back on \narguments against it as professionally irresponsible.\n\nTesting takes time, just like structural analysis takes time. Both activities ensure \nthe quality of the end product. It\u2019s time for software developers to take up the \nmantle of responsibility for what they produce. Testing alone isn\u2019t sufficient, \nbut it is necessary. Testing is the engineering rigor of software development.\n\n\n\n168 97 Things Every Programmer Should Know\n\nThinking in States\nNiclas Nilsson\n\nPEOPLE iN THE REAL WORLD HAVE A WEiRD RELATiONSHiP WiTH STATE. \n\nThis morning, I stopped by the local store to prepare for another day of con-\nverting caffeine to code. Since my favorite way of doing that is by drinking \nlattes, and I couldn\u2019t find any milk, I asked the clerk.\n\n\u201cSorry, we\u2019re super-duper, mega\u2013out of milk.\u201d\n\nTo a programmer, that\u2019s an odd statement. You\u2019re either out of milk, or you\u2019re \nnot. There is no scale when it comes to being out of milk. Perhaps she was try-\ning to tell me that they\u2019d be out of milk for a week, but the outcome was the \nsame\u2014espresso day for me.\n\nIn most real-world situations, people\u2019s relaxed attitude toward state is not an \nissue. Unfortunately, however, many programmers are quite vague about state, \ntoo\u2014and that is a problem.\n\nConsider a simple webshop that only accepts credit cards and does not invoice \ncustomers, with an Order class containing this method:\n\npublic boolean isComplete() {\n\nreturn isPaid() && hasShipped();\n\n}\n\nReasonable, right? Well, even if the expression is nicely extracted into a method \ninstead of copy \u2019n\u2019 pasted everywhere, the expression shouldn\u2019t exist at all. The \nfact that it does highlights a problem. Why? Because an order can\u2019t be shipped \nbefore it\u2019s paid. Thereby, hasShipped can\u2019t be true unless isPaid is true, which \nmakes part of the expression redundant. You may still want isComplete for \nclarity in the code, but then it should look like this:\n\npublic boolean isComplete() {\n\nreturn hasShipped();\n\n}\n\n[image: image82.jpg]  \n\n\n\n169Collective Wisdom from the Experts\n\nIn my work, I see both missing checks and redundant checks all the time. This \nexample is tiny, but when you add cancellation and repayment, it\u2019ll become \nmore complex, and the need for good state handling increases. In this case, an \norder can only be in one of three distinct states:\n\n\u2022 In progress: Can add or remove items. Can\u2019t ship.\n\n\u2022 Paid: Can\u2019t add or remove items. Can be shipped.\n\n\u2022 Shipped: Done. No more changes accepted. \n\nThese states are important, and you need to check that you\u2019re in the expected \nstate before doing operations, and that you only move to a legal state from where \nyou are. In short, you have to protect your objects carefully, in the right places.\n\nBut how do you begin thinking in states? Extracting expressions to meaningful \nmethods is a very good start, but it is just a start. The foundation is to under-\nstand state machines. I know you may have bad memories from CS class, but \nleave them behind. State machines are not particularly hard. Visualize them to \nmake them simple to understand and easy to talk about. Test-drive your code \nto unravel valid and invalid states and transitions and to keep them correct. \nStudy the State pattern. When you feel comfortable, read up on Design by \nContract. It helps you ensure a valid state by validating incoming data and the \nobject itself on entry and exit of each public method.\n\nIf your state is incorrect, there\u2019s a bug, and you risk trashing data if you don\u2019t \nabort. If you find the state checks to be noise, learn how to use a tool, code \ngeneration, weaving, or aspects to hide them. Regardless of which approach \nyou pick, thinking in states will make your code simpler and more robust.\n\n\n\n170 97 Things Every Programmer Should Know\n\nTwo Heads Are \nOften Better \nThan One\nAdrian Wible\n\nPROGRAMMiNG REqUiRES DEEP THOUGHT, and deep thought requires soli-\ntude. So goes the programmer stereotype.\n\nThis \u201clone wolf \u201d approach to programming has been giving way to a more col-\nlaborative approach, which, I would argue, improves quality, productivity, and \njob satisfaction for programmers. This approach has developers working more \nclosely with one another and also with nondevelopers\u2014business and systems \nanalysts, quality assurance professionals, and users.\n\nWhat does this mean for developers? Being the expert technologist is no longer \nsufficient. You must become effective at working with others.\n\nCollaboration is not about asking and answering questions or sitting in meet-\nings. It\u2019s about rolling up your sleeves with someone else to jointly attack work.\n\nI\u2019m a big fan of pair programming. You might call this \u201cextreme collaboration.\u201d \nAs a developer, my skills grow when I pair. If I am weaker than my pairing \npartner in the domain or technology, I clearly learn from his or her experience. \nWhen I am stronger in some aspect, I learn more about what I know and don\u2019t \nknow by having to explain myself. Invariably, we both bring something to the \ntable and learn from each other.\n\nWhen pairing, we each bring our collective programming experiences\u2014\ndomain as well as technical\u2014to the problem at hand and can bring unique \ninsight and experience into writing software effectively and efficiently. Even \nin cases of extreme imbalance in domain or technical knowledge, the more \nexperienced participant invariably learns something from the other\u2014perhaps \na new keyboard shortcut, or exposure to a new tool or library. For the less-\nexperienced member of the pair, this is a great way to get up to speed.\n\n[image: image83.jpg]  \n\n\n\n171Collective Wisdom from the Experts\n\nPair programming is popular with, though not exclusive to, proponents of \nagile software development. Some who object to pairing ask, \u201cWhy should I \npay two programmers to do the work of one?\u201d My response is that, indeed, \nyou should not. I argue that pairing increases quality, understanding of the \ndomain and technology, and techniques (like IDE tricks), and mitigates the \nimpact of lottery risk (one of your expert developers wins the lottery and \nquits the next day).\n\nWhat is the long-term value of learning a new keyboard shortcut? How do we \nmeasure the overall quality improvement to the product resulting from pairing? \nHow do we measure the impact of your partner not letting you pursue a dead-\nend approach to solving a difficult problem? One study cites an increase of 40% \nin effectiveness and speed.* What is the value of mitigating your \u201clottery risk\u201d? \nMost of these gains are difficult to measure.\n\nWho should pair with whom? If you\u2019re new to the team, it\u2019s important to find \na team member who is knowledgeable. Just as important, find someone who \nhas good interpersonal and coaching skills. If you don\u2019t have much domain \nexperience, pair with a team member who is an expert in the domain.\n\nIf you are not convinced, experiment: collaborate with your colleagues. Pair on \nan interesting, gnarly problem. See how it feels. Try it a few times.\n\n* J. T. Nosek, \u201cThe Case for Collaborative Programming,\u201d Communications of the ACM, March 1998\n\n\n\n172 97 Things Every Programmer Should Know\n\nTwo Wrongs Can \nMake a Right (and \nAre Difficult to Fix)\nAllan Kelly\n\nCODE NEVER LiES, BUT iT CAN CONTRADiCT iTSELF. Some contradictions \nlead to those \u201cHow can that possibly work?\u201d moments.\n\nIn an interview,* the principal designer of the Apollo 11 Lunar Module soft-\nware, Allan Klumpp, disclosed that the software controlling the engines con-\ntained a bug that should have made the lander unstable. However, another bug \ncompensated for the first, and the software was used for both Apollo 11 and 12 \nMoon landings before either bug was found or fixed.\n\nConsider a function that returns a completion status. Imagine that it returns \nfalse when it should return true. Now imagine that the calling function \nneglects to check the return value. Everything works fine until one day some-\none notices the missing check and inserts it.\n\nOr consider an application that stores state as an XML document. Imagine \nthat one of the nodes is incorrectly written as TimeToLive instead of TimeToDie, \nas the documentation says it should. Everything appears fine while the writer \ncode and the reader code both contain the same error. But fix one, or add a \nnew application reading the same document, and the symmetry is broken, as \nwell as the code.\n\nWhen two defects in the code create one visible fault, the methodical approach \nto fixing faults can itself break down. The developer gets a bug report, finds the \ndefect, fixes it, and retests. The reported fault still occurs, however, because a \nsecond defect is at work. So the first fix is removed, the code inspected until \nthe second underlying defect is found, and a fix applied for that. But the first \ndefect has returned, the reported fault is still seen, and so the second fix is \nrolled back. The process repeats, but now the developer has dismissed two \npossible fixes and is looking to make a third that will never work.\n\n* http://www.netjeff.com/humor/item.cgi?file=ApolloComputer\n\n[image: image84.jpg]  \n\nhttp://www.netjeff.com/humor/item.cgi?file=ApolloComputer\n\n\n173Collective Wisdom from the Experts\n\nThe interplay between two code defects that appear as one visible fault not \nonly makes it hard to fix the problem, but also leads developers down blind \nalleys, only to find they tried the right answers early on.\n\nThis doesn\u2019t happen only in code: the problem also exists in written require-\nments documents. And it can spread, virally, from one place to another. An \nerror in the code compensates for an error in the written description.\n\nIt can spread to people, too: users learn that when the application says Left, it \nmeans Right, so they adjust their behavior accordingly. They even pass it on \nto new users: \u201cRemember when that applications says \u2018click the left button,\u2019 it \nreally means the button on the right.\u201d Fix the bug, and suddenly the users need \nretraining.\n\nSingle wrongs can be easy to spot and easy to fix. It is the problems with multi-\nple causes, needing multiple changes, that are harder to resolve. In part, this is \nbecause easy problems are so easily fixed that people tend to fix them relatively \nquickly and store up the more difficult problems for a later date.\n\nThere is no simple advice for how to address faults arising from sympathetic \ndefects. Awareness of the possibility, a clear head, and a willingness to consider \nall possibilities are needed.\n\n\n\n174 97 Things Every Programmer Should Know\n\nUbuntu Coding \nfor Your Friends\nAslam Khan\n\nSO OFTEN, WE WRiTE CODE iN iSOLATiON and that code reflects our per-\nsonal interpretation of a problem, as well as a very personalized solution. We \nmay be part of the team, yet we are isolated, as is the team. We forget all too \neasily that this code created in isolation will be executed, used, extended, and \nrelied upon by others. It is easy to overlook the social side of software creation. \nCreating software is a technical exercise mixed into a social exercise. We just \nneed to lift our heads more often to realize that we are not working in isola-\ntion, and we have shared responsibility for increasing the probability of suc-\ncess for everyone, not just the development team.\n\nYou can write good-quality code in isolation, all the while lost in self. From \none perspective, that is an egocentric approach (not ego as in arrogant, but \nego as in personal). It is also a Zen view and it is about you, in that moment of \ncreating code. I always try to live in the moment because it helps me get closer \nto good quality, but then I live in my moment. What about the moment of my \nteam? Is my moment the same as the team\u2019s moment?\n\nIn Zulu, the philosophy of Ubuntu is summed up as \u201cUmuntu ngumuntu \nngabantu,\u201d which roughly translates to \u201cA person is a person through (other) \npersons.\u201d I get better because you make me better through your good actions. \nThe flip side is that you get worse at what you do when I am bad at what I \ndo. Among developers, we can narrow it down to \u201cA developer is a developer \nthrough (other) developers.\u201d If we take it down to the metal, then \u201cCode is \ncode through (other) code.\u201d\n\n[image: image85.jpg]  \n\n\n\n175Collective Wisdom from the Experts\n\nThe quality of the code I write affects the quality of the code you write. What if \nmy code is of poor quality? Even if you write very clean code, it is at the points \nwhere you use my code that your code quality will degrade to close to the \nquality of my code. You can apply many patterns and techniques to limit the \ndamage, but the damage has already been done. I have caused you to do more \nthan what you needed to do, simply because I did not think about you when I \nwas living in my moment.\n\nI may consider my code to be clean, but I can still make it better just by Ubuntu \ncoding. What does Ubuntu code look like? It looks just like good, clean code. \nIt is not about the code, the artifact. It is about the act of creating that artifact. \nCoding for your friends, with Ubuntu, will help your team live your values and \nreinforce your principles. The next person that touches your code, in whatever \nway, will be a better person and a better developer.\n\nZen is about the individual. Ubuntu is about Zen for a group of people. Very, \nvery rarely do we create code for ourselves alone.\n\n\n\n176 97 Things Every Programmer Should Know\n\nThe Unix Tools \nAre Your Friends\nDiomidis Spinellis\n\niF, ON MY WAY TO ExiLE ON A DESERT iSLAND, I had to choose between an \nIDE and the Unix toolchest, I\u2019d pick the Unix tools without a second thought. \nHere are the reasons why you should become proficient with Unix tools.\n\nFirst, IDEs target specific languages, while Unix tools can work with anything \nthat appears in textual form. In today\u2019s development environment, where new \nlanguages and notations spring up every year, learning to work in the Unix \nway is an investment that will pay off time and again.\n\nFurthermore, while IDEs offer just the commands their developers conceived, \nwith Unix tools you can perform any task you can imagine. Think of them \nas (classic pre-Bionicle) Lego blocks: you create your own commands simply \nby combining the small but versatile Unix tools. For instance, the following \nsequence is a text-based implementation of Cunningham\u2019s signature analysis\u2014a \nsequence of each file\u2019s semicolons, braces, and quotes, which can reveal a lot \nabout the file\u2019s contents:\n\nfor i in *.java; do \n\necho -n \"$i: \"\n\nsed 's/[^\"{};]//g' $i | tr -d '\\n'\n\necho\n\ndone\n\nIn addition, each IDE operation you learn is specific to that given task\u2014for \ninstance, adding a new step in a project\u2019s debug build configuration. By con-\ntrast, sharpening your Unix tool skills makes you more effective at any task. \nAs an example, I\u2019ve employed the sed tool used in the preceding command \nsequence to morph a project\u2019s build for cross-compiling on multiple processor \narchitectures.\n\n[image: image86.jpg]  \n\n\n\n177Collective Wisdom from the Experts\n\nUnix tools were developed in an age when a multiuser computer had 128KB \nof RAM. The ingenuity that went into their design means that nowadays they \ncan handle huge data sets extremely efficiently. Most tools work like filters, \nprocessing just a single line at the time, meaning that there is no upper limit in \nthe amount of data they can handle. You want to search for the number of edits \nstored in the half-terabyte English Wikipedia dump? A simple invocation of\n\ngrep '<revision>' | wc \u2013l \n\nwill give you the answer without sweat. If you find a command sequence gen-\nerally useful, you can easily package it into a shell script, using some uniquely \npowerful programming constructs, such as piping data into loops and condi-\ntionals. Even more impressively, Unix commands executing as pipelines, like \nthe preceding one, will naturally distribute their load among the many pro-\ncessing units of modern multicore CPUs.\n\nThe small-is-beautiful provenance and open source implementations of the \nUnix tools make them ubiquitously available, even on resource-constrained \nplatforms, like my set-top media player or DSL router. Such devices are \nunlikely to offer a powerful graphical user interface, but they often include the \nBusyBox application, which provides the most commonly used tools. And if \nyou are developing on Windows, the Cygwin environment offers you all imag-\ninable Unix tools, both as executables and in source code form.\n\nFinally, if none of the available tools matches your needs, it\u2019s very easy to extend \nthe world of the Unix tools. Just write a program (in any language you fancy) \nthat plays by a few simple rules: your program should perform just a single \ntask; it should read data as text lines from its standard input; and it should dis-\nplay its results unadorned by headers and other noise on its standard output. \nParameters affecting the tool\u2019s operation are given in the command line. Fol-\nlow these rules, and \u201cyours is the Earth and everything that\u2019s in it.\u201d\n\n\n\n178 97 Things Every Programmer Should Know\n\nUse the Right \nAlgorithm and \nData Structure\nJan Christiaan \u201cJC\u201d van Winkel\n\nA big bank with many branch offices complained that the new computers it \nhad bought for the tellers were too slow. This was in the time before everyone \nused electronic banking, and ATMs were not as widespread as they are now. \nPeople would visit the bank far more often, and the slow computers were \nmaking the people queue up. Consequently, the bank threatened to break its \ncontract with the vendor.\n\nThe vendor sent a performance analysis and tuning specialist to determine \nthe cause of the delays. He soon found one specific program running on the \nterminal that consumed almost all the CPU capacity. Using a profiling tool, he \nzoomed in on the program and he could see the function that was the culprit. \nThe source code read:\n\nfor (i=0; i<strlen(s); ++i) {\n\n   if (... s[i] ...) ...\n\n   }\n\nAnd string s was, on average, thousands of characters long. The code (writ-\nten by the bank) was quickly changed, and the bank tellers lived happily ever \nafter.\u2026\n\nSHOULDN\u2019T THE PROGRAMMER have done better than to use code that \nneedlessly scaled quadratically?\n\nEach call to strlen traversed every one of the many thousand characters in \nthe string to find its terminating null character. The string, however, never \nchanged. By determining its length in advance, the programmer could have \nsaved thousands of calls to strlen (and millions of loop executions):\n\nn=strlen(s);\n\nfor (i=0; i<n; ++i) {\n\nif (... s[i] ...) ...\n\n}\n\n[image: image87.jpg]  \n\n\n\n179Collective Wisdom from the Experts\n\nEveryone knows the adage \u201cfirst make it work, then make it work fast\u201d to avoid \nthe pitfalls of micro-optimization. But the preceding example would almost \nmake you believe that the programmer followed the Machiavellian adagio \n\u201cfirst make it work slowly.\u201d\n\nThis thoughtlessness is something you may come across more than once. And \nit is not just a \u201cdon\u2019t reinvent the wheel\u201d thing. Sometimes novice program-\nmers just start typing away without really thinking, and suddenly they have \n\u201cinvented\u201d bubble sort. They may even be bragging about it.\n\nThe other side of choosing the right algorithm is the choice of data structure. It \ncan make a big difference: using a linked list for a collection of a million items \nyou want to search through\u2014compared to a hashed data structure or a binary \ntree\u2014will have a big impact on the user\u2019s appreciation of your programming.\n\nProgrammers should not reinvent the wheel, and should use existing libraries \nwhere possible. But to be able to avoid problems like the bank\u2019s, they should \nalso be educated about algorithms and how they scale. Is it just the eye candy \nin modern text editors that makes them as slow as old-school programs like \nWordStar in the 1980s? Many say reuse in programming is paramount. Above \nall, however, programmers should know when, what, and how to reuse. To do \nthat, they should have knowledge of the problem domain and of algorithms \nand data structures.\n\nA good programmer should also know when to use an abominable algorithm. \nFor example, if the problem domain dictates that there can never be more \nthan five items (like the number of dice in a Yahtzee game), you know that you \nalways have to sort at most five items. In that case, bubble sort might actually \nbe the most efficient way to sort the items. Every dog has its day.\n\nSo, read some good books\u2014and make sure you understand them. And if you \nreally read Donald Knuth\u2019s The Art of Computer Programming (Addison-Wesley \nProfessional), well, you might even be lucky: find a mistake by the author, and \nyou\u2019ll earn one of Don Knuth\u2019s hexadecimal dollar ($2.56) checks.\n\n\n\n180 97 Things Every Programmer Should Know\n\nVerbose Logging \nWill Disturb \nYour Sleep\nJohannes Brodwall\n\nWHEN i ENCOUNTER A SYSTEM that has already been in development or pro-\nduction for a while, the first sign of real trouble is always a dirty log. You know \nwhat I\u2019m talking about: when clicking a single link on a normal flow on a web \npage results in a deluge of messages in the only log that the system provides. \nToo much logging can be as useless as none at all.\n\nIf your systems are like mine, when your job is done, someone else\u2019s job is \njust starting. After the system has been developed, it will hopefully live a long \nand prosperous life serving customers (if you\u2019re lucky). How will you know if \nsomething goes wrong when the system is in production, and how will you \ndeal with it?\n\nMaybe someone monitors your system for you, or maybe you will monitor it \nyourself. Either way, the logs will probably be part of the monitoring. If some-\nthing shows up and you have to be woken up to deal with it, you want to make \nsure there\u2019s a good reason for it. If my system is dying, I want to know. But if \nthere\u2019s just a hiccup, I\u2019d rather enjoy my beauty sleep.\n\nFor many systems, the first indication that something is wrong is a log mes-\nsage being written to some log. Mostly, this will be the error log. So do yourself \na favor: make sure from day one that if something is logged in the error log, \nyou\u2019re willing to have someone call and wake you in the middle of the night \nabout it. If you can simulate load on your system during system testing, look-\ning at a noise-free error log is also a good first indication that your system is \nreasonably robust\u2014or an early warning if it\u2019s not.\n\n[image: image88.jpg]  \n\n\n\n181Collective Wisdom from the Experts\n\nDistributed systems add another level of complexity. You have to decide how \nto deal with an external dependency failing. If your system is very distributed, \nthis may be a common occurrence. Make sure your logging policy takes this \ninto account.\n\nIn general, the best indication that everything is all right is that the messages \nat a lower priority are ticking along happily. I want about one INFO-level log \nmessage for every significant application event.\n\nA cluttered log is an indication that the system will be hard to control once it \nreaches production. If you don\u2019t expect anything to show up in the error log, it \nwill be much easier to know what to do when something does show up.\n\n\n\n182 97 Things Every Programmer Should Know\n\nWET Dilutes \nPerformance \nBottlenecks\nKirk Pepperdine\n\nTHE iMPORTANCE OF THE DRY PRiNCiPLE (Don\u2019t Repeat Yourself) is that \nit codifies the idea that every piece of knowledge in a system should have a \nsingular representation. In other words, knowledge should be contained in \na single implementation. The antithesis of DRY is WET (Write Every Time). \nOur code is WET when knowledge is codified in several different implemen-\ntations. The performance implications of DRY versus WET become very clear \nwhen you consider their numerous effects on a performance profile.\n\nLet\u2019s start by considering a feature of our system, say X, that is a CPU bottle-\nneck. Let\u2019s say feature X consumes 30% of the CPU. Now let\u2019s say that feature \nX has 10 different implementations. On average, each implementation will \nconsume 3% of the CPU. As this level of CPU utilization isn\u2019t worth worrying \nabout if we are looking for a quick win, it is likely that we\u2019d miss that this fea-\nture is our bottleneck. However, let\u2019s say that we somehow recognized feature \nX as a bottleneck. We are now left with the problem of finding and fixing every \nsingle implementation. With WET, we have 10 different implementations that \nwe need to find and fix. With DRY, we would clearly see the 30% CPU utiliza-\ntion and would have a tenth of the code to fix. And did I mention that we don\u2019t \nhave to spend time hunting down each implementation?\n\nThere is one use case where we are often guilty of violating DRY: our use of \ncollections. A common technique to implement a query would be to iterate \nover the collection and then apply the query in turn to each element:\n\npublic class UsageExample {\n\nprivate ArrayList<Customer> allCustomers = new ArrayList<Customer>();\n\n// ...\n\npublic ArrayList<Customer> findCustomersThatSpendAtLeast(Money amount) {\n\nArrayList<Customer> customersOfInterest = new ArrayList<Customer>();\n\nfor (Customer customer: allCustomers) {\n\nif (customer.spendsAtLeast(amount))\n\n[image: image89.jpg]  \n\n\n\n183Collective Wisdom from the Experts\n\ncustomersOfInterest.add(customer);\n\n}\n\nreturn customersOfInterest;\n\n}\n\n}\n\nBy exposing this raw collection to clients, we have violated encapsulation. This \nnot only limits our ability to refactor, but it also forces users of our code to vio-\nlate DRY by having each of them reimplement potentially the same query. This \nsituation can easily be avoided by removing the exposed raw collections from \nthe API. In this example, we can introduce a new, domain-specific collective \ntype called CustomerList. This new class is more semantically in line with our \ndomain. It will act as a natural home for all our queries.\n\nHaving this new collection type will also allow us to easily see if these queries \nare a performance bottleneck. By incorporating the queries into the class, we \neliminate the need to expose representation choices, such as ArrayList, to our \nclients. This gives us the freedom to alter these implementations without fear \nof violating client contracts:\n\npublic class CustomerList {\n\nprivate ArrayList<Customer> customers = new ArrayList<Customer>();\n\nprivate SortedList<Customer> customersSortedBySpendingLevel =  \n        new SortedList<Customer)();\n\n// ...\n\npublic CustomerList findCustomersThatSpendAtLeast(Money amount) {\n\nreturn new CustomerList( \n            customersSortedBySpendingLevel.elementsLargerThan(amount));\n\n}\n\n}\n\npublic class UsageExample {\n\npublic static void main(String[] args) {\n\nCustomerList customers = new CustomerList();\n\n// ...\n\nCustomerList customersOfInterest =  \n            customers.findCustomersThatSpendAtLeast(someMinimalAmount);\n\n// ...\n\n}\n\n}\n\nIn this example, adherence to DRY allowed us to introduce an alternate index-\ning scheme with SortedList keyed on our customers\u2019 level of spending. More \nimportant than the specific details of this particular example, following DRY \nhelped us to find and repair a performance bottleneck that would have been \nmore difficult to find had the code been WET.\n\n\n\n184 97 Things Every Programmer Should Know\n\nWhen Programmers \nand Testers \nCollaborate\nJanet Gregory\n\nSOMETHiNG MAGiCAL HAPPENS when testers and programmers start to col-\nlaborate. There is less time spent sending bugs back and forth through the \ndefect tracking system. Less time is wasted trying to figure out whether some-\nthing is really a bug or a new feature, and more time is spent developing good \nsoftware to meet customer expectations. There are many opportunities for \nstarting collaboration before coding even begins.\n\nTesters can help customers write and automate acceptance tests using the lan-\nguage of their domain with tools such as Fit (Framework for Integrated Test). \nWhen these tests are given to the programmers before the coding begins, the \nteam is practicing acceptance test\u2013driven development (ATDD). The program-\nmers write the fixtures to run the tests, and then code to make the tests pass. \nThese tests then become part of the regression suite. When this collaboration \noccurs, the functional tests are completed early, allowing time for exploratory \ntesting on edge conditions or through workflows of the bigger picture.\n\nWe can take it one step further. As a tester, I can supply most of my testing \nideas before the programmers start coding a new feature. When I ask the pro-\ngrammers if they have any suggestions, they almost always provide me with \ninformation that helps me with better test coverage, or helps me to avoid \nspending a lot of time on unnecessary tests. Often, we have prevented defects \nbecause the tests clarify many of the initial ideas. For example, in one project I \nwas on, the Fit tests I gave the programmers displayed the expected results of \n\n[image: image90.jpg]  \n\n\n\n185Collective Wisdom from the Experts\n\na query to respond to a wildcard search. The programmer had fully intended \nto code only complete word searches. We were able to talk to the customer and \ndetermine the correct interpretation before coding started. By collaborating, \nwe prevented the defect, which saved us both a lot of wasted time.\n\nProgrammers can collaborate with testers to create successful automation as \nwell. They understand good coding practices and can help testers set up a \nrobust test automation suite that works for the whole team. I have often seen \ntest automation projects fail because the tests are poorly designed. The tests try \nto test too much, or the testers haven\u2019t understood enough about the technol-\nogy to be able to keep tests independent. The testers are often the bottleneck, \nso it makes sense for programmers to work with them on tasks like automa-\ntion. Working with the testers to understand what can be tested early, perhaps \nby providing a simple tool, will give the programmers another cycle of feed-\nback that will help them deliver better code in the long run.\n\nWhen testers stop thinking that their only job is to break the software and find \nbugs in the programmers\u2019 code, programmers stop thinking that testers are \n\u201cout to get them,\u201d and are more open to collaboration. When programmers \nstart realizing that they are responsible for building quality into their code, \ntestability of the code is a natural by-product, and the team can automate more \nof the regression tests together. The magic of successful teamwork begins.\n\n\n\n186 97 Things Every Programmer Should Know\n\nWrite Code As If You \nHad to Support It for \nthe Rest of Your Life\nYuriy Zubarev\n\nYOU COULD ASK 97 PEOPLE what every programmer should know and do, \nand you might get 97 distinct answers. This could be both overwhelming and \nintimidating at the same time. All advice is good, all principles are sound, and \nall stories are compelling, but where do you start? More important, once you \nhave started, how do you keep up with all the best practices you\u2019ve learned, \nand how do you make them an integral part of your programming practice?\n\nI think the answer lies in your frame of mind or, more plainly, in your atti-\ntude. If you don\u2019t care about your fellow developers, testers, managers, sales \nand marketing people, and end users, then you will not be driven to employ \ntest-driven development or write clear comments in your code, for example. \nI think there is a simple way to adjust your attitude and always be driven to \ndeliver the best quality products:\n\nWrite code as if you had to support it for the rest of your life. \n\nThat\u2019s it. If you accept this notion, many wonderful things will happen. If you \nwere to accept that any of your previous or current employers had the right \nto call you in the middle of the night, asking you to explain the choices you \nmade while writing the fooBar method, you would gradually improve toward \nbecoming an expert programmer. You would naturally want to come up with \nbetter variable and method names. You would stay away from blocks of code \ncomprising hundreds of lines. You would seek, learn, and use design patterns. \nYou would write comments, test your code, and refactor continually. Support-\ning all the code you\u2019d ever written for the rest of your life should also be a \nscalable endeavor. You would therefore have no choice but to become better, \nsmarter, and more efficient.\n\n[image: image91.jpg]  \n\n\n\n187Collective Wisdom from the Experts\n\nIf you reflect on it, the code you wrote many years ago still influences your \ncareer, whether you like it or not. You leave a trail of your knowledge, attitude, \ntenacity, professionalism, level of commitment, and degree of enjoyment with \nevery method, class, and module you design and write. People will form opin-\nions about you based on the code that they see. If those opinions are constantly \nnegative, you will get less from your career than you hoped. Take care of your \ncareer, of your clients, and of your users with every line of code\u2014write code as \nif you had to support it for the rest of your life.\n\n\n\n188 97 Things Every Programmer Should Know\n\nWrite Small \nFunctions Using \nExamples\nKeith Braithwaite\n\nWE WOULD LiKE TO WRiTE CODE THAT iS CORRECT, and have evidence on \nhand that it is correct. It can help with both issues to think about the \u201csize\u201d of a \nfunction. Not in the sense of the amount of code that implements a function\u2014\nalthough that is interesting\u2014but rather the size of the mathematical function \nthat our code manifests.\n\nFor example, in the game of Go there is a condition called atari in which a \nplayer\u2019s stones may be captured by her opponent: a stone with two or more free \nspaces adjacent to it (called liberties) is not in atari. It can be tricky to count \nhow many liberties a stone has, but determining atari is easy if that is known. \nWe might begin by writing a function like this:\n\nboolean atari(int libertyCount)\n\nlibertyCount < 2\n\nThis is larger than it looks. A mathematical function can be understood as a \nset, some subset of the Cartesian product of the sets that are its domain (here, \nint) and range (here, boolean). If those sets of values were the same size as in \nJava, then there would be 2L*(Integer.MAX_VALUE+(\u20131L*Integer.MIN_VALUE)+1L) \nor 8,589,934,592 members in the set int\u00d7boolean. Half of these are members \nof the subset that is our function, so to provide complete evidence that our \nfunction is correct, we would need to check around 4.3\u00d7109 examples.\n\n[image: image70.jpg]\n\n189Collective Wisdom from the Experts\n\nThis is the essence of the claim that tests cannot prove the absence of bugs. \nTests can demonstrate the presence of features, though. But still we have this \nissue of size.\n\nThe problem domain helps us out. The nature of Go means that the number \nof liberties of a stone is not any int, but exactly one of {1,2,3,4}. So we could \nalternatively write:\n\nLibertyCount = {1,2,3,4} \n\nboolean atari(LibertyCount libertyCount)\n\nlibertyCount == 1\n\nThis is much more tractable: the function computed is now a set with at most \neight members. In fact, four checked examples would constitute evidence of \ncomplete certainty that the function is correct. This is one reason why it\u2019s a \ngood idea to use types closely related to the problem domain to write pro-\ngrams, rather than native types. Using domain-inspired types can often make \nour functions much smaller. One way to find out what those types should be \nis to find the examples to check in problem domain terms, before writing the \nfunction.\n\n\n\n190 97 Things Every Programmer Should Know\n\nWrite Tests \nfor People\nGerard Meszaros\n\nYOU ARE WRiTiNG AUTOMATED TESTS for some or all of your production \ncode. Congratulations! You are writing your tests before you write the code? \nEven better!! Just doing this makes you one of the early adopters on the lead-\ning edge of software engineering practice. But are you writing good tests? How \ncan you tell? One way is to ask, \u201cWho am I writing the tests for?\u201d If the answer \nis \u201cFor me, to save me the effort of fixing bugs\u201d or \u201cFor the compiler, so they \ncan be executed,\u201d then the odds are you aren\u2019t writing the best possible tests. So \nwho should you be writing the tests for? For the person trying to understand \nyour code.\n\nGood tests act as documentation for the code they are testing. They describe \nhow the code works. For each usage scenario, the test(s):\n\n\u2022 Describe the context, starting point, or preconditions that must be satisfied\n\n\u2022 Illustrate how the software is invoked\n\n\u2022 Describe the expected results or postconditions to be verified \n\nDifferent usage scenarios will have slightly different versions of each of \nthese. The person trying to understand your code should be able to look at \na few tests, and by comparing these three parts of the tests in question, be \nable to see what causes the software to behave differently. Each test should \nclearly illustrate the cause-and-effect relationship among these three parts. \n\n[image: image92.jpg]  \n\n\n\n191Collective Wisdom from the Experts\n\nThis implies that what isn\u2019t visible in the test is just as important as what is visible. \nToo much code in the test distracts the reader with unimportant trivia. When-\never possible, hide such trivia behind meaningful method calls\u2014the Extract \nMethod refactoring is your best friend. And make sure you give each test a \nmeaningful name that describes the particular usage scenario so the test reader \ndoesn\u2019t have to reverse-engineer each test to understand what the various sce-\nnarios are. Between them, the names of the test class and class method should \ninclude at least the starting point and how the software is being invoked. This \nallows the test coverage to be verified via a quick scan of the method names. It \ncan also be useful to include the expected results in the test method names as \nlong as this doesn\u2019t cause the names to be too long to see or read.\n\nIt is also a good idea to test your tests. You can verify that they detect the errors \nyou think they detect by inserting those errors into the production code (your \nown private copy that you\u2019ll throw away, of course). Make sure they report \nerrors in a helpful and meaningful way. You should also verify that your tests \nspeak clearly to a person trying to understand your code. The only way to \ndo this is to have someone who isn\u2019t familiar with your code read your tests \nand tell you what she learned. Listen carefully to what she says. If she didn\u2019t \nunderstand something clearly, it probably isn\u2019t because she isn\u2019t very bright. It \nis more likely that you weren\u2019t very clear. (Go ahead and reverse the roles by \nreading her tests!)\n\n\n\n192 97 Things Every Programmer Should Know\n\nYou Gotta Care \nAbout the Code\nPete Goodliffe\n\niT DOESN\u2019T TAKE SHERLOCK HOLMES to work out that good programmers \nwrite good code. Bad programmers\u2026don\u2019t. They produce monstrosities that \nthe rest of us have to clean up. You want to write the good stuff, right? You \nwant to be a good programmer.\n\nGood code doesn\u2019t pop out of thin air. It isn\u2019t something that happens by luck \nwhen the planets align. To get good code, you have to work at it. Hard. And \nyou\u2019ll only get good code if you actually care about good code.\n\nGood programming is not born from mere technical competence. I\u2019ve seen \nhighly intellectual programmers who can produce intense and impressive \nalgorithms, who know their language standard by heart, but who write the \nmost awful code. It\u2019s painful to read, painful to use, and painful to modify. I\u2019ve \nseen more humble programmers who stick to very simple code, but who write \nelegant and expressive programs that are a joy to work with.\n\nBased on my years of experience in the software factory, I\u2019ve concluded that \nthe real difference between adequate programmers and great programmers is \nthis: attitude. Good programming lies in taking a professional approach, and \nwanting to write the best software you can, within the real-world constraints \nand pressures of the software factory.\n\nThe code to hell is paved with good intentions. To be an excellent programmer, you \nhave to rise above good intentions, and actually care about the code\u2014foster posi-\ntive perspectives and develop healthy attitudes. Great code is carefully crafted \nby master artisans, not thoughtlessly hacked out by sloppy programmers or \nerected mysteriously by self-professed coding gurus.\n\n[image: image28.jpg]\n\n193Collective Wisdom from the Experts\n\nYou want to write good code. You want to be a good programmer. So, you care \nabout the code:\n\n\u2022 In any coding situation, you refuse to hack something that only seems to \nwork. You strive to craft elegant code that is clearly correct (and has good \ntests to show that it is correct).\n\n\u2022 You write code that is discoverable (that other programmers can easily pick \nup and understand), that is maintainable (that you, or other programmers, \nwill be easily able to modify in the future), and that is correct (you take \nall steps possible to determine that you have solved the problem, not just \nmade it look like the program works).\n\n\u2022 You work well alongside other programmers. No programmer is an \nisland. Few programmers work alone; most work in a team of program-\nmers, either in a company environment or on an open source project. \nYou consider other programmers and construct code that others can \nread. You want the team to write the best software possible, rather than to \nmake yourself look clever.\n\n\u2022 Any time you touch a piece of code, you strive to leave it better than you \nfound it (either better structured, better tested, more understandable\u2026).\n\n\u2022 You care about code and about programming, so you are constantly \nlearning new languages, idioms, and techniques. But you apply them only \nwhen appropriate. \n\nFortunately, you\u2019re reading this collection of advice because you do care about \ncode. It interests you. It\u2019s your passion. Have fun programming. Enjoy cutting \ncode to solve tricky problems. Produce software that makes you proud.\n\n\n\n194 97 Things Every Programmer Should Know\n\nYour Customers \nDo Not Mean \nWhat They Say\nNate Jackson\n\ni\u2019VE NEVER MET A CUSTOMER YET that wasn\u2019t all too happy to tell me what \nthey wanted\u2014usually in great detail. The problem is that customers don\u2019t \nalways tell you the whole truth. They generally don\u2019t lie, but they speak in \ncustomer speak, not developer speak. They use their terms and their contexts. \nThey leave out significant details. They make assumptions that you\u2019ve been \nat their company for 20 years, just like they have. This is compounded by the \nfact that many customers don\u2019t actually know what they want in the first place! \nSome may have a grasp of the \u201cbig picture,\u201d but they are rarely able to com-\nmunicate the details of their vision effectively. Others might be a little lighter \non the complete vision, but they know what they don\u2019t want. So, how can you \npossibly deliver a software project to someone who isn\u2019t telling you the whole \ntruth about what they want? It\u2019s fairly simple. Just interact with them more.\n\nChallenge your customers early, and challenge them often. Don\u2019t simply restate \nwhat they told you they wanted in their words. Remember: they didn\u2019t mean \nwhat they told you. I often implement this advice by swapping out the cus-\ntomer\u2019s words in conversation with them and judging their reaction. You\u2019d be \namazed how many times the term customer has a completely different mean-\ning from the term client. Yet the guy telling you what he wants in his software \nproject will use the terms interchangeably and expect you to keep track as to \nwhich one he\u2019s talking about. You\u2019ll get confused, and the software you write \nwill suffer.\n\nDiscuss topics numerous times with your customers before you decide that \nyou understand what they need. Try restating the problem two or three times \n\n[image: image93.jpg]  \n\n\n\n195Collective Wisdom from the Experts\n\nwith them. Talk to them about the things that happen just before or just after \nthe topic you\u2019re talking about to get better context. If at all possible, have mul-\ntiple people tell you about the same topic in separate conversations. They will \nalmost always tell you different stories, which will uncover separate yet related \nfacts. Two people telling you about the same topic will often contradict each \nother. Your best chance for success is to hash out the differences before you \nstart your ultra-complex software crafting.\n\nUse visual aids in your conversations. This could be as simple as using a white-\nboard in a meeting, as easy as creating a visual mockup early in the design \nphase, or as complex as crafting a functional prototype. It is generally known \nthat using visual aids during a conversation helps lengthen our attention span \nand increases the retention rate of the information. Take advantage of this fact \nand set your project up for success.\n\nIn a past life, I was a \u201cmultimedia programmer\u201d on a team that produced glitzy \nprojects. A client of ours described her thoughts on the look and feel of the \nproject in great detail. The general color scheme discussed in the design meet-\nings indicated a black background for the presentation. We thought we had it \nnailed. Teams of graphic designers began churning out hundreds of layered \ngraphics files. Loads of time was spent molding the end product. On the day \nwe showed the client the fruits of our labor, we got some startling news. When \nshe saw the product, her exact words about the background color were, \u201cWhen \nI said black, I meant white.\u201d So, you see, it is never as clear as black and white.\n\n\n\n196 Contributors\n\nContributors\n\nAdrian Wible \n\nAdrian Wible\u2019s self-chosen title is \u201csoftware development catalyst.\u201d \nHe works for ThoughtWorks, Inc., mostly in project management \nroles, but strives to fend off suggestions of being \u201cpost-technical\u201d by \ngetting his hands dirty in software development from time to \n\ntime. He was indoctrinated in the Waterfall/SDLC mode of development as a \ndeveloper at IBM, and moved into project, people, and process management \nroles throughout his 20+ year career there and at Dell Computer Corporation. \nAdrian joined ThoughtWorks and discovered the Agile Manifesto (and XP, \nand Scrum, and\u2026) in 2005, and realized that project work and management \ncould be fun, exciting, and rewarding. He hasn\u2019t looked back since.\n\nAdrian can be reached at awible@thoughtworks.com.\n\n\u201cTwo Heads Are Often Better Than One,\u201d page 170\n\nAlan Griffiths \n\nAlan Griffiths has been developing software through many fash-\nions in development processes, technologies, and programming \nlanguages. During that time, he\u2019s delivered working software and \ndevelopment processes to a range of organizations, written for a \n\nnumber of magazines, spoken at several conferences, and made many friends. \nFirmly convinced that common sense is a rare and marketable commodity, he\u2019s \ncurrently working as an independent consultant through his company, Octopull \nLimited.\n\n\u201cDon\u2019t Rely on \u2018Magic Happens Here\u2019,\u201d page 58\n\n[image: image94.jpg]  \n\n[image: image95.jpg]  \n\nmailto:\nhttp://www.octopull.demon.co.uk/\nhttp://www.octopull.demon.co.uk/\n\n\n197Contributors\n\nAlex Miller \n\nAlex Miller is a tech lead and engineer at Terracotta, Inc., the \nmakers of the open source Java clustering product Terracotta. \nPrior to Terracotta, Alex worked at BEA Systems on the Aqua-\nLogic product line, and was chief architect at MetaMatrix. His \n\ninterests include Java, concurrency, distributed systems, query languages, and \nsoftware design.\n\nAlex enjoys writing his blog at http://tech.puredanger.com. Along with the \nother members of the Terracotta team, he is a contributing author to the 2008 \nrelease The Definitive Guide to Terracotta (Apress). Alex is a frequent speaker \nat user groups and conferences, and is the founder of the Strange Loop confer-\nence in St. Louis (http://thestrangeloop.com).\n\n\u201cStart from Yes,\u201d page 154\n\nAllan Kelly \n\nAllan Kelly is an accomplished software engineer who now works \non the management side of development. He helps software \nteams improve their performance and adopt Agile methods. \nBased in London, he provides coaching, training, and consulting \n\nto companies large and small.\n\nHe is a frequent contributor to journals and conferences and is the author of \nChanging Software Development: Learning to Be Agile (John Wiley & Sons). \nAllan holds a BSc degree in computing and an MBA in management. He is \ncurrently working on a book of business strategy patterns for software compa-\nnies. Find out more about Allan at http://www.allankelly.net.\n\n\u201cCheck Your Code First Before Looking to Blame Others,\u201d page 18\n\u201cTwo Wrongs Can Make a Right (and Are Difficult to Fix),\u201d page 172\n\nAnders Nor\u00e5s \n\nAnders Nor\u00e5s is a seasoned software developer and speaker. The \n\u201centerpriseyness\u201d of EJB drove him to Microsoft .NET back in \n2002. He quickly made a name for himself in the Microsoft com-\nmunity by using his Java experiences to get a head start on fellow \n\ndevelopers. In 2006, he got reacquainted with his lost love\u2014Java\u2014and today he \nis a polyglot, combining the best of both worlds to build better software. Anders \nis the founder of the Quaere project and a contributor to a few open source proj-\nects. He has given talks at many conferences and user group meetings and is \n\n[image: image96.jpg]  \n\n[image: image97.jpg]  \n\n[image: image98.jpg]  \n\nhttp://tech.puredanger.com\nhttp://thestrangeloop.com\nhttp://www.allankelly.net\n\n\n198 Contributors\n\nknown for talks with few slides and lots of code. Anders lives in Norway, where \nhe works for Objectware as its chief technology evangelist. You can read his \nblog at http://andersnoras.com.\n\n\u201cDon\u2019t Just Learn the Language, Understand Its Culture,\u201d page 54\n\nAnn Katrin Gagnat \n\nAnn Katrin Gagnat has four years of experience with Java and \nworks as a system developer at Steria AS in Norway. Her profes-\nsional interests include agile development, patterns, and writing \nreadable code.\n\n\u201cPair Program and Feel the Flow,\u201d page 128\n\nAslam Khan \n\nAslam Khan has spent more than half his life creating software. \nHe still believes the truth is in the code that gets executed, but \nthat belief is soberly balanced by his other core value\u2014that peo-\nple are more important than compilers. As a software architect \n\nand coach, Aslam spends his time helping teams to design and build better \nsoftware, while having fun and making worthwhile friendships. Aslam is part \nof the factor10 team, and he is also an editor for the architecture community at \nDZone. You can read his blog at http://aslamkhan.net.\n\n\u201cUbuntu Coding for Your Friends,\u201d page 174\n\nBurk Hufnagel \n\nBurk Hufnagel has been creating positive user experiences since \n1978 as a software architect and developer. As someone who has \nspent most of his life designing and crafting software, Burk has \nmade a habit of developing practical solutions for difficult prob-\n\nlems. He is a bibliophile and a technophile, and tends to appreciate esoteric \nsubjects.\n\nBurk was one of the contributors to 97 Things Every Software Architect Should \nKnow (O\u2019Reilly). He spoke at JavaOne 2008 on building better user experi-\nences, and at the International Association of Software Architects\u2019 IT Archi-\ntecture Regional Conference in 2007 and 2009. He also authored a paper for \nthe IASA Skills Library on the not-so-subtle connection between user inter-\nface design and user experience.\n\n\u201cNews of the Weird: Testers Are Your Friends,\u201d page 120\n\u201cPut the Mouse Down and Step Away from the Keyboard,\u201d page 138\n\n[image: image99.jpg]  \n\n[image: image100.jpg]  \n\n[image: image101.jpg]  \n\nhttp://andersnoras.com\nhttp://aslamkhan.net\nhttp://www.strategy-nets.com/wiki/converting-your-near-time-account-to-strategy-nets\nhttp://www.strategy-nets.com/wiki/converting-your-near-time-account-to-strategy-nets\n\n\n199Contributors\n\nCal Evans \n\nCal Evans is the director of the PCE for Ibuildings. He has been \na programmer in various languages for more than 25 years. He \nis a published author of books and magazine articles on a vari-\nety of topics in several programming languages. He is an Amer-\n\nican currently based in Utrecht, the Netherlands, where he speaks, writes, \ncodes, and works with the global PHP community. His blog can be found at \nhttp://blog.calevans.com.\n\n\u201cA Comment on Comments,\u201d page 32\n\u201cDon\u2019t Touch That Code!,\u201d page 62\n\nCarroll Robinson \n\nCarroll Robinson is an embedded firmware engineer with \napproximately 20 years of experience. He has written C and \nassembly language firmware for a variety of processors (includ-\ning 8051, 80x86, 68k, ARM7, and C2000), with applications in \n\nmedical equipment, laboratory instrumentation, and wireless communica-\ntions. He has written applications in C++, Java, and Python as well. He prefers \nto use open source tools (GCC, GAS, GDB) on Linux platforms, and has built \nseveral embedded Linux systems.\n\nCarroll holds a master\u2019s of science degree in computer engineering from Case \nWestern Reserve University in Cleveland, Ohio.\n\n\u201cKnow How to Use Command-Line Tools,\u201d page 86\n\nCay Horstmann \n\nCay Horstmann grew up in northern Germany and attended the \nChristian-Albrechts-Universit\u00e4t in Kiel, a harbor town by the \nBaltic Sea. He received an MS in computer science from Syracuse \nUniversity, and a PhD in mathematics from the University of \n\nMichigan in Ann Arbor. For four years, Cay was VP and CTO of an Internet \nstartup that grew from three people in a tiny office to a public company. He \nnow teaches computer science at San Jose State University. In his copious spare \ntime, he writes books and articles on Java and computer science education.\n\n\u201cStep Back and Automate, Automate, Automate,\u201d page 156\n\n[image: image102.jpg]  \n\n[image: image103.jpg]  \n\n[image: image104.jpg]  \n\nhttp://blog.calevans.com\n\n\n200 Contributors\n\nChuck Allison \n\nChuck Allison is an associate professor of computer science at \nUtah Valley University. He spent the two previous decades as a \nsoftware engineer in the western U.S. He was an active contrib-\nutor to C++98, senior editor of the C/C++ Users Journal, and \n\ncoauthor of Thinking in C++, Volume 2, with Bruce Eckel. He was also the \nfounder of The C++ Source and a contributing editor for Better Software Mag-\nazine. For more information, visit his website: http://www.chuckallison.com.\n\n\u201cFloating-Point Numbers Aren\u2019t Real,\u201d page 66\n\nClint Shank \n\nClint Shank is a software developer, consultant, and mentor at \nSphere of Influence, Inc., a company that leads with design-\ndriven innovation to make curve-jumping, mouth-watering soft-\nware that\u2019s awesome inside and out. His typical consulting focus \n\nis the design and construction of enterprise applications.\n\nHe is particularly interested in agile practices such as continuous integration \nand test-driven development; the programming languages Java, Groovy, Ruby, \nand Scala; frameworks like Spring and Hibernate; and general design and \napplication architecture.\n\nHe keeps a blog at http://clintshank.javadevelopersjournal.com/ and was a con-\ntributor to the book 97 Things Every Software Architect Should Know.\n\n\u201cContinuous Learning,\u201d page 36\n\nDan Bergh johnsson \n\nDan Bergh Johnsson is senior consultant, partner, and official \nspokesperson for Omegapoint AB. He is a domain-driven design \nenthusiast and a long-time agile fan, and considers himself as \npart of the software craftsman tradition and the \u201cOOPSLA \n\nSchool\u201d of development. He cofounded the Swedish domain-driven design \ngroup DDD Sverige, contributes at http://domaindrivendesign.org/, and often \ndelivers presentations at international conferences. He also shares his love of \nthe craft in his blog, \u201cDear Junior: Letters to a Junior Programmer,\u201d which can \nbe found at http://dearjunior.blogspot.com.\n\n\u201cDistinguish Business Exceptions from Technical,\u201d page 42\n\u201cKnow Your Next Commit,\u201d page 94\n\n[image: image105.jpg]  \n\n[image: image106.jpg]  \n\n[image: image107.jpg]  \n\nhttp://www.chuckallison.com\nhttp://clintshank.javadevelopersjournal.com/\nhttp://domaindrivendesign.org/\nhttp://dearjunior.blogspot.com\n\n\n201Contributors\n\nDan North \n\nDan North writes software and coaches teams in agile and lean \nmethods. He believes in putting people first and writing simple, \npragmatic software. He also believes that most problems that \nteams face are about communication\u2014and all the others are, too.\n\nThis is why he puts so much emphasis on \u201cgetting the words right,\u201d and why \nhe is so passionate about behavior-driven development, communication, and \nhow people learn. Dan has been working in the IT industry since he graduated \nin 1991, and he occasionally blogs at http://dannorth.net.\n\n\u201cCode in the Language of the Domain,\u201d page 22\n\nDaniel Lindner \n\nDaniel Lindner has developed software for over 15 years, both paid \nfor and voluntary (open source). He cofounded a software devel-\nopment company in Karlsruhe, Germany, and gives lectures on \nsoftware engineering. He has been seen having a social life, too.\n\n\u201cLet Your Project Speak for Itself,\u201d page 104\n\nDiomidis Spinellis \n\nDiomidis Spinellis is a professor in the department of manage-\nment science and technology at the Athens University of Eco-\nnomics and Business, Greece. His research interests include \nsoftware engineering, computer security, and programming lan-\n\nguages. He has written the two award-winning Open Source Perspective books, \nCode Reading and Code Quality (both Addison-Wesley Professional), as well \nas dozens of scientific papers. His most recent work is the collection Beautiful \nArchitecture (O\u2019Reilly). He is a member of the IEEE Software editorial board, \nauthoring the regular \u201cTools of the Trade\u201d column. Diomidis is a FreeBSD \ncommitter and the developer of UMLGraph and other open source software \npackages, libraries, and tools. He holds an MEng in software engineering and \na PhD in computer science, both from Imperial College London. Diomidis is \na senior member of the ACM and the IEEE and a member of the Usenix Asso-\nciation.\n\n\u201cLarge, Interconnected Data Belongs to a Database,\u201d page 96\n\u201cPut Everything Under Version Control,\u201d page 136\n\u201cThe Unix Tools Are Your Friends,\u201d page 176\n\n[image: image108.jpg]  \n\n[image: image109.jpg]  \n\n[image: image110.jpg]  \n\nhttp://dannorth.net\n\n\n202 Contributors\n\nEdward Garson \n\nEdward Garson has been passionate about computing since \nlearning to program in Logo on an Apple II. He currently works \nas an independent software development consultant, with a focus \non helping companies transition to agile methods.\n\nEdward\u2019s technical interests include software architecture and design, pro-\ngramming languages, and GNU/Linux. He is an enthusiastic presenter and \nhas spoken at the British Computer Society, the Microsoft Architects Council, \nand various conferences. Edward is a contributing author of 97 Things Every \nSoftware Architect Should Know.\n\nEdward resides in Montreal with his wife and two sons. In his spare time, he \nenjoys skiing, climbing, and cycle touring.\n\n\u201cApply Functional Programming Principles,\u201d page 4\n\nEinar Landre \n\nEinar Landre is a practicing software professional with 25 years\u2019 \nexperience as a developer, architect, manager, consultant, and \nauthor/presenter. He currently works for StatoilHydro\u2019s Business \nApplication Services, where he engages in business-critical appli-\n\ncation development, architecture reviews, and software process improvement \nactivities. Before joining StatoilHydro, Einar held positions as developer, \nconsultant, and manager, working with the design and implementation of \ncommunication protocols, operating systems, and test software for the Inter-\nnational Space Station. In recent years, he has become an active member of the \nprofessional community, authoring or coauthoring several papers presented at \nOOPSLA and SPE (Society of Petroleum Engineers). His professional interests \ninclude object-oriented programming, autonomous systems design, use of sys-\ntems engineering practices, agile methodologies, and leadership in high-tech \norganizations.\n\nEinar holds an MSc in information technology from the University of Strath-\nclyde and is an IEEE-certified software development professional (CSDP). He \nlives with his family in Stavanger, Norway.\n\n\u201cEncapsulate Behavior, Not Just State,\u201d page 64\n\u201cPrefer Domain-Specific Types to Primitive Types,\u201d page 130\n\n[image: image111.jpg]  \n\n[image: image112.jpg]  \n\n\n\n203Contributors\n\nFilip van Laenen \n\nFilip van Laenen is a chief engineer at the Norwegian software com-\npany Computas AS, which supplies IT solutions to the public and the \nprivate sector in Norway. He has over 10 years of experience in the \nsoftware industry, from being a developer in both small and large \n\nteams to being the lead developer and compentency leader for security and soft-\nware engineering for the whole company. In his professional career, he has used a \nnumber of programming languages, including Smalltalk, Java, Perl, Ruby, and PL/\nSQL. He has a special interest in computer security and cryptography, and held the \nposition of chief security officer at Computas for a number of years.\n\nFilip holds an MSc in electronics and an MSc in computer science from the \nKULeuven. He comes originally from Flanders, but moved to Norway in 1997 \nand now lives with his family in Kols\u00e5s, near Oslo.\n\n\u201cAutomate Your Coding Standard,\u201d page 8\n\nGerard Meszaros \n\nGerard Meszaros is an independent software development con-\nsultant, coach, and trainer with 25 years\u2019 experience building \nsoftware and nearly a decade of experience applying agile meth-\nods such as Scrum, eXtreme Programming, and Lean. He speaks \n\nregularly at software development and testing conferences such as OOPSLA, \nAgile200x, and STAR. He is the author of xUnit Test Patterns: Refactoring Test \nCode (Addison-Wesley) and runs the website http://xunitpatterns.com.\n\n\u201cWrite Tests for People,\u201d page 190\n\nGiles Colborne \n\nGiles Colborne has been working in usability for two decades at \nBritish Aerospace, Institute of Physics Publishing, and Euro RSCG \ngroup. In that time, he has spent hundreds of hours watching users \nin the lab and in the field. In 2004, he cofounded cxpartners, a user-\n\ncentered design company that researches user behavior and designs user experi-\nences for clients all over the world, including Nokia, Marriott, and eBay.\n\nHe was president of the UK Usability Professionals\u2019 Association from 2003 to \n2007, and has worked with the British Standards Institute in developing stan-\ndards and guidance on accessibility.\n\n\u201cAsk \u2018What Would the User Do?\u2019 (You Are Not the User),\u201d page 6\n\u201cPrevent Errors,\u201d page 132\n\n[image: image113.jpg]  \n\n[image: image114.jpg]  \n\n[image: image115.jpg]  \n\nhttp://xunitpatterns.com\n\n\n204 Contributors\n\nGiovanni Asproni \n\nGiovanni Asproni is a freelance contractor and consultant living \nin the UK. Despite the fact that he often gets hired as an architect, \nteam leader, trainer, and mentor, he is a programmer at heart, \nwith a taste for simple code. He is a regular conference speaker, a \n\nmember of the committee of the London XPDay conference, and the chair of \nthe ACCU conference. Giovanni is a member of the ACCU, the AgileAlliance, \nthe ACM, and the IEEE Computer Society.\n\n\u201cChoose Your Tools with Care,\u201d page 20\n\u201cLearn to Estimate,\u201d page 100\n\nGreg Colvin \n\nGreg Colvin has been hacking happily since 1972. When not \ncranking code or reading technical prose, he runs his dog on the \nbeach or plays the blues in the local dives.\n\n\u201cKnow Your Limits,\u201d page 92\n\nGregor Hohpe \n\nGregor Hohpe is a software engineer with Google. He is best \nknown for his thoughts on asynchronous messaging and \n service-oriented architectures, which he shares in a number of \npublications, including the seminal book Enterprise Integration \n\nPatterns (Addison-Wesley Professional). Find out more about his work at \nhttp://www.eaipatterns.com.\n\n\u201cConvenience Is Not an -ility,\u201d page 38\n\nGudny Hauknes \n\nGudny Hauknes works as senior software developer at the Nor-\nwegian division of the consultancy company Steria. Since 1987, \nwhen she graduated from the Norwegian University of Technol-\nogy (NTH/NTNU), she has had different roles within system \n\ndevelopment, project management, and quality assurance.\n\nShe is particularly interested in getting people to work together in a smooth \nway, having fun, working effectively, and, of course, making quality software.\n\n\u201cPair Program and Feel the Flow,\u201d page 128\n\n[image: image116.jpg]  \n\n[image: image117.jpg]  \n\n[image: image118.jpg]  \n\n[image: image119.jpg]  \n\nhttp://www.eaipatterns.com\n\n\n205Contributors\n\nHeinz Kabutz \n\nHeinz Kabutz is the author of The Java Specialists\u2019 Newsletter, an \nadvanced Java publication read by 50,000 Java specialists in 120 \ncountries. Most of Heinz\u2019s time is spent writing Java code as a \ncontractor for a number of companies. In addition, he lectures \n\ncompanies on how to write more effective Java, taking advantage of its \nadvanced features.\n\nHeinz is a Java Champion and was interviewed by Sun Microsystems (see http://\njava.sun.com/developer/technicalArticles/Interviews/community/kabutz_qa.html).\n\n\u201cKnow Your IDE,\u201d page 90\n\njan Christiaan \u201cjC\u201d van Winkel \n\nJC van Winkel is a trainer and courseware developer for the small \nDutch training and consulting company AT Computing. His \nwork focuses on UNIX/Linux (system administration, security, \nperformance analysis) and programming languages (mostly C, \n\nC++, and Python). He is also the Dutch representative for C++ standardiza-\ntion. JC was a board member of the Netherlands Unix User\u2019s group (NLUUG) \nfor 12 years, during 6 of which he also served as chair.\n\n\u201cUse the Right Algorithm and Data Structure,\u201d page 178\n\njanet Gregory \n\nThe coauthor of Agile Testing: A Practical Guide for Agile Testers \nand Teams (Addison-Wesley Professional), Janet Gregory is a \nconsultant who specializes in helping teams build quality systems \nusing agile methods. Based in Calgary, Canada, Janet\u2019s greatest \n\npassion is promoting agile quality processes. As tester or coach, she has helped \nintroduce agile development practices into companies and has successfully \ntransitioned several traditional test teams into the agile world. Her focus is work-\ning with business users and testers to understand their roles in agile projects. \nJanet teaches courses on agile testing and is a frequent speaker at agile and testing \nsoftware conferences around the world. Read more at http://janetgregory.ca.\n\n\u201cWhen Programmers and Testers Collaborate,\u201d page 184\n\n[image: image120.jpg]  \n\n[image: image121.jpg]  \n\n[image: image122.jpg]  \n\nhttp://java.sun.com/developer/technicalArticles/Interviews/community/kabutz_qa.html\nhttp://java.sun.com/developer/technicalArticles/Interviews/community/kabutz_qa.html\nhttp://janetgregory.ca\n\n\n206 Contributors\n\njason P. Sage \n\nJason P. Sage is a computer consultant and business owner whose \nprimary focus is system design, integration, customer relationship \nmanagement (CRM), original server software, data processing, and \n3D graphics software. Jason is a true programming enthusiast; he \n\ngot his start in 1981, when he was 10 years old, on a Timex Sinclair with 2k of \nmemory and a cassette recorder. Since then, he has written all sorts of software, \nranging from video games and an operating system to a warehouse management \nsystem that runs one of the nation\u2019s largest natural food distributors.\n\nHe is often engaged in online forums, assisting and teaching fellow program-\nmers and students of all ages.\n\n\u201cReinvent the Wheel Often,\u201d page 144\n\njohannes Brodwall \n\nJohannes Brodwall is chief scientist at the Norwegian division of \nthe consulting company Steria. He likes to take a broad view of \nprojects to understand how multiple disciplines and technologies \ncan together (hopefully) create value for users of software sys-\n\ntems. He organizes activities in the Oslo agile community. His two most time-\nconsuming activities are the Oslo Extreme Programming Meetup and the \nannual Smidig 200x conferences, a Norwegian-language agile conference \n(smidig is the Norwegian word for \u201cagile\u201d). He is a regular speaker at events in \nthe Oslo area and writes frequently about software development in his blog at \nhttp://johannesbrodwall.com.\n\n\u201cKeep the Build Clean,\u201d page 84\n\u201cVerbose Logging Will Disturb Your Sleep,\u201d page 180\n\njon jagger \n\nJon Jagger is a self-employed software consultant/trainer/ \nprogrammer/mentor/enthusiast, etc., specializing in agile soft-\nware development (people and process), test-driven development, \nUML, design, analysis, OO, and curly-bracket languages (C#, C, \n\nC++, Java). He is a UK C panel member and a lapsed UK C++ panel member, \nand served as the convenor and Principal UK Expert (PUKE!) for C#\u2019s ECMA \nstandardization.\n\nJon is also the inventor of the Average Time To Green game. He has had numer-\nous articles published both online and in magazines and is the coauthor of \n\n[image: image123.jpg]  \n\n[image: image124.jpg]  \n\n[image: image125.jpg]  \n\nhttp://johannesbrodwall.com\n\n\n207Contributors\n\ntwo books: Microsoft\u00ae Visual C#\u00ae .NET Step by Step (Microsoft Press) and C# \nAnnotated Standard (Morgan Kaufmann).\n\nJon is married to the beautiful Natalie, and is the proud father of Ellie, Penny, \nand Patrick. He is also a mad keen freshwater fisherman.\n\n\u201cDo Lots of Deliberate Practice,\u201d page 44\n\u201cMake the Invisible More Visible,\u201d page 112\n\nj\u00f8rn \u00d8lmheim \n\nJ\u00f8rn \u00d8lmheim is a practicing software professional with over 10 \nyears of experience as a developer, architect, and author/presenter. \nHe currently works for Statoil, developing software for a number \nof research projects, mostly using Java, Ruby, and Python with a \n\npinch of Fortran and C/C++ for high-performance computing. His main \ninterests include agile practices with an emphasis on developer craftsmanship, \nprogramming languages, and autonomous systems.\n\nIn his spare time, he enjoys skiing, mountain biking, and spending time with \nhis family.\n\n\u201cBeauty Is in Simplicity,\u201d page 10\n\nKari R\u00f8ssland \n\nKari R\u00f8ssland is a software developer at the Norwegian division \nof the consulting company Steria. In the three years since she got \nher master\u2019s degree in computer science from NTNU in Trond-\nheim, Norway, she has worked on several different projects. She \n\nis particularly interested in agile development and is passionate about effi-\ncient, joyful cooperation between participants in software projects.\n\n\u201cPair Program and Feel the Flow,\u201d page 128\n\nKarianne Berg \n\nKarianne Berg holds an MSc from University of Bergen, Norway, \nand is currently employed at the Norwegian consulting firm \nObjectware. She likes to contribute to making people better devel-\nopers, and is co-organizer of the ROOTS and Smidig conferences, \n\nas well as the Oslo XP Meetup. She has also presented at several conferences, \nand was last seen at Smidig 2009. Karianne\u2019s main fields of interest include \nagile development, patterns, and the Spring framework.\n\n\u201cRead Code,\u201d page 140\n\n[image: image126.jpg]  \n\n[image: image127.jpg]  \n\n[image: image128.jpg]  \n\n\n\n208 Contributors\n\nKeith Braithwaite \n\nKeith Braithwaite is a principal consultant with Zuhlke. He also \nmanages its Centre of Agile Practice. This group provides training, \ncoaching, mentoring, toolsmithing, and straightforward develop-\nment to enhance client teams\u2019 capabilities. He has maintained \n\ncompilers, modeled GSM networks, and ported sat-nav sytems for startups, \nproduct companies, and global service organizations. He has earned money \nwriting code in C, C++, Java, Python, and Smalltalk. Keith increasingly focuses \non the use of \u201cchecked examples\u201d or \u201cautomated tests\u201d as effective tools for \nrequirements gathering and analysis, system design, and project management.\n\nHis blog is at http://peripateticaxiom.blogspot.com/; find his conference presen-\ntations at http://www.keithbraithwaite.demon.co.uk/professional/presentations/.\n\n\u201cRead the Humanities,\u201d page 142\n\u201cWrite Small Functions Using Examples,\u201d page 188\n\nKevlin Henney \n\nKevlin Henney is an independent consultant and trainer. His \nwork focuses on patterns and architecture, programming tech-\nniques and languages, and development process and practice. He \nhas been a columnist for various magazines and online publica-\n\ntions, including The Register, Better Software, Java Report, CUJ, and C++ \nReport. Kevlin is coauthor of two volumes in the Pattern-Oriented Software \nArchitecture series: A Pattern Language for Distributed Computing and On Pat-\nterns and Pattern Languages (Wiley). He also contributed to 97 Things Every \nSoftware Architect Should Know.\n\n\u201cComment Only What the Code Cannot Say,\u201d page 34\n\u201cTest for Required Behavior, Not Incidental Behavior,\u201d page 160\n\u201cTest Precisely and Concretely,\u201d page 162\n\nKirk Pepperdine \n\nKirk Pepperdine works as an independent consultant offering \nJava performance-related services. Prior to focusing on Java, \nKirk developed and tuned systems written in C/C++, Small-\ntalk, and a variety of other languages. Kirk has written many arti-\n\ncles and spoken at several conferences on the subject of performance tuning. \n\n[image: image129.jpg]  \n\n[image: image130.jpg]  \n\n[image: image131.jpg]  \n\nhttp://peripateticaxiom.blogspot.com/\nhttp://www.keithbraithwaite.demon.co.uk/professional/presentations/\n\n\n209Contributors\n\nHe helped evolve http://www.javaperformancetuning.com as a resource for \nperformance-tuning tips and information.\n\n\u201cMissing Opportunities for Polymorphism,\u201d page 118\n\u201cThe Road to Performance Is Littered with Dirty Code Bombs,\u201d page 148\n\u201cWET Dilutes Performance Bottlenecks,\u201d page 182\n\nKlaus Marquardt \n\nKlaus Marquardt\u2019s software development experience covers life-\nsupport systems, international projects, frameworks and product \nlines, and agility in regulated environments. He has documented \na series of diagnoses and therapies on software systems that stem \n\nfrom his interest in the mutual influences of technology, humans, processes, \nand organization; these can be found at http://www.sustainable-architecture.eu. \nFurthermore, he enjoys writing patterns, running conference sessions that \nexplore new ground, and having a life beyond software.\n\n\u201cLearn Foreign Languages,\u201d page 98\n\u201cThe Longevity of Interim Solutions,\u201d page 108\n\nLinda Rising \n\nLinda Rising has a PhD from Arizona State University and a \nbackground that includes university teaching and industry work \nin a variety of domains. An internationally known presenter on \npatterns, retrospectives, agile development, and the change pro-\n\ncess, Linda has authored numerous articles and four books, the most recent, \nFearless Change: Patterns for Introducing New Ideas (Addison-Wesley), with \nMary Lynn Manns.\n\n\u201cA Message to the Future,\u201d page 116\n\nMarcus Baker \n\nMarcus Baker is a happy programmer who\u2019s astonished that he \ngets paid for it. The joy extends to telephony, data mining, robot-\nics, and web development. He is also an occasional writer and \ncolumnist, and sometimes organizer of user groups and confer-\n\nences. Today, though, he has to look after the kids.\n\n\u201cInstall Me,\u201d page 80\n\n[image: image132.jpg]  \n\n[image: image133.jpg]  \n\n[image: image134.jpg]  \n\nhttp://www.javaperformancetuning.com\nhttp://www.sustainable-architecture.eu\n\n\n210 Contributors\n\nMatt Doar \n\nMatt Doar is a consultant working with software tools such as \nversion control (CVS, Subversion), build systems (make, SCons), \nand bug trackers (Bugzilla, JIRA). Most of his clients are smaller \nstartups in Silicon Valley. Matt is also the author of O\u2019Reilly\u2019s \n\nPractical Development Environments.\n\n\u201cHow to Use a Bug Tracker,\u201d page 76\n\nMattias Karlsson \n\nMattias Karlsson spends most of his time working with software \ndevelopment in the financial sector as well as leading a Java User \nGroup in Stockholm, Sweden. Mattias has worked with OO soft-\nware development since 1993. Through the years, he has gained \n\nexperience in many different roles, including developer, architect, team leader, \ncoach, manager, and teacher. In these roles, he receives consistent feedback \nabout his ability to inspire and motivate the people he works with. The JUG \nholds six to eight fully booked meetings per year, with more then 200 partici-\npants at every meeting. Mattias is also one of the organizers behind Jfokus. \nJfokus is the largest Java-focused annual conference in Stockholm.\n\nIn his spare time, Mattias can be found playing with his children or riding \nhis motorcycle, as well as changing underprivileged people\u2019s lives by building \nhouses with Habitat for Humanity. Mattias also supports Kiva, a person-\nto-person microloan organization. Join his effort to improve the world at \nhttp://www.kiva.org/team/jug.\n\n\u201cCode Reviews,\u201d page 28\n\nMichael Feathers \n\nMichael Feathers is a consultant with Object Mentor Interna-\ntional. He balances his time between working with, training, and \ncoaching various teams around the world. Michael developed \nCppUnit, the initial port of JUnit to C++, and FitCpp, a C++ port \n\nof the Fit integrated-test framework. Michael is also the author of the book \nWorking Effectively with Legacy Code (Prentice Hall).\n\n\u201cThe Golden Rule of API Design,\u201d page 70\n\n[image: image135.jpg]  \n\n[image: image136.jpg]  \n\n[image: image137.jpg]  \n\nhttp://www.kiva.org/team/jug\n\n\n211Contributors\n\nMichael Hunger \n\nMichael Hunger has been passionate about software develop-\nment since his childhood days in East Germany. He is particu-\nlarly interested in the people who develop software, software \ncraftsmanship, programming languages, and improving code. \n\nWhile he likes coaching and in-project development as an independent con-\nsultant (\u201cbetter software development evangelist\u201d\u2014http://jexp.de), he really \nenjoys the numerous other projects in his life.\n\nOne half of his life is devoted to his family of three kids, a longtime obsession with \na text-based multiuser dungeon (MUD MorgenGrauen), reading books whenever \npossible, running his coffee shop \u201cdie-buchbar\u201d with a workshop for printing on \nthings, and tinkering with and without Lego\u00ae. The other half is filled with working \nwith programming languages and learning new ones, enjoying IT podcasts (espe-\ncially Software Engineering Radio; http://se-radio.net/), participating in exciting \nand ambitious projects like qi4j, creating DSLs (jequel, squill, and xmldsl), lots \nof refactoring, and contributing to and reviewing books in progress. Recently, he \nstarted to present at conferences.\n\n\u201cDomain-Specific Languages,\u201d page 46\n\nMike Lewis \n\nMike Lewis is currently a software engineer at Lutron Electron-\nics, and an independent software consultant in his spare time. He \napplies over a decade of software engineering experience toward \ndesigning elegant and intuitive software solutions. He is a process \n\nimprovement advocate whose passion lies in enhancing the user experience of \nabsolutely everything.\n\nMike holds a BS and an MS in computer engineering, both from the Rochester \nInstitute of Technology. Mike currently resides in Allentown, Pennsylvania, \njust outside of New York City and Philadelphia.\n\n\u201cDon\u2019t Be Afraid to Break Things,\u201d page 48\n\nNate jackson \n\nNate Jackson is a senior software architect in Buffalo, New York. \nHe has been writing code of one kind or another since 1979, \nwhen he got his TI-99 and a basic emulator cartridge. By follow-\ning his own advice, he has satisfied all of his customers\u2014even the \n\nlady who wanted the white background.\n\n\u201cYour Customers Do Not Mean What They Say,\u201d page 194\n\n[image: image138.jpg]  \n\n[image: image139.jpg]  \n\n[image: image140.jpg]  \n\nhttp://jexp.de\nhttp://se-radio.net/\n\n\n212 Contributors\n\nNeal Ford \n\nNeal Ford is software architect and meme wrangler at Thought-\nWorks, a global IT consultancy with an exclusive focus on end-\nto-end software development and delivery. He is the designer/\ndeveloper of applications, instructional materials, magazine arti-\n\ncles, courseware, video/DVD presentations, and author and/or editor of five \nbooks. He also speaks at lots of conferences. You can assuage your ravenous \ncuriosity about Neal at http://www.nealford.com.\n\n\u201cTesting Is the Engineering Rigor of Software Development,\u201d page 166\n\nNiclas Nilsson \n\nNiclas Nilsson is a software development coach, consultant, edu-\ncator, and writer with a deep passion for the craft and a love of \ngood design and architecture. He began working as a developer \nin 1992. From his experience, he knows that some choices in soft-\n\nware development\u2014like languages, tools, communication, and processes\u2014\nmake a significant difference. This is the reason behind his affection for dynamic \nlanguages, test-driven development, code generation, metaprogramming, and \nagile processes. Niclas is a cofounder of factor10, and he is also an editor for the \narchitecture community at InfoQ. Niclas blogs at http://niclasnilsson.se.\n\n\u201cThinking in States,\u201d page 168\n\nOlve Maudal \n\nOlve Maudal lives in Norway. Married. Two kids. Dedicated \ncomputer geek. These days, mostly coding in C and C++.\n\nAt university, he studied software engineering and artificial \nintelligence. His professional career started in an oil service \n\ncompany developing systems for finding oil and gas. He then spent a few \nyears developing systems for moving money. Now he works for a telecom \ncompany developing systems for effective communication between people.\n\nOlve is an active member of the vibrant geek community in Oslo, where, \namong other things, he organizes the Oslo C++ Users Group. You can read his \nblog at http://olvemaudal.wordpress.com.\n\n\u201cHard Work Does Not Pay Off,\u201d page 74\n\n[image: image141.jpg]  \n\n[image: image142.jpg]  \n\n[image: image143.jpg]  \n\nhttp://www.nealford.com\nhttp://niclasnilsson.se\nhttp://olvemaudal.wordpress.com\n\n\n213Contributors\n\nPaul W. Homer \n\nPaul W. Homer is a software developer, writer, and occasional \nphotographer, who was drawn into software development several \ndecades ago and has been struggling ever since with trying to \nbuild increasingly complex systems. His experience includes in-\n\nhouse,  consulting, and commercial development from a diverse array of con-\ncurrent posisions including analyst, architect, programmer, manager, and \neven\u2014foolishly\u2014CTO. He is willing to play any role that is focused on getting \nsystems built and released.\n\nOver the last few years, he has turned more of his attention toward commu-\nnicating with his fellow developers, including a self-published book, blogging, \nand way too much commenting in the hopes of helping an industry rationalize \nitself and reach new heights.\n\n\u201cSimplicity Comes from Reduction,\u201d page 150\n\nPete Goodliffe \n\nPete Goodliffe is a software developer, columnist, speaker, and \nauthor who never stays at the same place in the software food chain. \nHe\u2019s worked in numerous languages on diverse projects. He also \nteaches and mentors programmers, and writes the regular \u201cProfes-\n\nsionalism in Programming\u201d column for ACCU\u2019s CVu magazine (http://accu.org/).\n\nPete\u2019s popular book, Code Craft (No Starch Press), is a practical and entertain-\ning investigation of the entire programming pursuit. Pete enjoys writing excel-\nlent, bug-free code, so he can spend more time having fun with his kids. He \nhas a passion for curry and doesn\u2019t wear shoes.\n\n\u201cDon\u2019t Ignore That Error!,\u201d page 52\n\u201cImprove Code by Removing It,\u201d page 78\n\u201cYou Gotta Care About the Code,\u201d page 192\n\nPeter Sommerlad \n\nPeter Sommerlad is professor and head of the Institute for Soft-\nware at HSR Rapperswil. Peter is coauthor of Pattern-Oriented \nSoftware Architecture, Volume 1, and Security Patterns (both \nWiley). His long-term goal is to make software simpler through \n\ndecremental development: refactoring software down to 10% of its size with \nbetter architecture, testability, quality, and functionality.\n\n\u201cOnly the Code Tells the Truth,\u201d page 124\n\n[image: image144.jpg]  \n\n[image: image145.jpg]  \n\n[image: image146.jpg]  \n\nhttp://accu.org/\n\n\n214 Contributors\n\nRajith Attapattu \n\nRajith Attapattu is a senior software engineer on Red Hat\u2019s MRG \nteam. Rajith is an open source enthusiast and has been a contribu-\ntor on several Apache projects, including Apache Qpid, Apache \nSynapse, Apache Tuscany, and Apache Axis2. His recent focus has \n\nbeen on building scalable and reliable messaging middleware, and he is part of \nthe AMQP (Advanced Message Queuing Protocol) working group.\n\nHe has published several articles and spoken at several conferences and user \ngroups, including ApacheCon, Colorado Software Summit, and Toronto JUG. \nRajith\u2019s research interests are in improving scalability and high availability of dis-\ntributed systems. Rajith enjoys painting and playing cricket during his free time.\n\nRajith can be reached at rajith@apache.org, and he maintains a presence at \nhttp://rajith.2rlabs.com.\n\n\u201cBefore You Refactor,\u201d page 12\n\u201cTest While You Sleep (and over Weekends),\u201d page 164\n\nRandy Stafford \n\nRandy Stafford is a practicing software professional with 20 years\u2019 \nexperience as a developer, analyst, architect, manager, consultant, \nand author/presenter. He\u2019s currently a member of Oracle\u2019s \nA-Team, where he\u2019s involved with POC projects, architecture \n\nreviews, and production crises. He specializes in grid, SOA, performance, HA, \nand JEE/ORM work.\n\nRandy has been technical advisor to Rally Software, chief architect of IQNavi-\ngator, director of development at SynXis, consultant for GemStone and Small-\ntalk, and a simulation specialist in the aerospace and CASE industries. He\u2019s \ncontributed to 97 Things Every Software Architect Should Know, Patterns of \nEnterprise Application Architecture (Wiley), and EJB Design Patterns (Addison-\nWesley Professional).\n\n\u201cInterprocess Communication Affects Application Response Time,\u201d page 82\n\nRichard Monson-Haefel\n\nRichard Monson-Haefel, an independent software developer, has \ncoauthored all five editions of Enterprise JavaBeans and both edi-\ntions of Java Message Service (both from O\u2019Reilly), and authored \nJ2EE Web Services (Addison-Wesley). Richard is the editor of 97 \n\nThings Every Software Architect Should Know. He cofounded the OpenEJB \n\n[image: image147.jpg]  \n\n[image: image148.jpg]  \n\n[image: image149.jpg]  \n\nhttp://rajith.2rlabs.com\n\n\n215Contributors\n\nopen source project, the EJB container for Apache Geronimo, and currently \nconsults as an iPhone and Microsoft Surface developer.\n\n\u201cFulfill Your Ambitions with Open Source,\u201d page 68\n\nRobert C. Martin (Uncle Bob) \n\nRobert C. Martin (Uncle Bob) has been a software professional \nsince 1970 and is founder and president of Object Mentor, Inc., in \nGurnee, Illinois. Object Mentor, Inc., is an international firm of \nhighly experienced software developers and managers who spe-\n\ncialize in helping companies get their projects done. Object Mentor offers pro-\ncess improvement consulting, object-oriented software design consulting, \ntraining, and skill development services to major corporations worldwide.\n\nBob has published dozens of articles in various trade journals, and is a regular \nspeaker at international conferences and trade shows. He has authored and \nedited many books, including Designing Object-Oriented C++ Applications \nUsing the Booch Method (Prentice Hall), Patterns Languages of Program Design \n3 (Addison-Wesley Professional), More C++ Gems (Cambridge University \nPress), Extreme Programming in Practice (Addison-Wesley Professional), Agile \nSoftware Development: Principles, Patterns, and Practices, UML for Java Pro-\ngrammers, and Clean Code (all Prentice Hall).\n\nA leader in the industry of software development, Bob served three years as \nthe editor-in-chief of the C++ Report, and he served as the first chairman of \nthe Agile Alliance.\n\n\u201cThe Boy Scout Rule,\u201d page 16\n\u201cThe Professional Programmer,\u201d page 134\n\u201cThe Single Responsibility Principle,\u201d page 152\n\nRod Begbie\n\nRod Begbie originally hails from Scotland, but currently leaves \nhis heart in San Francisco.\n\nHis day job is engineering lead and panda wrangler at Slide, Inc. \nPreviously, he was employed as an API architect at Current TV, \n\nlurked in the R&D labs of Bose Corporation, consulted with Sapient, and \nducked out the (first) dot-com bubble-burst in the basement of a bank, build-\ning systems for fixed-income annuity analysis, which is as dull as it sounds.\n\n\u201cDon\u2019t Be Cute with Your Test Data,\u201d page 50\n\n[image: image150.jpg]  \n\n[image: image151.jpg]  \n\n\n\n216 Contributors\n\nRussel Winder \n\nRussel Winder is a partner in Concertant LLP, which provides \nanalysis and consultancy on all aspects of parallelism, concurrency, \nand multicore systems. He is also an independent consultant, \nauthor, and trainer on programming, programming languages \n\n(Java, Groovy, and Python), version control systems (Subversion, Bazaar, and \nGit) and build frameworks (Gant, SCons, Gradle, Ant, and Maven). Russel is \nauthor of Developing C++ Software (Wiley), and coauthor of Developing Java \nSoftware (Wiley) and Python for Rookies (Cengage Learning Business Press).\n\n\u201cKnow Well More Than Two Programming Languages,\u201d page 88\n\u201cMessage Passing Leads to Better Scalability in Parallel Systems,\u201d page 114\n\nRyan Brush \n\nRyan Brush is a director and Distinguished Engineer with Cerner \nCorporation, where he has worked since 1999. He is primarily \ninterested in the application of technology to healthcare.\n\n\u201cCode Is Design,\u201d page 24\n\u201cThe Guru Myth,\u201d page 72\n\nSam Saariste\n\nSam Saariste has an MSc degree in electrical engineering and has \nbeen developing software professionally since 1995. He has done \nso in a variety of application areas, ranging from real-time speech \nprocessing solutions for telecoms to financial trading applica-\n\ntions for investment banking. His language of choice is C++, and he has been \na member of the BSI C++ panel since 2005. Sam has been a fan of agile devel-\nopment methods since he discovered XP around 2000. He cares about high-\nquality software and believes that with agile and lean, both higher quality and \nhigher productivity can be achieved simultaneously.\n\n\u201cResist the Temptation of the Singleton Pattern,\u201d page 146\n\nSarah Mount \n\nSarah Mount is a senior lecturer in computer science at the Univer-\nsity of Wolverhampton. Her interests lie in the area of program-\nming languages and tools, especially for wireless sensor networks \nand other distributed systems. She has taught introductory \n\n[image: image152.jpg]  \n\n[image: image153.jpg]  \n\n[image: image154.jpg]  \n\n[image: image155.jpg]  \n\n\n\n217Contributors\n\nprogramming to undergraduate students for nine years and is a coauthor of the \ntextbook Python for Rookies (Cengage Learning Business Press).\n\n\u201cTake Advantage of Code Analysis Tools,\u201d page 158\n\nScott Meyers \n\nScott Meyers is an author, trainer, speaker, and consultant with \nover three decades of experience in software development prac-\ntice and research. He\u2019s authored dozens of journal and magazine \narticles, as well as the books Effective C++, More Effective C++, \n\nand Effective STL (all Addison-Wesley Professional). He also designed and \noversaw their electronic publication in HTML and PDF forms. Scott is con-\nsulting editor for Addison-Wesley\u2019s Effective Software Development series and \nwas an inaugural member of the advisory board for the online journal, The \nC++ Source (http://www.artima.com/cppsource). He received his PhD in com-\nputer science from Brown University. His website is http://www.aristeia.com/.\n\n\u201cMake Interfaces Easy to Use Correctly and Hard to Use Incorrectly,\u201d page 110\n\nSeb Rose\n\nSeb Rose is a principal software engineer working on the Rational \nDOORS team in Edinburgh. He first worked as a programmer in \n1980 writing applications for estate agents and solicitors in com-\npiled BASIC on an Apple IIe. Upon graduating from Edinburgh \n\nUniversity in 1987, he worked on the REKURSIV project before becoming a \nfreelance contractor. Today, his primary software interests are agile practices \nand the resuscitation of legacy code.\n\n\u201cAct with Prudence,\u201d page 2\n\nSteve Berczuk\n\nSteve Berczuk is a software engineer at Humedica, where he \ndevelops business intelligence solutions for the healthcare indus-\ntry. He has been developing software applications for over 20 \nyears, and is the author of Software Configuration Management \n\nPatterns: Effective Teamwork, Practical Integration (Addison-Wesley Profes-\nsional). In addition to developing software, he enjoys helping teams deliver more \neffectively through the use of agile methods and software configuration manage-\nment. His website is http://www.berczuk.com.\n\n\u201cDeploy Early and Often,\u201d page 40\n\u201cOwn (and Refactor) the Build,\u201d page 126\n\n[image: image156.jpg]  \n\n[image: image157.jpg]  \n\n[image: image158.jpg]  \n\nhttp://www.artima.com/cppsource\nhttp://www.aristeia.com/\nhttp://www.berczuk.com\n\n\n218 Contributors\n\nSteve Freeman \n\nSteve Freeman is an independent consultant specializing in agile \nsoftware development. He has led, coached, and trained teams \naround the world. He is coauthor of the book Growing Object-\nOriented Software, Guided by Tests (Addison-Wesley). Steve is \n\none of the 2006 winners of the Agile Alliance Gordon Pask award. He is a com-\nmitter to the jMock and Hamcrest projects, and was an author of NMock. He \nis a founder member of the eXtreme Tuesday Club and was chair of the first \nLondon XpDay. Steve has been an organizer and presenter at many international \nindustry conferences. Steve has a PhD from the University of Cambridge and, in \nprevious lives, took degrees in statistics and music. These days, he is interested \nin writing better code and exploring organizational complexity.\n\n\u201cCode Layout Matters,\u201d page 26\n\u201cOne Binary,\u201d page 122\n\nSteve Smith \n\nSteve Smith is a software developer, speaker, author, and mentor. \nHe has worked in the software development world professionally \nsince 1997 and has contributed to several books, primarily in the \nASP.NET space. He is a regular speaker at user groups and indus-\n\ntry conferences like DevConnections and Microsoft TechEd. Steve is also a \nformer U.S. Army Engineer Captain and a veteran of Operation Iraqi Free-\ndom, where the platoon he led was involved in clearing unexploded munitions \nand IEDs. Steve lives in Ohio with his wife and two children, and is one of the \ncoordinators of the Hudson Software Craftsmanship group in Hudson, Ohio.\n\n\u201cDon\u2019t Repeat Yourself,\u201d page 60\n\nThomas Guest \n\nThomas Guest is an experienced and enthusiastic computer pro-\ngrammer. He prefers high-level languages and simple solutions. \nHis writing has been published in a number of online and print \nmagazines as well as on his own site, http://www.wordaligned.org.\n\n\u201cLearn to Say \u2018Hello, World\u2019,\u201d page 102\n\n[image: image159.jpg]  \n\n[image: image160.jpg]  \n\n[image: image161.jpg]  \n\nhttp://www.wordaligned.org\n\n\n219Contributors\n\nUdi Dahan\n\nUdi Dahan is The Software Simplist, an internationally renowned \nexpert on software architecture and design. A solutions architec-\nture and connected systems MVP for four consecutive years, Udi \nis also one of 33 experts in Europe recognized by the International \n\n.NET Association, an author and trainer for the International Association of \nSoftware Architects, and an SOA, Web Services, and XML Guru recommended \nby DDJ.\n\nWhen not consulting, speaking, or training, Udi leads the development of \nNServiceBus, the most popular open source .NET enterprise service bus. He \ncan be contacted via his blog at http://www.UdiDahan.com.\n\n\u201cBeware the Share,\u201d page 14\n\nVerity Stob\n\nVerity Stob is the pseudonym of a programmer based in London, \nEngland. Although she professes competence in C++ and the usual \ncurly-bracketed scripting languages, and designs and writes code \nfor a number of platforms, she is probably at her happiest and does \n\nleast harm when she is making Windows programs in CodeGear\u2019s Delphi.\n\nFor over 20 years, Verity has written supposedly amusing articles and columns \nfor various magazines, newspapers, and websites, including the legendary (i.e., \nlong-defunct) .EXE Magazine, the mold-breaking (i.e., more recently defunct) \nDr. Dobb\u2019s Journal, and the scurrilous (i.e., actually profitable) The Register. In \n2005, she published a collection of these pieces as The Best of Verity Stob (Apress), \nand so achieved a lifetime\u2019s ambition\u2014to be paid twice for the same work.\n\nVerity regards her entry in Wikipedia as a travesty of brevity.\n\n\u201cDon\u2019t Nail Your Program into the Upright Position,\u201d page 56\n\nWalter Bright \n\nWalter Bright is a compiler writer, having implemented compil-\ners for C, C++, ECMAScript, ABEL, Java, and, most recently, the \nD programming language. Walter is also known for inventing the \nEmpire strategy game.\n\n\u201cThe Linker Is Not a Magical Program,\u201d page 106\n\n[image: image162.jpg]  \n\n[image: image163.jpg]  \n\n[image: image164.jpg]  \n\nhttp://www.UdiDahan.com\n\n\n220 Contributors\n\nYechiel Kimchi\n\nYechiel Kimchi is a mathematician (PhD in abstract set theory, \nHebrew University, Jerusalem), a computer scientist (teaching \nmore than 10 years with the CS faculty at The Technion, Israel), \nand a software developer\u2014spending more than 15 years alternat-\n\ning between working for big high-tech companies and working as a consultant \nthrough his own small firm. Working initially in C, and then in C++, he is \ninterested in object orientation and the ways to develop software that is cor-\nrect, maintainable, and efficient at the same time. Among other things, he \ndeveloped heuristics for efficiently solving practical NP-hard problems, but he \nconsiders as his greatest achievement the influence he had on the technical \neducation of several thousand Israeli software engineers.\n\n\u201cCoding with Reason,\u201d page 30\n\nYuriy zubarev\n\nYuriy Zubarev is a software architect and team lead with \nYachtWorld.com, a division of Dominion Enterprises. His work \nfocuses on integration of software systems, knowledge gathering \nand tracking techniques, and increasing the technical efficiency \n\nand proficiency of his company. Yuriy lives and works in beautiful Vancouver \ncity in British Columbia, Canada. When he isn\u2019t writing code, you can often \nfind him Latin dancing.\n\n\u201cWrite Code As If You Had to Support It for the Rest of Your Life,\u201d page 186\n\n[image: image165.jpg]  \n\n[image: image166.jpg]  \n\n\n\n221Index\n\nA\nacceptance test-driven development \n\n(ATDD), 184\nAda, 88, 130\nAdams, Douglas, 112\nalgorithms, 178\u2013179\n\ncatastrophic cancellation, 67\nlimits, 92\nperformance, 82\nusing caches, 93\n\nAllison, Chuck\nbiography, 200\nFloating-Point Numbers Aren\u2019t Real, \n\n66\u201367\nanalysis tools, 9, 158\u2013159\nAndroMDA, 47\nANTLR, 47\nAPIs, 38\u201339\n\nAPI design, 70\u201371\ninternal DSLs, 46\n\nThe Art of Computer Programming, 179\nAsproni, Giovanni\n\nbiography, 204\nChoose Your Tools with Care, 20\u201321\nLearn to Estimate, 100\u2013101\n\nAttapattu, Rajith\nBefore You Refactor, 12\u201313\nbiography, 214\nTest While You Sleep (and over \n\nWeekends), 164\u2013165\nautomation, 156\u2013157\n\nautomated tests, 165\nautomating coding standard, 8\u20139\n\nB\nBaden-Powell, Robert Stephenson Smyth, \n\n16\nBaker, Marcus\n\nbiography, 209\nInstall Me, 80\u201381\n\nbeautiful code, 10\u201311, 116\u2013117\nBegbie, Rod\n\nbiography, 215\nDon\u2019t Be Cute with Your Test Data, \n\n50\u201351\nBeing and Time, 143\nBerczuk, Steve\n\nbiography, 217\nDeploy Early and Often, 40\u201341\nOwn (and Refactor) the Build, \n\n126\u2013127\nBerg, Karianne\n\nbiography, 207\nRead Code, 140\u2013141\n\nbinary search, 93\nbinary, single, 122\u2013123\nbiographies\n\nAllison, Chuck, 200\nAsproni, Giovanni, 204\nAttapattu, Rajith, 214\nBaker, Marcus, 209\nBegbie, Rod, 215\nBerczuk, Steve, 217\nBerg, Karianne, 207\nBraithwaite, Keith, 208\nBright, Walter, 219\nBrodwall, Johannes, 206\nBrush, Ryan, 216\n\nIndex\n\n\n\n222 Index\n\nSage, Jason P., 206\nShank, Clint, 200\nSmith, Steve, 218\nSommerlad, Peter, 213\nSpinellis, Diomidis, 201\nStafford, Randy, 214\nStob, Verity, 219\nvan Laenen, Filip, 203\nvan Winkel, Jan Christiaan \u201cJC\u201d, 205\nWible, Adrian, 196\nWinder, Russel, 216\nZubarev, Yuriy, 220\n\nblaming others, 18\u201319, 76\nbottlenecks\n\nperformance, 82, 182\u2013183\nprocess, 28\n\nBoy Scout rule, 16\u201317\nBraithwaite, Keith\n\nbiography, 208\nRead the Humanities, 142\u2013143\nWrite Small Functions Using \n\nExamples, 188\u2013189\nbreaking code, 7, 48\u201349\nBright, Walter\n\nbiography, 219\nThe Linker Is Not a Magical Program, \n\n106\u2013107\nBrodwall, Johannes\n\nbiography, 206\nKeep the Build Clean, 84\u201385\nVerbose Logging Will Disturb Your \n\nSleep, 180\u2013181\nBrush, Ryan\n\nbiography, 216\nCode Is Design, 24\u201325\nThe Guru Myth, 72\u201373\n\nbug tracker, 76\u201377\nbuilds\n\nautomating, 87, 156\nbreaking, 9\nkeeping clean, 84\u201385, 126\u2013127\nsingle binary, 122\u2013123\n\nbuild scripts, 126\u2013127\nbulletin boards, 113\n\nC\nC, 115\n\ndeclarations, 107\nSplint, 159\n\nC#, 42, 54, 67, 70\n\nbiographies (continued)\nColborne, Giles, 203\nColvin, Greg, 204\nDahan, Udi, 219\nDoar, Matt, 210\nEvans, Cal, 199\nFeathers, Michael, 210\nFord, Neal, 212\nFreeman, Steve, 218\nGagnat, Ann Katrin, 198\nGarson, Edward, 202\nGoodliffe, Pete, 213\nGregory, Janet, 205\nGriffiths, Alan, 196\nGuest, Thomas, 218\nHauknes, Gudny, 204\nHenney, Kevlin, 208\nHohpe, Gregor, 204\nHomer, Paul W., 213\nHorstmann, Cay, 199\nHufnagel, Burk, 198\nHunger, Michael, 211\nJackson, Nate, 211\nJagger, Jon, 206\nJohnsson, Dan Bergh, 200\nKabutz, Heinz, 205\nKarlsson, Mattias, 210\nKelly, Allan, 197\nKhan, Aslam, 198\nKimchi, Yechiel, 220\nLandre, Einar, 202\nLewis, Mike, 211\nLindner, Daniel, 201\nMarquardt, Klaus, 209\nMartin, Robert C. (Uncle Bob), 215\nMaudal, Olve, 212\nMeszaros, Gerard, 203\nMeyers, Scott, 217\nMiller, Alex, 197\nMonson-Haefel, Richard, 214\nMount, Sarah, 216\nNilsson, Niclas, 212\nNor\u00e5s, Anders, 197\nNorth, Dan, 201\n\u00d8lmheim, J\u00f8rn, 207\nPepperdine, Kirk, 208\nRising, Linda, 209\nRobinson, Carroll, 199\nRose, Seb, 217\nR\u00f8ssland, Kari, 207\nSaariste, Sam, 216\n\n\n\n223Index\n\ncollaboration, 170\u2013171\ncustomers\u2019 requests, 194\ntesters and programmers, 184\u2013185\n\nColvin, Greg\nbiography, 204\nKnow Your Limits, 92\u201393\n\ncommand-line build tools, 86\u201387\ncomments, 28, 32\u201335, 51, 124, 136, 158, \n\n186\ncommitments, 94\u201395, 101\ncommitting code, running tests before, \n\n164\nCommunicating Sequential Processes \n\n(CSP), 115\ncommunicating with peers, 98\u201399\ncompiler bugs, 18\ncomplexity analysis, 93\u201394\ncomponents, 20\nconcurrency, 114\u2013115\ncontinuous learning, 36\u201337\ncontradictions in code, 172\u2013173\ncorrectness of code, 30\u201331\ncustomers\u2019 requests, 194\nCVS, 136\n\nD\nDahan, Udi\n\nBeware the Share, 14\u201315\nbiography, 219\n\nD and declarations, 107\ndatabases, 96\u201397\ndatabase, unresponsive, 43\ndataflow system, 115\ndata structures, 178\u2013179\n\nusing caches, 23, 82, 93\ndeclarations, 107\ndecoupling code, 125\ndefaults, 133\ndefinitions, 107\ndeliberate practice, 44\u201345\ndependency inversion principle, 153\ndeployment process, 40\u201341\ndesign, 24\u201325\n\nAPI design, 70\u201371\nSingle Responsibility Principle, \n\n152\u2013153\ndirty code, 148\u2013149\nDoar, Matt\n\nbiography, 210\nHow to Use a Bug Tracker, 76\u201377\n\nC++, 56, 88, 115, 131\ndeclarations, 107\n\ncaches, 83, 93\ncaller breaking method contract, 42\nchaos, 1\nCharlemagne, 99\nCOBOL, 26, 58\ncode\n\nanalysis tools, 158\u2013159\nas design, 24\u201325, 166\nautomating coding standard, 8\u20139\nbeautiful, 10\u201311\nbreaking, 48\u201349\ncaring about, 192\u2013193\nchecking code before blaming others, \n\n18\u201319\nclear information, 124\u2013125\ncomments, 32\u201335, 124\ncontradictions in, 172\u2013173\ndecoupling, 125\ndirty, 148\u2013149\ndomain concepts, 22\u201323, 43, 46\u201347, 99, \n\n130\u2013131\nduplication, 60\nerrors, 52\u201353\ninappropriate text in, 50\u201351\nlayout, 26\u201327\nlibraries of shared code, 15\u201316\nreading, 11, 26, 69, 140\u2013141\nreasoning semiformally about \n\ncorrectness, 30\u201331\nrefactoring, 12\u201313, 125\nremoving, 78\u201379, 150\u2013151\nrepetition\n\nlogic, 61\nprocess calls, 60\n\nreviews, 14, 28\u201329, 91\nrunning tests before committing code, \n\n164\nsimplicity, 150\u2013151\nsource control (see source control)\nstatic code analyzers, 30\u201331\nstructuring, 125\nwriting and supporting, 186\u2013187\n\ncodebase, growing, 84\u201385\ncoding practices, 30\u201331\nColborne, Giles\n\nAsk, \u201cWhat Would the User Do?\u201d (You \nAre Not the User), 6\u20137\n\nbiography, 203\nPrevent Errors, 132\u2013133\n\n\n\n224 Index\n\nFowler, Martin, 82\nframeworks, 20\n\ngetting to know, 36\nprocess models and message passing, \n\n115\nFreeman, Steve\n\nbiography, 218\nCode Layout Matters, 26\u201327\nOne Binary, 122\u2013123\n\nfree software, 21, 93, 136\nfunctional programming, 4\u20135, 54, 88\u201389\nfunctions, writing, 188\u2013189\n\nG\nGagnat, Ann Katrin\n\nbiography, 198\nPair Program and Feel the Flow, \n\n128\u2013129\nGarson, Edward\n\nApply Functional Programming \nPrinciples, 4\u20135\n\nbiography, 202\nGit, 136\nGoodliffe, Pete\n\nbiography, 213\nDon\u2019t Ignore That Error!, 52\u201353\nImprove Code by Removing It, 78\u201379\nYou Gotta Care About the Code, \n\n192\u2013193\nGoogle, 37, 68, 112, 204\nGregory, Janet\n\nbiography, 205\nWhen Programmers and Testers \n\nCollaborate, 184\u2013185\nGriffiths, Alan\n\nbiography, 196\nDon\u2019t Rely on \u201cMagic Happens Here\u201d, \n\n58\u201359\nGroovy, 115\nGuest, Thomas\n\nbiography, 218\nLearn to Say, \u201cHello, World\u201d, 102\u2013103\n\nguru myth, 72\u201373\n\nH\nhard work, 74\u201375\nHauknes, Gudny\n\nbiography, 204\nPair Program and Feel the Flow, \n\n128\u2013129\n\ndomain concepts in code, 22\u201323\ndomain-logical problems, 43\ndomain-specific languages (DSLs), 46\u201347\ndomain-specific typing, 130\u2013131\nDRY (Don\u2019t Repeat Yourself), 60\u201361, \n\n182\u2013183\nDugg, 51\nduplication, 60, 126\n\nE\nEBNF, 47\nencapsulation, 64\u201365\n\nviolating, 183\nErlang, 114\nerrno, 52\nerrors, 42, 52\u201353\n\nbuilds, 85\ncode reviews, 28\nformatting errors, 132\ninterfaces, 110\u2013111\nnot handling, 53\npreventing, 132\u2013133\ntesting tests, 191\n\nestimates, 100\u2013101\nEvans, Cal\n\nA Comment on Comments, 32\u201333\nbiography, 199\nDon\u2019t Touch That Code!, 62\u201363\n\nexceptions, 53\ndistinguishing business from technical, \n\n42\u201343\nmultiple exception handlers, 56\n\nexternal DSLs, 47\nextreme feedback device (XFD), 104\u2013105\n\nF\nfalse consensus bias, 6\nFeathers, Michael\n\nbiography, 210\nThe Golden Rule of API Design, 70\u201371\n\nfile formats and automation, 157\nFit (Framework for Integrated Test), 184\nFlibflarb, 51\nfloating-point numbers, 66\u201367\nFord, Neal\n\nbiography, 212\nTesting Is the Engineering Rigor of \n\nSoftware Development, 166\u2013167\nformatting errors, 132\nFortran, 54, 66, 88\n\n\n\n225Index\n\nHeidegger, Martin, 143\nHello, World program, 102\u2013103\nHenney, Kevlin\n\nbiography, 208\nComment Only What the Code \n\nCannot Say, 34\u201335\nTest for Required Behavior, Not \n\nIncidental Behavior, 160\u2013161\nTest Precisely and Concretely, 162\u2013163\n\nHohpe, Gregor\nbiography, 204\nConvenience Is Not an -ility, 38\u201339\n\nHolmes, Sherlock, 19, 192\nHomer, Paul W.\n\nbiography, 213\nSimplicity Comes from Reduction, \n\n150\u2013151\nHopper, Grace, 58\nHorstmann, Cay\n\nbiography, 199\nStep Back and Automate, Automate, \n\nAutomate, 156\u2013157\nHufnagel, Burk\n\nbiography, 198\nNews of the Weird: Testers Are Your \n\nFriends, 120\u2013121\nPut the Mouse Down and Step Away \n\nfrom the Keyboard, 138\u2013139\nhumanities, reading, 142\u2013143\nHunger, Michael\n\nbiography, 211\nDomain-Specific Languages, 46\u201347\n\nHunt, Andy, 54, 60\n\ni\nIDEs\n\nautomation, 156\nUnix tools, 176\n\nIDEs (Integrated Development \nEnvironments), 86\u201387, 90\u201391\n\nIEEE floating-point numbers, 66\u201367\ninappropriate text in code, 50\u201351\nincremental changes, 12\nincremental development, 113\ninstallation process, 40\u201341\ninstalling software, 80\u201381\ninterfaces, 110\u2013111\n\ndesigning, 111\npreventing errors, 133\n\ninterim solutions, 108\u2013109\n\ninternal DSLs, 46\ninterprocess communication, 82\u201383\ninvisibility, 112\u2013113\nissue tracker, 76\u201377\n\nj\nJackson, Nate\n\nbiography, 211\nYour Customers Do Not Mean What \n\nThey Say, 194\u2013195\nJagger, Jon\n\nbiography, 206\nDo Lots of Deliberate Practice, 44\u201345\nMake the Invisible More Visible, \n\n112\u2013113\nJava, 42, 55, 57, 64, 70, 85, 90, 97, 115, 131, \n\n160, 188\ninternal DSLs, 46\n\nJohnsson, Dan Bergh\nbiography, 200\nDistinguish Business Exceptions from \n\nTechnical, 42\u201343\nKnow Your Next Commit, 94\u201395\n\nK\nKabutz, Heinz\n\nbiography, 205\nKnow Your IDE, 90\u201391\n\nKarlsson, Mattias\nbiography, 210\nCode Reviews, 28\u201329\n\nkeeping a sustainable pace, 74\u201375\nKelly, Allan\n\nbiography, 197\nCheck Your Code First Before Looking \n\nto Blame Others, 18\u201319\nTwo Wrongs Can Make a Right (and \n\nAre Difficult to Fix), 172\u2013173\nKhan, Aslam\n\nbiography, 198\nUbuntu Coding for Your Friends, \n\n174\u2013175\nKimchi, Yechiel\n\nbiography, 220\nCoding with Reason, 30\u201331\n\nKlumpp, Allan, 172\nKnuth, Donald, 179\n\n\n\n226 Index\n\nL\nLandre, Einar\n\nbiography, 202\nEncapsulate Behavior, Not Just State, \n\n64\u201365\nPrefer Domain-Specific Types to \n\nPrimitive Types, 130\u2013131\nlanguages, 54\u201355\n\ncommunicating with peers, 98\u201399\nknowing more than two, 88\u201389\n\nlayout of code, 26\u201327\nlearning, continuous, 36\u201337\nLee, Paul, 102\nLewis, Mike\n\nbiography, 211\nDon\u2019t Be Afraid to Break Things, \n\n48\u201349\nlibraries, 15\u201316, 20\n\ngetting to know, 36\ninternal DSLs, 46\nprocess models and message passing, \n\n115\nlicensing terms, 21\nlimitations, knowing, 93\u201394\nLindner, Daniel\n\nbiography, 201\nLet Your Project Speak for Itself, \n\n104\u2013105\nlinear search, 93\nlinkers, 106\u2013107\nLINQ, 55\nLISP, 42\n\ninternal DSLs, 46\nlogging, verbose, 180\u2013181\n\nM\nMarquardt, Klaus\n\nbiography, 209\nLearn Foreign Languages, 98\u201399\nThe Longevity of Interim Solutions, \n\n108\u2013109\nMartin, Robert C. (Uncle Bob)\n\nbiography, 215\nThe Boy Scout Rule, 16\u201317\nThe Professional Programmer, \n\n134\u2013135\nThe Single Responsibility Principle, \n\n152\u2013153\n\nMaudal, Olve\nbiography, 212\nHard Work Does Not Pay Off, 74\u201375\n\nMcGuire, Kevin, 27\nmemory (cache), 93\nmentors, 36\nMercurial, 136\nMeszaros, Gerard\n\nbiography, 203\nWrite Tests for People, 190\u2013191\n\nMetaphors We Live By, 142\nMeyers, Scott\n\nbiography, 217\nMake Interfaces Easy to Use Correctly \n\nand Hard to Use Incorrectly, \n110\u2013111\n\nmicro-optimization, 179\nMiller, Alex\n\nbiography, 197\nStart from Yes, 154\u2013155\n\nmonitoring, 180\u2013181\nMonson-Haefel, Richard\n\nbiography, 214\nFulfill Your Ambitions with Open \n\nSource, 68\u201369\nMount, Sarah\n\nbiography, 216\nTake Advantage of Code Analysis \n\nTools, 158\u2013159\nmultithreaded problems, 19\n\nsingletons and, 146\u2013147\nmultithreaded systems, 115\u2013116\nMurrow, Edward R., xxiii\nMySQL, 96\n\nN\nNatural Categories, 143\nNilsson, Niclas\n\nbiography, 212\nThinking in States, 168\u2013169\n\nNor\u00e5s, Anders\nbiography, 197\nDon\u2019t Just Learn the Language, \n\nUnderstand Its Culture, 54\u201355\nNorth, Dan\n\nbiography, 201\nCode in the Language of the Domain, \n\n22\u201323\nNorvig, Peter, 44\nNosek, J. T., 171\n\n\n\n227Index\n\nO\n\u00d8lmheim, J\u00f8rn\n\nBeauty Is in Simplicity, 10\u201311\nbiography, 207\n\nOnce and Only Once principle, 61\nopenArchitectureWare, 47\nOpen/Closed Principle, 61\nopen source, 11, 68\u201369, 96, 140\noptimization, 83, 92, 97, 148, 179\norder, 1\n\nP\npair programming, 128\u2013129, 170\u2013171\nparallelism, 114\u2013115\nparsimony, 83\nPascal, 66, 88\nPatterns of Enterprise Application \n\nArchitecture, 82\nPepperdine, Kirk\n\nbiography, 208\nMissing Opportunities for \n\nPolymorphism, 118\u2013119\nThe Road to Performance Is Littered \n\nwith Dirty Code Bombs, \n148\u2013149\n\nWET Dilutes Performance Bottlenecks, \n182\u2013183\n\nperformance\nbottlenecks, 182\u2013183\nmanagement, 82\u201383\ntests, 165\n\nPhilosophical Investigations, 142\nPlato, 10\npolymorphism, 118\u2013119\nPoppendieck, Mary, 44\nPostgreSQL, 96\nThe Pragmatic Programmer, 54, 60\nprocess bottlenecks, 28\nprofessional programmers, 134\u2013135\nprofiling tool, 178\nprogramming languages (see languages)\nproject management, providing estimates, \n\n100\u2013101\nProlog, 88\nPylint, 159\nPython, 55, 67, 115, 131\n\nPylint, 159\nstandard library, 159\n\nR\nRDBMS systems, 96\u201397\nreadability of code, 10, 26\u201327, 31, 38, \n\n46\u201347, 130, 163\nreading code (see code, reading)\nReeves, Jack, 166\nrefactoring code, 12\u201313, 125\nreinventing the wheel, 144\u2013145, 179\nremoving code, 78\u201379, 150\u2013151\nrepetition\n\nlogic, 61\npractice, 44\nprocess, 60\n\nrepetitive tasks, 156\nresponse time, 82\u201383\nreturn code, 52\nreviews, code (see code, reviews)\nripple loading, 82\nRising, Linda\n\nA Message to the Future, 116\u2013117\nbiography, 209\n\nRobinson, Carroll\nbiography, 199\nKnow How to Use Command-Line \n\nTools, 86\u201387\nRosch, Eleanor, 143\nRose, Seb\n\nAct with Prudence, 2\u20133\nbiography, 217\n\nR\u00f8ssland, Kari\nbiography, 207\nPair Program and Feel the Flow, \n\n128\u2013129\nRuby, 55, 97\n\ninternal DSLs, 46\n\nS\nSaariste, Sam\n\nbiography, 216\nResist the Temptation of the Singleton \n\nPattern, 146\u2013147\nSableCC, 47\nSage, Jason P.\n\nbiography, 206\nReinvent the Wheel Often, 144\u2013145\n\nScala, 55\ninternal DSLs, 46\n\n\n\n228 Index\n\nschedules\ndirty code, 148\u2013149\nprofessional programmers, 134\ntechnical debt, 2\u20133\n\nShank, Clint\nbiography, 200\nContinuous Learning, 36\u201337\n\nshared memory, 114\u2013115\nsimplicity, 10\u201311, 150\u2013151\nsingle binary, 122\u2013123\nsingle responsibility principle, 152\u2013153\nSingle Responsibility Principle, 61\nsingletons, 146\u2013147\n\ncleanup of, 147\nSmalltalk, 42\nsmearing, 67\nSmith, Steve\n\nbiography, 218\nDon\u2019t Repeat Yourself, 60\u201361\n\nsoak test, 164\nsoftware metrics, 148\u2013149\nsolutions, interim, 108\u2013109\nSommerlad, Peter\n\nbiography, 213\nOnly the Code Tells the Truth, \n\n124\u2013125\nsource control, 62\u201363, 136\u2013137\nSpinellis, Diomidis\n\nbiography, 201\nLarge, Interconnected Data Belongs to \n\na Database, 96\u201397\nPut Everything Under Version Control, \n\n136\u2013137\nThe Unix Tools Are Your Friends, \n\n176\u2013177\nSplint, 159\nSQL, 96\nStafford, Randy\n\nbiography, 214\nInterprocess Communication Affects \n\nApplication Response Time, \n82\u201383\n\nstates, 168\u2013169\nstatic code analysis, 104\nstatic code analyzers, 30\u201331\nStob, Verity\n\nbiography, 219\nDon\u2019t Nail Your Program into the \n\nUpright Position, 56\u201357\nSubversion, 136\nsymbols, 107\n\nT\ntaking a break, 138\u2013139\ntargets, 101, 123\ntechnical debt, 2\u20133\ntesting, 120\u2013121, 134, 166\u2013167, 191\n\nautomated tests, 165\ncollaboration with programmers, 184\u2013185\nfor required behavior, 160\u2013161\nperformance tests, 165\nprecisely and concretely, 162\u2013163\nrunning tests before committing code, \n\n164\nsoak test, 164\ntest data, inappropriate text in, 50\u201351\ntest servers, 164\u2013165\nvalid and invalid states and transitions, \n\n169\nwriting tests, 190\u2013191\n\nThomas, Dave, 54, 60\ntools\n\nautomation, 157\ncode analysis, 158\u2013159\ncommand-line build tools, 86\u201387\nselecting, 20\u201321\nUnix, 176\u2013177\n\nTwitter, 51\ntyping, domain-specific, 130\u2013131\n\nU\nUbuntu coding, 174\u2013175\nUncle Bob (see Martin, Robert C.)\nunit tests, 19, 71, 78, 113, 131\n\nimplicit persistent state, 146\nUnix tools, 91, 176\u2013177\nusers, thinking like, 6\u20137\n\nV\nvan Emde Boas tree, 93\nvan Laenen, Filip\n\nAutomate Your Coding Standard, 8\u20139\nbiography, 203\n\nvan Winkel, Jan Christiaan \u201cJC\u201d\nbiography, 205\nUse the Right Algorithm and Data \n\nStructure, 178\u2013179\nvendor lock-in, 21\nversion control systems (see source control)\nversioning environment information, 123\nvisual pattern matching, 26\n\n\n\n229Index\n\nW\nWET (Write Every Time), 182\u2013183\nWhat is Software Design?, 166\nWible, Adrian\n\nbiography, 196\nTwo Heads Are Often Better Than \n\nOne, 170\u2013171\nWinder, Russel\n\nbiography, 216\nKnow Well More Than Two \n\nProgramming Languages, 88\u201389\nMessage Passing Leads to Better \n\nScalability in Parallel Systems, \n114\u2013115\n\nWittgenstein, Ludwig, 142\nworking together, 154\u2013155, 170\u2013171\n\ncollaboration between testers and \nprogrammers, 184\u2013185\n\ncustomers\u2019 requests, 194\nworking too hard, 74\u201375, 138\u2013139\n\nx\nXFDs (extreme feedback device), 104\u2013105\nXML, 47\n\nY\nyes, starting at, 154\u2013155\n\nz\nZubarev, Yuriy\n\nbiography, 220\nWrite Code As If You Had to Support \n\nIt for the Rest of Your Life, \n186\u2013187\n\n\n\n\n\nThe cover and heading font is Gotham; the text font is Minion Pro; and the \ncode font is TheSansMonoCondensed. \n\nColophon\n\n\n\tContributions by Category\n\tPreface\n\tAct with Prudence\n\tSeb Rose\n\n\tApply Functional Programming Principles\n\tEdward Garson\n\n\tAsk, \u201cWhat Would the User Do?\u201d (You Are Not the User)\n\tGiles Colborne\n\n\tAutomate Your Coding Standard\n\tFilip van Laenen\n\n\tBeauty Is in Simplicity\n\tJ\u00f8rn \u00d8lmheim\n\n\tBefore You Refactor\n\tRajith Attapattu\n\n\tBeware the Share\n\tUdi Dahan\n\n\tThe Boy Scout Rule\n\tRobert C. Martin (Uncle Bob)\n\n\tCheck Your Code First Before Looking to Blame Others\n\tAllan Kelly\n\n\tChoose Your Tools with Care\n\tGiovanni Asproni\n\n\tCode in the Language of the Domain\n\tDan North\n\n\tCode Is Design\n\tRyan Brush\n\n\tCode Layout Matters\n\tSteve Freeman\n\n\tCode Reviews\n\tMattias Karlsson\n\n\tCoding with Reason\n\tYechiel Kimchi\n\n\tA Comment on Comments\n\tCal Evans\n\n\tComment Only What the Code Cannot Say\n\tKevlin Henney\n\n\tContinuous Learning\n\tClint Shank\n\n\tConvenience Is Not an -ility\n\tGregor Hohpe\n\n\tDeploy Early and Often\n\tSteve Berczuk\n\n\tDistinguish Business Exceptions from Technical\n\tDan Bergh Johnsson\n\n\tDo Lots of Deliberate Practice\n\tJon Jagger\n\n\tDomain-Specific Languages\n\tMichael Hunger\n\n\tDon\u2019t Be Afraid to Break Things\n\tMike Lewis\n\n\tDon\u2019t Be Cute with Your Test Data\n\tRod Begbie\n\n\tDon\u2019t Ignore That Error!\n\tPete Goodliffe\n\n\tDon\u2019t Just Learn the Language, Understand Its Culture\n\tAnders Nor\u00e5s\n\n\tDon\u2019t Nail Your Program into the Upright Position\n\tVerity Stob\n\n\tDon\u2019t Rely on \u201cMagic Happens Here\u201d\n\tAlan Griffiths\n\n\tDon\u2019t Repeat Yourself\n\tSteve Smith\n\n\tDon\u2019t Touch That Code!\n\tCal Evans\n\n\tEncapsulate Behavior, Not Just State\n\tEinar Landre\n\n\tFloating-Point Numbers Aren\u2019t Real\n\tChuck Allison\n\n\tFulfill Your Ambitions with Open Source\n\tRichard Monson-Haefel\n\n\tThe Golden Rule of API Design\n\tMichael Feathers\n\n\tThe Guru Myth\n\tRyan Brush\n\n\tHard Work Does Not Pay Off\n\tOlve Maudal\n\n\tHow to Use a Bug Tracker\n\tMatt Doar\n\n\tImprove Code by Removing It\n\tPete Goodliffe\n\n\tInstall Me\n\tMarcus Baker\n\n\tInterprocess Communication Affects Application Response Time\n\tRandy Stafford\n\n\tKeep the Build Clean\n\tJohannes Brodwall\n\n\tKnow How to Use Command-Line Tools\n\tCarroll Robinson\n\n\tKnow Well More Than Two Programming Languages\n\tRussel Winder\n\n\tKnow Your IDE\n\tHeinz Kabutz\n\n\tKnow Your Limits\n\tGreg Colvin\n\n\tKnow Your Next Commit\n\tDan Bergh Johnsson\n\n\tLarge, Interconnected Data Belongs to a Database\n\tDiomidis Spinellis\n\n\tLearn Foreign Languages\n\tKlaus Marquardt\n\n\tLearn to Estimate\n\tGiovanni Asproni\n\n\tLearn to Say, \u201cHello, World\u201d\n\tThomas Guest\n\n\tLet Your Project Speak for Itself\n\tDaniel Lindner\n\n\tThe Linker Is Not a Magical Program\n\tWalter Bright\n\n\tThe Longevity of Interim Solutions\n\tKlaus Marquardt\n\n\tMake Interfaces Easy to Use Correctly and Hard to Use Incorrectly\n\tScott Meyers\n\n\tMake the Invisible More Visible\n\tJon Jagger\n\n\tMessage Passing Leads to Better Scalability in Parallel Systems\n\tRussel Winder\n\n\tA Message to the Future\n\tLinda Rising\n\n\tMissing Opportunities for Polymorphism\n\tKirk Pepperdine\n\n\tNews of the Weird: Testers Are Your Friends\n\tBurk Hufnagel\n\n\tOne Binary\n\tSteve Freeman\n\n\tOnly the Code Tells the Truth\n\tPeter Sommerlad\n\n\tOwn (and Refactor) the Build\n\tSteve Berczuk\n\n\tPair Program and Feel the Flow\n\tGudny Hauknes, Kari R\u00f8ssland, and Ann Katrin Gagnat\n\n\tPrefer Domain-Specific Types to Primitive Types\n\tEinar Landre\n\n\tPrevent Errors\n\tGiles Colborne\n\n\tThe Professional Programmer\n\tRobert C. Martin (Uncle Bob)\n\n\tPut Everything Under Version Control\n\tDiomidis Spinellis\n\n\tPut the Mouse Down and Step Away from the Keyboard\n\tBurk Hufnagel\n\n\tRead Code\n\tKarianne Berg\n\n\tRead the Humanities\n\tKeith Braithwaite\n\n\tReinvent the Wheel Often\n\tJason P. Sage\n\n\tResist the Temptation of the Singleton Pattern\n\tSam Saariste\n\n\tThe Road to Performance Is Littered with Dirty Code Bombs\n\tKirk Pepperdine\n\n\tSimplicity Comes from Reduction\n\tPaul W. Homer\n\n\tThe Single Responsibility Principle\n\tRobert C. Martin (Uncle Bob)\n\n\tStart from Yes\n\tAlex Miller\n\n\tStep Back and Automate, Automate, Automate\n\tCay Horstmann\n\n\tTake Advantage of Code Analysis Tools\n\tSarah Mount\n\n\tTest for Required Behavior, Not Incidental Behavior\n\tKevlin Henney\n\n\tTest Precisely and Concretely\n\tKevlin Henney\n\n\tTest While You Sleep (and over Weekends)\n\tRajith Attapattu\n\n\tTesting Is the Engineering Rigor of Software Development\n\tNeal Ford\n\n\tThinking in States\n\tNiclas Nilsson\n\n\tTwo Heads Are Often Better Than One\n\tAdrian Wible\n\n\tTwo Wrongs Can Make a Right (and Are Difficult to Fix)\n\tAllan Kelly\n\n\tUbuntu Coding for Your Friends\n\tAslam Khan\n\n\tThe Unix Tools Are Your Friends\n\tDiomidis Spinellis\n\n\tUse the Right Algorithm and Data Structure\n\tJan Christiaan \u201cJC\u201d van Winkel\n\n\tVerbose Logging Will Disturb Your Sleep\n\tJohannes Brodwall\n\n\tWET Dilutes Performance Bottlenecks\n\tKirk Pepperdine\n\n\tWhen Programmers and Testers Collaborate\n\tJanet Gregory\n\n\tWrite Code As If You Had to Support It for the Rest of Your Life\n\tYuriy Zubarev\n\n\tWrite Small Functions Using Examples\n\tKeith Braithwaite\n\n\tWrite Tests for People\n\tGerard Meszaros\n\n\tYou Gotta Care About the Code\n\tPete Goodliffe\n\n\tYour Customers Do Not Mean What They Say\n\tNate Jackson\n\n\tContributors\n\tIndex\n\n\n\n"
    },
    {
      "file_name": "import-this.png",
      "mergedText": " import this \"\" \"The Zen of Python, by Tim Peters. (poster by Joachim Jablon) \"\"\" 1 Beautiful is better than ugly. Explicit is better than impl .. 3 Simple is better than complex. 4 Complex is better than comp1 | c@ted. 15 Flat is better than nested. 6 Sparse is better than dense. 7 Readability counts. 8 Special cases aren't special enough to break the rules. 9 Although practicality beats purity. 10 raise PythonicError(\"Errors should never pass silently.\") 11 # Unless explicitly silenced. 12 In the face of ambiguity, refuse the temptation to guess. 13 There should be one -- and preferably only one -- obvious way to do it. 14 # Although that way may not be obvious at first unless you're Dutch. 15 Now is better than never. 16 Although never is often better thanrightnow. 17 If the implementation is hard to explain, it's a bad idea. 18 If the implementation is easy to explain, it may be a good idea. 19 Namespaces are one honking great idea -- let's do more of those! \n"
    },
    {
      "file_name": "pyf-onedrop.png",
      "mergedText": " Flask web development, one drop at a time web web web web \n"
    },
    {
      "file_name": "vnwmap.gif",
      "mergedText": " CHINA Cao Bang NORTH Lao Cai Red VIETNAM 22\u00aaN Lang Son Black Viel The Thai Dien Nguyen Bien Phu R. HanoiQ Hon Gay Gia Lam Hai Phong Cat Bi Nam Dinh 20 9 LAOS ThoungIl Thanh Hoa Quan Lang Hleh Me Hainan I. Vinh Gulf of (China) Tonkin Ha Tinh -18'N Ron Quang Ke Quang Tri Khe Sanhe City Hue Da Nang 16\u00baN THAILAND A Shaus An Hoa Tam Ky Chu Lai Ba Gia Quang Ngai Dak To Ja Drang Kontum Valley Pleiku -14\u00baN \"Duc Co _Quy Nhon Chu Pong: \"Plet Me Phu Cat Mtn. SOUTH Tuy Hoa CAMBODIA VIETNAM. Nha Trang -12'N Gulf of Sam Rahn Bay Song Be Thailand Dong Koa Phan Rang Ap ESBien Hoa\" Phan Thiet Kompong Bac Saigon Binh Gia Som MyTho -10ON South Rach Gia> Sa Dec China Sea Kanh Hung 50 100 ml *Bac Lieu Quan 50 100 km Long 100E 10.2\u00baE 104\u00baE 106\u00aaE 108'E 110\u00baE Areas of Prolonged Confrontation: Major battle Demilitarization Zone (DMZ) 1965 U.S. aerial I Major North bombardment Vietnamese base \u20a6\u00aa 1966 Z 1967 Ho Chi Minh Trail II Major U.S. base \n"
    }
]